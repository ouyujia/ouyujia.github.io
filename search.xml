<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>QT串口通讯错误码解析</title>
      <link href="/2023/05/01/QT%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF%E9%94%99%E8%AF%AF%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/05/01/QT%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF%E9%94%99%E8%AF%AF%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>项目使用qt串口接口QSerialPort进行串口通讯，生产反馈产品提示串口通讯异常，查看log发现有3个错误码</p><p>分别是PermissionError(2)、WriteError(7)、UnknownError(11)。后面分析日志、了解生产情况找到了问题点。</p><blockquote><ul><li>PermissionError原因：串口占用，生产电脑上面先跑了串口调试工具导致串口打开失败</li><li>WriteError及UnknownError原因：（这连个错误是同时出现的额，先报WriteError后面紧跟UnknownError）通过对比日志发现是Windows自动睡眠后再次唤醒出现的。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682670665137.png" alt="1682670665137"></p></blockquote><h3 id="QT串口通讯错误码及机翻"><a href="#QT串口通讯错误码及机翻" class="headerlink" title="QT串口通讯错误码及机翻"></a>QT串口通讯错误码及机翻</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SerialPortError</span> {</span><br><span class="line">        NoError, <span class="comment">// 没有错误</span></span><br><span class="line">    </span><br><span class="line">        DeviceNotFoundError,<span class="comment">// 试图打开不存在的设备时发生错误。</span></span><br><span class="line">    </span><br><span class="line">        PermissionError,<span class="comment">// 1、试图打开另一个进程已打开的设备时</span></span><br><span class="line">    <span class="comment">// 2、用户没有足够的权限和凭据打开时发生错误。</span></span><br><span class="line">    </span><br><span class="line">        OpenError,<span class="comment">// 试图打开本进程中已打开的设备时发生错误。</span></span><br><span class="line">    </span><br><span class="line">        ParityError,<span class="comment">// 读取数据时，硬件检测到奇偶校验错误。</span></span><br><span class="line">    <span class="comment">// 这个值已经过时了。我们强烈建议不要在新代码中使用它。</span></span><br><span class="line">    </span><br><span class="line">        FramingError,<span class="comment">// 读取数据时硬件检测到帧错误。</span></span><br><span class="line">    <span class="comment">// 这个值已经过时了。我们强烈建议不要在新代码中使用它。</span></span><br><span class="line">    </span><br><span class="line">        BreakConditionError,<span class="comment">// 硬件在输入线上检测到断路情况。</span></span><br><span class="line">    <span class="comment">// 这个值已经过时了。我们强烈建议不要在新代码中使用它。</span></span><br><span class="line">    </span><br><span class="line">        WriteError,<span class="comment">// 写入数据时发生I/O错误。</span></span><br><span class="line">    </span><br><span class="line">        ReadError,<span class="comment">// 读取数据时发生I/O错误。</span></span><br><span class="line">    </span><br><span class="line">        ResourceError,<span class="comment">// 当资源不可用时发生I/O错误，例如当设备意外地从系统中移除时。</span></span><br><span class="line">    </span><br><span class="line">        UnsupportedOperationError, <span class="comment">//当前操作系统不支持或不禁止所请求的设备操作。</span></span><br><span class="line">    </span><br><span class="line">        UnknownError,<span class="comment">// 发生了一个无法识别的错误。</span></span><br><span class="line">    </span><br><span class="line">        TimeoutError,<span class="comment">// 发生超时错误。这个值是在QtSerialPort 5.2中引入的。</span></span><br><span class="line">    </span><br><span class="line">        NotOpenError<span class="comment">// 当执行的操作只有在设备打开的情况下才能成功执行时，会发生此错误。</span></span><br><span class="line">            <span class="comment">// 这个值是在QtSerialPort 5.2中引入的。</span></span><br><span class="line">    };</span><br></pre></td></tr></tbody></table></figure><h3 id="串口错误码处理"><a href="#串口错误码处理" class="headerlink" title="串口错误码处理"></a>串口错误码处理</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">m_uart = <span class="keyword">new</span> <span class="built_in">QSerialPort</span>();  <span class="comment">//不能指定父对象</span></span><br><span class="line"><span class="comment">//! 连接串口通信错误信号</span></span><br><span class="line"><span class="built_in">connect</span>(m_uart, <span class="built_in">SIGNAL</span>(<span class="built_in">errorOccurred</span>(QSerialPort::SerialPortError)), <span class="keyword">this</span>,</span><br><span class="line">        <span class="built_in">SLOT</span>(<span class="built_in">errorFunc</span>(QSerialPort::SerialPortError)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//! 串口通信错误吗处理接口 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UartPortThread::errorFunc</span><span class="params">(QSerialPort::SerialPortError error)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (error != QSerialPort::NoError &amp;&amp; error != QSerialPort::TimeoutError</span><br><span class="line">            &amp;&amp; error != QSerialPort::NotOpenError &amp;&amp; error !=      QSerialPort::DeviceNotFoundError)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; Q_FUNC_INFO &lt;&lt; QString::<span class="built_in">number</span>(error) &lt;&lt; <span class="string">"error...."</span>;</span><br><span class="line">        m_needReconnect = <span class="literal">true</span>;</span><br><span class="line">        <span class="function">emit <span class="title">uartConnectState</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">setPortName</span>(<span class="string">""</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
            <tag> 串口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT使用MingW编译器添加Dump调试功能</title>
      <link href="/2023/04/28/QTMingW%E6%B7%BBDump%E5%8A%9F%E8%83%BD/"/>
      <url>/2023/04/28/QTMingW%E6%B7%BBDump%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>最近因为维护的项目出现崩溃，客户现场的log无法定位，因此需要使用dump文件调试于是查找资料添加了一个崩溃生成dump文件功能</p></blockquote><hr><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><blockquote><p>Qt5.12.9-MingW版本/Qt5.5.1-MingW版本，Visual Studio 2017/Visual Studio 2013，Windows系统</p></blockquote><hr><h2 id="配置pro文件，在exe文件加入调试信息"><a href="#配置pro文件，在exe文件加入调试信息" class="headerlink" title="配置pro文件，在exe文件加入调试信息"></a>配置pro文件，在exe文件加入调试信息</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QMAKE_CFLAGS_RELEASE += -g</span><br><span class="line">QMAKE_CXXFLAGS_RELEASE += -g</span><br><span class="line">#禁止优化</span><br><span class="line">QMAKE_CFLAGS_RELEASE -= -O2</span><br><span class="line">QMAKE_CXXFLAGS_RELEASE -= -O2</span><br><span class="line">QMAKE_LFLAGS_RELEASE = -mthreads -W</span><br><span class="line">#生成dump文件需要</span><br><span class="line">LIBS += -lDbgHelp</span><br><span class="line">#加上下面两行，否则用vs调试时，提示“未找到xxx.exe<span class="string">"</span></span><br><span class="line"><span class="string">QMAKE_CXXFLAGS += -g</span></span><br><span class="line"><span class="string">QMAKE_CFLAGS += -g</span></span><br></pre></td></tr></tbody></table></figure><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDir&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;qdebug.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDateTime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;qglobal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMap&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_WIN</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dbghelp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_WIN</span></span><br><span class="line"><span class="comment">//! 异常处理回调（崩溃时自动调用）</span></span><br><span class="line"><span class="function"><span class="type">static</span> LONG WINAPI <span class="title">exceptionCallback</span><span class="params">(<span class="keyword">struct</span> _EXCEPTION_POINTERS* exceptionInfo)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QCoreApplication *app = QApplication::<span class="built_in">instance</span>();</span><br><span class="line"></span><br><span class="line">    QString savePath = app-&gt;<span class="built_in">applicationDirPath</span>() + <span class="string">"dump/"</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"save path :"</span>&lt;&lt;savePath;</span><br><span class="line">    <span class="function">QDir <span class="title">dir</span><span class="params">(savePath)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!dir.<span class="built_in">exists</span>() &amp;&amp; !dir.<span class="built_in">mkpath</span>(savePath)) {</span><br><span class="line">        app-&gt;<span class="built_in">exit</span>(E_UNEXPECTED);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_EXECUTE_HANDLER;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    savePath.<span class="built_in">append</span>(<span class="string">"assit_"</span>);</span><br><span class="line">    savePath.<span class="built_in">append</span>(QDateTime::<span class="built_in">currentDateTime</span>().<span class="built_in">toString</span>(<span class="string">"yyyyMMddhhmmsszzz"</span>));</span><br><span class="line">    savePath.<span class="built_in">append</span>(<span class="string">".dmp"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建dump文件</span></span><br><span class="line">    HANDLE dump = <span class="built_in">CreateFileW</span>(savePath.<span class="built_in">toStdWString</span>().<span class="built_in">c_str</span>(), GENERIC_WRITE,</span><br><span class="line">        <span class="number">0</span>, <span class="literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (INVALID_HANDLE_VALUE == dump) {</span><br><span class="line">        app-&gt;<span class="built_in">exit</span>(E_UNEXPECTED);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_EXECUTE_HANDLER;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    MINIDUMP_EXCEPTION_INFORMATION miniDumpExceptionInfo;</span><br><span class="line">    miniDumpExceptionInfo.ExceptionPointers = exceptionInfo;</span><br><span class="line">    miniDumpExceptionInfo.ThreadId = <span class="built_in">GetCurrentThreadId</span>();</span><br><span class="line">    miniDumpExceptionInfo.ClientPointers = TRUE;</span><br><span class="line">    DWORD idProcess = <span class="built_in">GetCurrentProcessId</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将崩溃信息写入dump文件中</span></span><br><span class="line">    <span class="built_in">MiniDumpWriteDump</span>(<span class="built_in">GetCurrentProcess</span>(), idProcess, dump,</span><br><span class="line">        MiniDumpNormal, &amp;miniDumpExceptionInfo, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(dump);</span><br><span class="line"></span><br><span class="line">    app-&gt;<span class="built_in">exit</span>(E_UNEXPECTED);</span><br><span class="line">    <span class="keyword">return</span> EXCEPTION_EXECUTE_HANDLER;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//! 空指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">crashNullPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//空指针测试</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span>* p_a = (<span class="type">int</span>*)(<span class="literal">NULL</span>); *p_a = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//! 悬浮指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">crashFloatPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span>* p_a = &amp;a;</span><br><span class="line">    <span class="keyword">delete</span> p_a;</span><br><span class="line">    *p_a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"*p_a :"</span>&lt;&lt; *p_a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//! 野指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">crashWildPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span>* p_a;</span><br><span class="line">    *p_a = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"*p_a :"</span>&lt;&lt; *p_a;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//! array越界</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ArrayExceed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">2</span>] = {<span class="number">0</span>, <span class="number">1</span>};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        arr[i] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"arr[i]"</span>&lt;&lt; arr[i];</span><br><span class="line">    }</span><br><span class="line">    arr[<span class="number">1000</span>] = <span class="number">11111</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"arr[10000]"</span>&lt;&lt; arr[<span class="number">10000</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Vector越界</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VectorExceed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; vec = {<span class="number">0</span>, <span class="number">1</span>};</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        value = vec.<span class="built_in">at</span>(i);</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"arr.at(i)"</span>&lt;&lt; value;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"arr[10000]"</span>&lt;&lt; vec.<span class="built_in">at</span>(<span class="number">10000</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Vector越界</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VectorExceed2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; vec = {<span class="number">0</span>, <span class="number">1</span>};</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        vec[i] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"arr[i]"</span>&lt;&lt; vec[i];</span><br><span class="line">    }</span><br><span class="line">    vec[<span class="number">1000</span>] = <span class="number">11111</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"arr[10000]"</span>&lt;&lt; vec[<span class="number">10000</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//! list越界</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListExceed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QList&lt;<span class="type">int</span>&gt; list = {<span class="number">0</span>, <span class="number">1</span>};</span><br><span class="line">    list[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Map</span></span><br><span class="line"><span class="comment">//void MapExceed()</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//    QMap&lt;int, QString&gt; map;</span></span><br><span class="line"><span class="comment">//    map.insert(0, "frist");</span></span><br><span class="line"><span class="comment">//    map.insert(1, "second");</span></span><br><span class="line"><span class="comment">//    map.remove(3);</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_WIN</span></span><br><span class="line">    <span class="comment">//! 注册异常奔溃回调</span></span><br><span class="line">    <span class="built_in">SetUnhandledExceptionFilter</span>(exceptionCallback);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//测试接口</span></span><br><span class="line"><span class="comment">//    crashNullPtr();</span></span><br><span class="line"><span class="comment">//    crashFloatPtr();</span></span><br><span class="line"><span class="comment">//    crashWildPtr();</span></span><br><span class="line"><span class="comment">//    ArrayExceed();</span></span><br><span class="line">    <span class="built_in">VectorExceed</span>();</span><br><span class="line"><span class="comment">//    VectorExceed2();</span></span><br><span class="line"><span class="comment">//    ListExceed();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="生成pdb文件"><a href="#生成pdb文件" class="headerlink" title="生成pdb文件"></a>生成pdb文件</h2><blockquote><p>注：WingW编译器并不会像MSVC一样自动生成pdb文件需要使用第三方工具生成。这里使用github开源工具<strong>cv2pdb.exe</strong>生成。</p></blockquote><h3 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h3><p><a href="https://github.com/rainers/cv2pdb">下载链接</a></p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682242797578.png" alt="1682242797578"></p><p>下载下来使用vs2017编译源码的到cv2pdb.exe文件。</p><h3 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h3><blockquote><p>使用命令行(cmd)</p><ol><li>打开命令行，cd到cv2pdb.exe文件路径下</li><li>执行指令 “cv2pdb.exe  xxx.exe”即可在xxx.exe同级路径下生成xxx.pdb文件</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682243028125.png" alt="1682243028125"></p><h3 id="出现错误："><a href="#出现错误：" class="headerlink" title="出现错误："></a>出现错误：</h3><blockquote><p><strong>qBreakpadTest.pdb: cannot load PDB helper DLL</strong></p></blockquote><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p><strong>错误原因：电脑没有安装Visual Studio环境</strong></p><blockquote><p>安装Visual Studio即可解决</p></blockquote><hr><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><hr><h3 id="使用Visual-Studio-IDE调试（推荐）"><a href="#使用Visual-Studio-IDE调试（推荐）" class="headerlink" title="使用Visual Studio IDE调试（推荐）"></a>使用Visual Studio IDE调试（推荐）</h3><h4 id="加载pdb文件"><a href="#加载pdb文件" class="headerlink" title="加载pdb文件"></a>加载pdb文件</h4><blockquote><p>使用Visual Studio打开需要调试的pdb文件(将exe文件和pdb放到同一目录下，然后设置符合路径)</p></blockquote><hr><h4 id="设置调试pdb目录位置"><a href="#设置调试pdb目录位置" class="headerlink" title="设置调试pdb目录位置"></a>设置调试pdb目录位置</h4><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682243563126.png" alt="1682243563126"></p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682243641185.png" alt="1682243641185"></p><hr><h4 id="设置源码目录"><a href="#设置源码目录" class="headerlink" title="设置源码目录"></a>设置源码目录</h4><p>在解决方案-属性，打开弹窗设置</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682243771250.png" alt="1682243771250"></p><h4 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h4><blockquote><p>点击 “使用 仅限本机 进行调试”</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682243822104.png" alt="1682243822104"></p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/kk_image.jpg" alt="img"></p><hr><h3 id="使用Windows调试器windbg-exe调试"><a href="#使用Windows调试器windbg-exe调试" class="headerlink" title="使用Windows调试器windbg.exe调试"></a>使用Windows调试器windbg.exe调试</h3><blockquote><p><a href="https://developer.microsoft.com/zh-cn/windows/downloads/windows-sdk/">下载链接</a></p><p>此链接是下载Windows SDK安装包的，Windows SDK安装包含windbg.exe。</p></blockquote><h4 id="调试步骤"><a href="#调试步骤" class="headerlink" title="调试步骤"></a>调试步骤</h4><blockquote><ol><li>双击打开windbg.exe，选择相应版本</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682405908877.png" alt="1682405865975"></p><ol start="2"><li>依次完成如下配置<br>打开File 需要完成 Symbol File Path 、Source File Path、Image File Path 的配置</li><li>Symbol File Path ：这里就是加載pdb文件的路徑</li><li>Source File Path: 加载程序代码 存放的路径（注意切回發佈版本的代碼）</li><li>Image File Path: 加載exe 存放的路徑</li><li>選擇Open Crash Dump 導入生成的dmp文件</li><li>输入命令 !analyze -v ，等待几秒后会打印出错误信息</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682407236891.png" alt="1682407236891"></p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682407088643.png" alt="1682407088643"></p></blockquote><p>1、Symbol File Path ：這裏就是加載pdb文件的路徑，我們直接使用</p><p>D:/Project/DumTools/<br>1<br>2、 Source File Path: 加载程序代码 存放的路径（注意切回發佈版本的代碼）</p><p>D:/Project/Demo/<br>1<br>3、Image File Path: 加載exe 存放的路徑</p><p>D:/Project/DumTools/<br>1<br>4、選擇Open Crash Dump 導入生成的dmp文件</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><blockquote><ul><li>用于崩溃调试的dump、pdb、源码需要是同一个版本，一般为发布版本（即客户版本）</li><li>用于崩溃调试的dump、pdb、源码需要区分debug和release否则无法调试</li></ul></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ol><li><a href="https://blog.csdn.net/LiHong333/article/details/129798322?spm=1001.2014.3001.5502">Qt-mingw 生成dump文件并使用vs调试定位错误代码_qt生成dump文件</a></li><li><a href="https://libaineu2004.blog.csdn.net/article/details/108310384?spm=1001.2014.3001.5502">Qt如何在Release编译下怎么调试？怎么生成pdb文件</a></li><li><a href="https://blog.csdn.net/HeroGuo_JP/article/details/105383752"> Window端Qt Create dmp的生成与解析</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
            <tag> MingW </tag>
            
            <tag> Dump </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT数据库</title>
      <link href="/2022/05/28/QT%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2022/05/28/QT%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>QT模型/视图</title>
      <link href="/2022/05/28/QT%E6%A8%A1%E5%9E%8B-%E8%A7%86%E5%9B%BE/"/>
      <url>/2022/05/28/QT%E6%A8%A1%E5%9E%8B-%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>QT样式基类</title>
      <link href="/2022/05/28/QT%E6%A0%B7%E5%BC%8F%E5%9F%BA%E7%B1%BB/"/>
      <url>/2022/05/28/QT%E6%A0%B7%E5%BC%8F%E5%9F%BA%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>QT自定义部件</title>
      <link href="/2022/05/28/QT%E8%87%AA%E5%AE%9A%E4%B9%89%E9%83%A8%E4%BB%B6/"/>
      <url>/2022/05/28/QT%E8%87%AA%E5%AE%9A%E4%B9%89%E9%83%A8%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>QT绘图</title>
      <link href="/2022/05/28/QT%E7%BB%98%E5%9B%BE/"/>
      <url>/2022/05/28/QT%E7%BB%98%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>QT串口通讯</title>
      <link href="/2022/05/28/QT%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF/"/>
      <url>/2022/05/28/QT%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>QT网络通讯</title>
      <link href="/2022/05/28/QT%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/"/>
      <url>/2022/05/28/QT%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>QT线程</title>
      <link href="/2022/05/28/QT%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/05/28/QT%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>QT部件基类</title>
      <link href="/2022/05/28/QT%E9%83%A8%E4%BB%B6%E5%9F%BA%E7%B1%BB/"/>
      <url>/2022/05/28/QT%E9%83%A8%E4%BB%B6%E5%9F%BA%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>QT对象基类</title>
      <link href="/2022/05/28/QT%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%B1%BB/"/>
      <url>/2022/05/28/QT%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>QT事件</title>
      <link href="/2022/05/28/QT%E4%BA%8B%E4%BB%B6/"/>
      <url>/2022/05/28/QT%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>空悬指针和野指针</title>
      <link href="/2022/05/09/%E7%A9%BA%E6%82%AC%E6%8C%87%E9%92%88%E5%92%8C%E9%87%8E%E6%8C%87%E9%92%88/"/>
      <url>/2022/05/09/%E7%A9%BA%E6%82%AC%E6%8C%87%E9%92%88%E5%92%8C%E9%87%8E%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="空悬指针"><a href="#空悬指针" class="headerlink" title="空悬指针"></a>空悬指针</h2><p>简单地说，空悬指针是对象的指针的生存周期比对象更长所导致的，也就是说，<font color="orange"><code>对象销毁、删除了，不存在了，指针仍然存在，这时这个指针就成了空悬指针。</code></font><br>当对象被析构、删除时，如果指向它的指针没有被同时修改，那么指针仍然会指向那块内存（但是那块内存已经没有东西了）。系统此时可能会重新分配这块已经free掉的内存。<font color="red"><code>如果程序再通过这个指针读这块内存，就可能会有不可预见的事情发生，因为这块内存可能被分配了完全不同的内容。</code></font>如果程序此时要写这块内存，就可能会造成数据污染，进而可能带来超级难被发现的bug。<font color="red"><code>如果内存已经被其它进程重新分配，此时再去访问指针指向的内容，就可能会发生片段错误(UNIX,Linux)或者一般性保护错误(Windows).如果程序有足够的权限去重写内核内存分配器的内容，还可能造成系统的不稳定。</code></font>在有垃圾回收机制的面向对象语言中，阻止空悬引用的方法是销毁所有访问不到的对象，也就是说他们也就没有所谓的指针了，这是由追踪或引用计数而确保的。然而finalizer可能会创建新的对象的引用，这就要求对象要再生来防止空悬引用。</p><p>以下举例说明空悬指针：</p><p>例1</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">   <span class="type">char</span> *dp = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="comment">/* ... */</span></span><br><span class="line">   {</span><br><span class="line">       <span class="type">char</span> c; <span class="comment">//出了作用域系统自动销毁局部变量</span></span><br><span class="line">       dp = &amp;c;</span><br><span class="line">   }  </span><br><span class="line"><span class="comment">//到这里，c已经被销毁了，dp就变成了空悬指针(dp没有修改其指向正确的地址，它依然指向c的指针，但c的地址已不属于本程序)</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>例2</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">test_array</span><span class="params">(<span class="type">int</span> *a)</span></span>{</span><br><span class="line"><span class="type">int</span> length = <span class="built_in">sizeof</span>(a)/<span class="built_in">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"><span class="type">int</span> *b = <span class="keyword">new</span> <span class="type">int</span> [length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">{</span><br><span class="line">*b++=a[i];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="type">int</span> a [<span class="number">5</span>] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line"><span class="type">int</span> *b = <span class="built_in">test_array</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">{</span><br><span class="line">cout&lt;&lt;b[i]&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">51</span></span><br></pre></td></tr></tbody></table></figure><p>就像这样，因为虽然返回了一个指针，但是这个指针指向的对象在函数返回时已经销毁了，因此返回的值是不确定的。如果接下来还想用，那么得用引用的方法传参。</p><p>消除空悬指针的方式</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span> *dp = <span class="built_in">malloc</span>(A_CONST);</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="built_in">free</span>(dp);         <span class="comment">/* dp 现在是空悬指针 */</span></span><br><span class="line">    dp = <span class="literal">NULL</span>;        <span class="comment">/* dp 不再是空悬指针*/</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>注意：</p><blockquote><p>悬浮指针所指向的内存不属于当前程序，但是因为知道内存的指针，当前程序还是可以追寻到这块地址并修改它的值，如果操作系统没有将这块内存分配给其他程序，当前系统对该内存的操作不会出现问题（严禁这么做，因为你不知道什么时候操作系统会将这块内存分配给其他程序），如果操作系统已经将这块内存分配给其他程序，此时当前程序通过指针对这块内存进行操作就可能会发生片段错误(UNIX,Linux)或者一般性保护错误(Windows)。</p></blockquote><p>下面是一段简单的测试代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//悬浮指针， 野指针的一种，使用后结果不可控，非常危险</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* int_pointer = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"赋值前地址:"</span> &lt;&lt; int_pointer;</span><br><span class="line">    *int_pointer = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"赋值后地址:"</span> &lt;&lt; int_pointer;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"delete前值:"</span> &lt;&lt; *int_pointer;</span><br><span class="line">    <span class="keyword">delete</span> int_pointer;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"delete后值:"</span> &lt;&lt; *int_pointer;</span><br><span class="line"><span class="comment">//    int * int_pointer_second = int_pointer;</span></span><br><span class="line">    <span class="type">double</span> * double_pointer = (<span class="type">double</span>*) int_pointer;</span><br><span class="line">    *double_pointer = <span class="number">8.4</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"delete后地址:"</span> &lt;&lt; int_pointer;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"double delete后地址:"</span> &lt;&lt; double_pointer;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"int delete后值1:"</span> &lt;&lt; *int_pointer; <span class="comment">//此时变量被double值占用，输出为垃圾值（-858993459）</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"double delete后值1:"</span> &lt;&lt; *double_pointer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    *int_pointer = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"double delete后值2:"</span> &lt;&lt; *double_pointer;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"delete后赋值2:"</span> &lt;&lt; *int_pointer;</span><br><span class="line">    int_pointer = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"nullptr后地址:"</span> &lt;&lt; int_pointer;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"nullptr后地址double:"</span> &lt;&lt; double_pointer;</span><br><span class="line"><span class="comment">//    qDebug() &lt;&lt; "nullptr后值:" &lt;&lt; *int_pointer; //报错 无法操作空指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">赋值前地址: <span class="number">0x35dc900</span></span><br><span class="line">赋值后地址: <span class="number">0x35dc900</span></span><br><span class="line"><span class="keyword">delete</span>前值: <span class="number">5</span></span><br><span class="line"><span class="keyword">delete</span>后值: <span class="number">5</span></span><br><span class="line"><span class="keyword">delete</span>后地址: <span class="number">0x35dc900</span></span><br><span class="line"><span class="type">double</span> <span class="keyword">delete</span>后地址: <span class="number">0x35dc900</span></span><br><span class="line"><span class="type">int</span> <span class="keyword">delete</span>后值<span class="number">1</span>: <span class="number">-858993459</span></span><br><span class="line"><span class="type">double</span> <span class="keyword">delete</span>后值<span class="number">1</span>: <span class="number">8.4</span></span><br><span class="line"><span class="type">double</span> <span class="keyword">delete</span>后值<span class="number">2</span>: <span class="number">8.39999</span></span><br><span class="line"><span class="keyword">delete</span>后赋值<span class="number">2</span>: <span class="number">9</span></span><br><span class="line"><span class="literal">nullptr</span>后地址: <span class="number">0x0</span></span><br><span class="line"><span class="literal">nullptr</span>后地址<span class="type">double</span>: <span class="number">0x35dc900</span></span><br></pre></td></tr></tbody></table></figure><h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><p><font color="orange"><code>野指针作为一个指针，甚至都没有被初始化，也就是说虽然它的类型是一个指针，但它根本没有值。</code></font>它跟NULL指针还有差别，NULL是指向了0地址，而野指针是没有地址。也就相当于，int a=0;和int a;的区别。野指针非常危险，往往会引起程序奔溃。</p><p>举例说明：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span> *dp;<span class="comment">//野指针，没有初始化</span></span><br><span class="line">    <span class="comment">//定义一个测试类testClass，包含一个成员函数void show();</span></span><br><span class="line">    testClass * test; <span class="comment">//野指针，没有初始化</span></span><br><span class="line">    test.<span class="built_in">show</span>(); <span class="comment">//系统将奔溃</span></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> *sdp; <span class="comment">//非野指针，因为静态变量会默认初始化为0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可调用对象包装器、绑定器</title>
      <link href="/2022/05/09/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8%E3%80%81%E7%BB%91%E5%AE%9A%E5%99%A8/"/>
      <url>/2022/05/09/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8%E3%80%81%E7%BB%91%E5%AE%9A%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h2><p>在 C++ 中存在 “可调用对象” 这么一个概念。准确来说，可调用对象有如下几种定义：</p><ul><li><font color="orange"><code>是一个函数指针</code></font></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 定义函数指针</span></span><br><span class="line"><span class="built_in">int</span> (*func)(<span class="type">int</span>, <span class="type">double</span>) = &amp;print</span><br></pre></td></tr></tbody></table></figure><ul><li><font color="orange"><code>是一个具有operator()成员函数的类对象（仿函数，即重载()运算符）</code></font></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// ()操作符重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string msg)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"msg: "</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="built_in">t</span>(<span class="string">"我是要成为海贼王的男人!!!"</span>);<span class="comment">// 仿函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><font color="orange"><code>是一个可被转换为函数指针的类对象</code></font></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>, string);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, string b)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"name: "</span> &lt;&lt; b &lt;&lt; <span class="string">", age: "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将类对象转换为函数指针</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">func_ptr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> print; <span class="comment">//只能是类的静态成员函数，因为类的静态成员函数类定义时就存在，而类的普通成员函数只有函数实例对象后才存在.</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="comment">// 对象转换为函数指针, 并调用</span></span><br><span class="line">    <span class="built_in">t</span>(<span class="number">19</span>, <span class="string">"Monkey D. Luffy"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><font color="orange"><code>是一个类成员函数指针或者类成员指针</code></font></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, string b)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"name: "</span> &lt;&lt; b &lt;&lt; <span class="string">", age: "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 定义类成员函数指针指向类成员函数</span></span><br><span class="line">    <span class="built_in">void</span> (Test::*func_ptr)(<span class="type">int</span>, string) = &amp;Test::print;</span><br><span class="line">    <span class="comment">// 类成员指针指向类成员变量</span></span><br><span class="line">    <span class="type">int</span> Test::*obj_ptr = &amp;Test::m_num;</span><br><span class="line"></span><br><span class="line">    Test t;</span><br><span class="line">    <span class="comment">// 通过类成员函数指针调用类成员函数</span></span><br><span class="line">    (t.*func_ptr)(<span class="number">19</span>, <span class="string">"Monkey D. Luffy"</span>);</span><br><span class="line">    <span class="comment">// 通过类成员指针初始化类成员变量</span></span><br><span class="line">    t.*obj_ptr = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"number is: "</span> &lt;&lt; t.m_num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上面的例子中满足条件的这些可调用对象对应的类型被统称为<font color="red"><code>可调用类型</code></font>。C++ 中的可调用类型虽然具有比较统一的操作形式，但定义方式五花八门，这样在我们试图使用统一的方式保存，或者传递一个可调用对象时会十分繁琐。现在，<font color="orange"><code>C++11通过提供std::function 和 std::bind统一了可调用对象的各种操作。</code></font></p><h2 id="可调用对象包装器"><a href="#可调用对象包装器" class="headerlink" title="可调用对象包装器"></a>可调用对象包装器</h2><p><font color="orange"><code>std::function是可调用对象的包装器。它是一个类模板，可以容纳除了类成员（函数）指针之外的所有可调用对象。通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们。</code></font></p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>std::function 必须要包含一个叫做 <font color="orange"><code>functional</code> </font>的头文件，可调用对象包装器使用语法如下:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line">std::function&lt;返回值类型(参数类型列表)&gt; diy_name = 可调用对象;</span><br></pre></td></tr></tbody></table></figure><p>下面的实例代码中演示了可调用对象包装器的基本使用方法：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">" + "</span> &lt;&lt; b &lt;&lt; <span class="string">" = "</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">" - "</span> &lt;&lt; b &lt;&lt; <span class="string">" = "</span> &lt;&lt; a - b &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">" * "</span> &lt;&lt; b &lt;&lt; <span class="string">" = "</span> &lt;&lt; a * b &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 绑定一个普通函数</span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f1 = add;</span><br><span class="line">    <span class="comment">// 绑定以静态类成员函数</span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f2 = T1::sub;</span><br><span class="line">    <span class="comment">// 绑定一个仿函数</span></span><br><span class="line">    T2 t;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f3 = t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">f2</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">f3</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输入结果如下:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> + <span class="number">3</span> = <span class="number">12</span></span><br><span class="line"><span class="number">9</span> - <span class="number">3</span> = <span class="number">6</span></span><br><span class="line"><span class="number">9</span> * <span class="number">3</span> = <span class="number">27</span></span><br></pre></td></tr></tbody></table></figure><p><font color="red"><code>通过测试代码可以得到结论：std::function 可以将可调用对象进行包装，得到一个统一的格式，包装完成得到的对象相当于一个函数指针，和函数指针的使用方式相同，通过包装器对象就可以完成对包装的函数的调用了。</code></font></p><h3 id="作为回调函数使用"><a href="#作为回调函数使用" class="headerlink" title="作为回调函数使用"></a>作为回调函数使用</h3><p>因为回调函数本身就是通过函数指针实现的，<font color="orange"><code>使用对象包装器可以取代函数指针的作用</code></font>，来看一下下面的例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数参数是一个包装器对象</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> function&lt;<span class="built_in">void</span>()&gt;&amp; f) : <span class="built_in">callback</span>(f)</span><br><span class="line">    {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">callback</span>(); <span class="comment">// 调用通过构造函数得到的函数指针</span></span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    function&lt;<span class="type">void</span>()&gt; callback;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"我是要成为海贼王的男人!!!"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    B b;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(b)</span></span>; <span class="comment">// 仿函数通过包装器对象进行包装</span></span><br><span class="line">    a.<span class="built_in">notify</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过上面的例子可以看出，使用对象包装器 std::function 可以非常方便的将仿函数转换为一个函数指针，通过进行函数指针的传递，在其他函数的合适的位置就可以调用这个包装好的仿函数了。</p><p>另外，使用 std::function 作为函数的传入参数，可以将定义方式不相同的可调用对象进行统一的传递，这样大大增加了程序的灵活性。</p><h2 id="绑定器"><a href="#绑定器" class="headerlink" title="绑定器"></a>绑定器</h2><p><font color="orange"><code>std::bind用来将可调用对象与其参数一起进行绑定。绑定后的结果可以使用std::function进行保存，并延迟调用到任何我们需要的时候。</code></font>通俗来讲，它主要有两大作用：</p><ol><li><font color="orange"><code>将可调用对象与其参数一起绑定成一个仿函数。</code></font></li><li><font color="orange"><code>将多元（参数个数为n，n&gt;1）可调用对象转换为一元或者（n-1）元可调用对象，即只绑定部分参数。</code></font></li></ol><p>绑定器函数使用语法格式如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定非类成员函数/变量</span></span><br><span class="line"><span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(可调用对象地址, 绑定的参数/占位符);</span><br><span class="line"><span class="comment">// 绑定类成员函/变量</span></span><br><span class="line"><span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(类函数/成员地址, 类实例对象地址, 绑定的参数/占位符);</span><br></pre></td></tr></tbody></table></figure><p>下面来看一个关于绑定器的实际使用的例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callFunc</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;&amp; f)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">f</span>(x);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_add</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; x + <span class="number">10</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 使用绑定器绑定可调用对象和参数</span></span><br><span class="line">    <span class="keyword">auto</span> f1 = <span class="built_in">bind</span>(output, placeholders::_1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">callFunc</span>(i, f1);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f2 = <span class="built_in">bind</span>(output_add, placeholders::_1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">callFunc</span>(i, f2);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试代码输出的结果:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="number">10</span> <span class="number">12</span> <span class="number">14</span> <span class="number">16</span> <span class="number">18</span></span><br></pre></td></tr></tbody></table></figure><p>在上面的程序中，使用了 std::bind 绑定器，在函数外部通过绑定不同的函数，控制了最后执行的结果。<font color="orange"><code>std::bind绑定器返回的是一个仿函数类型，得到的返回值可以直接赋值给一个std::function，在使用的时候我们并不需要关心绑定器的返回值类型，使用auto进行自动类型推导就可以了。</code></font></p><p><font color="orange">placeholders::_1</font> 是一个占位符，代表这个位置将在函数调用时被传入的第一个参数所替代。同样还有其他的占位符 <font color="orange">placeholders::_2</font> 、<font color="orange">placeholders::_3</font> 、<font color="orange">placeholders::_4</font> 、<font color="orange">placeholders::_5</font>  等……</p><p>有了占位符的概念之后，使得 std::bind 的使用变得非常灵活:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 使用绑定器绑定可调用对象和参数, 并调用得到的仿函数</span></span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">1</span>, <span class="number">2</span>)();</span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_1, <span class="number">2</span>)(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">2</span>, placeholders::_1)(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// error, 调用时没有第二个参数</span></span><br><span class="line">    <span class="comment">// bind(output, 2, placeholders::_2)(10);</span></span><br><span class="line">    <span class="comment">// 调用时第一个参数10被吞掉了，没有被使用</span></span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">2</span>, placeholders::_2)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_1, placeholders::_2)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_2, placeholders::_1)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>示例代码执行的结果:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="number">2</span><span class="comment">// bind(output, 1, 2)();</span></span><br><span class="line"><span class="number">10</span> <span class="number">2</span><span class="comment">// bind(output, placeholders::_1, 2)(10);</span></span><br><span class="line"><span class="number">2</span> <span class="number">10</span><span class="comment">// bind(output, 2, placeholders::_1)(10);</span></span><br><span class="line"><span class="number">2</span> <span class="number">20</span><span class="comment">// bind(output, 2, placeholders::_2)(10, 20);</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span><span class="comment">// bind(output, placeholders::_1, placeholders::_2)(10, 20);</span></span><br><span class="line"><span class="number">20</span> <span class="number">10</span><span class="comment">// bind(output, placeholders::_2, placeholders::_1)(10, 20);</span></span><br></pre></td></tr></tbody></table></figure><p>通过测试可以看到，std::bind 可以直接绑定函数的所有参数，也可以仅绑定部分参数。在绑定部分参数的时候，通过使用 std::placeholders 来决定空位参数将会属于调用发生时的第几个参数。</p><p>可调用对象包装器 std::function 是不能实现对类成员函数指针或者类成员指针的包装的，但是通过绑定器 std::bind 的配合之后，就可以完美的解决这个问题了，再来看一个例子，然后再解释里边的细节：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"x: "</span> &lt;&lt; x &lt;&lt; <span class="string">", y: "</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> m_number = <span class="number">100</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="comment">// 绑定类成员函数</span></span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f1 = </span><br><span class="line">        <span class="built_in">bind</span>(&amp;Test::output, &amp;t, placeholders::_1, placeholders::_2);</span><br><span class="line">    <span class="comment">// 绑定类成员变量(公共)</span></span><br><span class="line">    function&lt;<span class="type">int</span>&amp;(<span class="type">void</span>)&gt; f2 = <span class="built_in">bind</span>(&amp;Test::m_number, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用</span></span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">520</span>, <span class="number">1314</span>);</span><br><span class="line">    <span class="built_in">f2</span>() = <span class="number">2333</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"t.m_number: "</span> &lt;&lt; t.m_number &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>示例代码输出的结果:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x: <span class="number">520</span>, y: <span class="number">1314</span></span><br><span class="line">t.m_number: <span class="number">2333</span></span><br></pre></td></tr></tbody></table></figure><p>在用绑定器绑定类成员函数或者成员变量的时候需要将它们所属的实例对象一并传递到绑定器函数内部。<font color="orange"><code>f1的类型是function&lt;void(int, int)&gt;，通过使用std::bind将Test的成员函数output的地址和对象t绑定，并转化为一个仿函数并存储到对象f1中。</code></font></p><p><font color="orange"><code>使用绑定器绑定的类成员变量m_number得到的仿函数被存储到了类型为function&lt;int&amp;(void)&gt;的包装器对象f2中，并且可以在需要的时候修改这个成员。其中int是绑定的类成员的类型，并且允许修改绑定的变量，因此需要指定为变量的引用，由于没有参数因此参数列表指定为void。</code></font></p><p>示例程序中是使用 function 包装器保存了 bind 返回的仿函数，如果不知道包装器的模板类型如何指定，可以直接使用 auto 进行类型的自动推导，这样使用起来会更容易一些。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11新特性 </tag>
            
            <tag> 指针 </tag>
            
            <tag> 可调用对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QSS入门</title>
      <link href="/2022/05/07/QSS%E5%85%A5%E9%97%A8/"/>
      <url>/2022/05/07/QSS%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>为了书写方便, 文中一律使用 Qss 代替 Qt style sheet。</p><p>首先来看 Qt 的官方介绍: 除了子类化 QStyle 以外, Qss 是一个非常强大的用于自定义控件外观的机制. 它的概念,术语以及语法都是受到了 HTML CSS 的启发(实际上就是 CSS 的语法), 但可以适应全局窗口部件(这一句我没明白是什么意思)。</p><p>就是说, Qss 是用来设置界面样式的, 设置的方法就是类似于 CSS,通过以一定规则组织的字符串来给界面设置样式, 而不用我们调用控件对象的接口或子类化 QStyle 去设置样式. 这种组织字符串的规则就是它的语法, 下的总结也是主要讲一些 Qss 的语法, 包含少量的经验以及官方文档中没有说明的内容.</p><p>个人认为使用 Qss 的好处:</p><p>(1) 可读性高并且非常直观,便于设置界面样式;</p><p>(2) 在每个平台上都有相同的显示效果. </p><p>(3) 可以在界面代码中省去与显示效果相关的大量代码,将界面逻辑独立出来. </p><p>(4) 在界面风格(配色, 字体等)改变的情况下, 可以不用修改 c++源码就可以实现.</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>样式表由一系列的样式规则组成。一条样式规则由一个<font color="orange"><code>选择器</code></font>和一个<font color="orange"><code>声明语句</code></font>组成，<font color="orange"><code>选择器指明了哪个（或者说是哪种）控件将会受规则影响，而声明语句则指明了哪些属性会设置到这个（这些）控件</code></font>. </p><p>语法如下:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selector { attribute: value; } </span><br></pre></td></tr></tbody></table></figure><blockquote><p>在上面这条语句中, selector 代表选择器, 指明了哪个(或者说是哪种)控件将会受到规则影响.</p><p>{attribute: value;}代表声明语句, 其中 attribute 表示属性, value 表示该属性的值, 属性与它的值之间必须以冒号( : )隔开, 属性值后面必须以分号( ; )结束,表示这条属性已经设置完成. 整条语句加起来的意思是, 在整个应用程序中, 被 selector匹配的控件, 它们控件的 attribute 属性的值应该被设置为 value.</p></blockquote><p>例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPushButton{ <span class="attribute">color</span>: red;}</span><br></pre></td></tr></tbody></table></figure><p>表示将我们的应用程序中所有的 QPushbutton 对象以及它的子类对象应该使用 red 作为它们的前景色(即字体的颜色);由此看来, 我们要学会如何使用 qss 来控制我们的界面样式, 只需要学会两个方面的内容, 即选择器和属性, 下面将用专门的章节来讲解这两部分的内容.</p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="通用选择器"><a href="#通用选择器" class="headerlink" title="通用选择器"></a>通用选择器</h4><p>又叫通配符选择器</p><h5 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* { 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>通用选择器用( * )来表示, 它表示匹配程序中所有的 widget.</p><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><blockquote><p><font color="cornflowerblue">由于通用选择器会匹配程序中所有的 widgets, 效率较低, 因此应该尽量减少或者不使用</font></p></blockquote><h5 id="一般用法"><a href="#一般用法" class="headerlink" title="一般用法"></a>一般用法</h5><p>通用选择器一般用来给应用程序设置统一的字体,例如</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*{<span class="attribute">font</span>: normal <span class="number">20px</span> “微软雅黑”;}</span><br></pre></td></tr></tbody></table></figure><p>这条语句表示将程序中所有 widget 的字体大小都设置为 20px 大小, 字体采用微软雅黑.</p><h4 id="类型选择器"><a href="#类型选择器" class="headerlink" title="类型选择器"></a>类型选择器</h4><h5 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 { 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>类名即 Widget 类名, 由 QObject :: metaObject() :: className()获取, 类型选择器匹配所有该类以及该类的派生类的对象.</p><p>例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QPushButton{ </span><br><span class="line"><span class="attribute">color</span>: blue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这条语句表示, 程序中<font color="orange"><code>所有的 QPushButton 类和它的派生类的对象, 它们的前景色(即文字颜色)被设置为蓝色.</code></font></p><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><p>Qt 样式表使用 widget 的 <font color="orange"><code>QObject::className()</code></font>来决定何时应用<font color="orange"><code>类型选择器</code></font>。当<font color="red"><code>自定义控件在命名空间之中</code></font>(或它是一个嵌套类)，<font color="red">QObject::className()会返回( :: )</font>, 这与后面介绍的子控件选择器相冲突. 为了解决这个问题，当为命名空间中 widget 使用类型选择器时, 我们必须将<font color="orange"><code>” :: ”</code></font>替换成<font color="orange"><code>” -- ”</code></font>, 下面即将介绍的类选择器也是一样. </p><p>例子如下:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ns {</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">MyPushButton</span> : <span class="keyword">public</span> QPushButton {</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> } </span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">qApp-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">"ns--MyPushButton { background: yellow; }"</span>);</span><br></pre></td></tr></tbody></table></figure><h5 id="一般用法-1"><a href="#一般用法-1" class="headerlink" title="一般用法"></a><strong>一般用法</strong></h5><p>类型选择器会匹配<font color="orange"><code>所有该类以及该类的派生类的对象</code></font>, 所以我们在程序中, 有时为了统一具有相似性的控件的样式, 可以使用类型选择器, 如, 我们想要为 <font color="orange">QSpinBox</font>,<font color="orange">QDoubleSpinBox</font>, <font color="orange">QDateTimeEdit</font>, <font color="orange">QTimeEdit</font>, <font color="orange">QDateEdit</font> 等这些编辑框的控件设置一些相同的样式, 因为它们都是 <font color="orange">QAbstractSpinBox 类的派生类</font>, 因此可以如下写:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QAbstractSpinBox{</span><br><span class="line"><span class="attribute">min-height</span>: <span class="number">30px</span>;</span><br><span class="line"><span class="attribute">max-height</span>: <span class="number">30px</span>;</span><br><span class="line"><span class="attribute">border-width</span>: <span class="number">1px</span>;</span><br><span class="line">rder-style: solid;</span><br><span class="line"><span class="attribute">order</span>-<span class="attribute">color</span>: gray; </span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0px</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a><strong>类选择器</strong></h4><h5 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.类名 { 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>这里的类名与类型选择器中的类名一样, 不同的是, 类选择器的类名前面有一个( . ), 这种选择器<font color="red"><code>只会匹配该类的所有对象, 而不会匹配其派生类的对象.</code></font> </p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.QPushButton</span>{ </span><br><span class="line"><span class="attribute">color</span>: blue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="一般用法-2"><a href="#一般用法-2" class="headerlink" title="一般用法"></a><strong>一般用法</strong></h5><p>类选择器提供了一种<font color="orange"><code>匹配所有该类的对象但不会匹配派生类的方法</code></font>, 通常用来特例化拥有派生类的类对象, 但不仅限于此.例如在在我的应用程序中, 我用 QFrame 来作为容器 widget,此时我想对它设置一些样式, 但又不想影响它的子类对象(QLabel, QAbstractScrollArea 等等),那么我可以使用类选择器给所有的 QFrame 设置相同的样式 . </p><p>例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.QFrame</span>{</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">25px</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="ID-选择器"><a href="#ID-选择器" class="headerlink" title="ID 选择器"></a><strong>ID</strong> <strong>选择器</strong></h4><h5 id="格式-3"><a href="#格式-3" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#id</span>{ 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>这里的 id 指的是 objectName, 每个 QObject 类及其派生类都有的一个属性, “#” + objectName构成了我们的 ID 选择器, <font color="orange"><code>它匹配所有 objectName 为 ID 选择器所指定的名称的对象</code></font>, 为其设置样式. </p><p>例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#button_1</span>{</span><br><span class="line"> <span class="attribute">color</span>: red; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a><strong>注意点</strong></h5><ol><li><p>objectName 是大小写敏感的.</p></li><li><p>“#”与 ID 之间不可以有空格</p></li><li><p>由于 objectName 是所有 QObject 类对象的一个属性, 在运行过程中可以改变, 所以一般情况下, 要使用 ID 选择器时,<font color="orange"> <code>保证 objectName 不要在运行时被改变, 否则重新加载stylesheet 文件时, 对应的 ID 选择器将不会匹配到原来的控件.</code></font></p></li><li><p>由于 objectName 允许字符串中含有空格, 但是 ID 选择器中,<font color="orange"> <code>ID 是从紧跟#后的第一个字符开始直到遇到空格或“{”之间的字符串, 因此, 如果是为了使用 ID 选择器而设置objectName, 则 objectName 中不能含有空格</code></font></p></li><li><p><font color="orange"><code>由于任何对象的 objectName 都可以出现重复, 因此在设置 objectName 时, 尽量保持其唯一性</code></font></p></li><li><p>Qt 官方给出的 ID 选择器的格式为:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名<span class="selector-id">#id</span>{ 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>但实际上不加类名也是可以的(加了类名的 ID 选择器在 CSS 中被称为交集选择器),在正式开发中, 还是<font color="orange"><code>建议加上类名, 因为这样可以看出这个 id 选择器所匹配的对象的类型,有利于提高阅读性.</code></font>基于以上特点, 我们在设置 objectName 时, 一般使用下划线”_”连接的多个单词表明此对象的功能.</p></li></ol><h5 id="一般用法-3"><a href="#一般用法-3" class="headerlink" title="一般用法"></a><strong>一般用法</strong></h5><p>ID 选择器一般用于为比较特殊的控件设置样式, 例如在我的某个页面中, 需要突出一个重要的按钮, 那么此时我可以给这个按钮设置一个独特的样式用以提醒用户, 如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-id">#settings_popup_fileDialog_button</span>{</span><br><span class="line"></span><br><span class="line"> <span class="attribute">min-height</span>: <span class="number">31px</span>;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">min-width</span>: <span class="number">70px</span>;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">color</span>: <span class="number">#F0F0F0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">min-height</span>: <span class="number">10px</span>;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">border-radius</span>:<span class="number">3px</span>;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">background</span>: <span class="built_in">qlineargradient</span>(spread:pad, x1:<span class="number">0</span>, y1:<span class="number">0</span>, x2:<span class="number">0</span>, y2:<span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">stop:<span class="number">0</span> <span class="number">#454648</span>, stop:<span class="number">1</span> <span class="number">#7A7A7A</span>); </span><br><span class="line"></span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h4 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a><strong>后代选择器</strong></h4><h5 id="格式-4"><a href="#格式-4" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器<span class="number">1</span> 选择器<span class="number">2</span>{ 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>这个选择器表示: <font color="orange"><code>在选择器 1 匹配的所有对象中, 找到选择器 2 所匹配的所有后代对象, 并给它们设置样式.</code></font></p><h5 id="注意点-3"><a href="#注意点-3" class="headerlink" title="注意点"></a><strong>注意点</strong></h5><ol><li>后代选择器必须用空格隔开每个选择器</li><li><font color="orange"><code>后代选择器可以通过空格一直延续下去</code></font>, 例如:选择器 1 选择器 2 选择器 3 … 选择器 N{ 属性: 值; }</li><li><font color="red"><code>顾名思义, 后代选择器不仅包含”儿子”, 还包含”孙子”, “重孙子”等, 一般来说, 只要 B 控件显示在 A 控件上, 那么 B 控件就是 A 控件的后代.</code></font></li><li>后代选择器不仅可以使用类型选择器, 还可以使用类选择器, id 选择器以及后面提及的属性选择器等.</li><li>Qt 中, 各控件的父子关系:通过简单的验证, 各控件的父子关系并非我们在创建对象时所指定的那样, <font color="orange"><code>实际父子关系取决于如何布局.</code> </font></li></ol><h5 id="一般用法-4"><a href="#一般用法-4" class="headerlink" title="一般用法"></a><strong>一般用法</strong></h5><p>后代选择器一般用于指定特定类的后代的样式, 例如在我的应用程序中, 有很多个相似的对话框, 它们中包含一些样式相同的按钮, 那么我可以使用后代选择器为他们指定样式, 例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BaseDialog QPushButton{</span><br><span class="line"><span class="attribute">min-width</span>: <span class="number">120px</span>;</span><br><span class="line"><span class="attribute">min-height</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">max-width</span>: <span class="number">120px</span>;</span><br><span class="line"><span class="attribute">max-height</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0px</span>; </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h4 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a><strong>子元素选择器</strong></h4><h5 id="格式-5"><a href="#格式-5" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器<span class="number">1</span> &gt;选择器<span class="number">2</span> { 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>子元素选择器表示找到指定选择器所匹配的对象中的所有特定直接子元素然后设置属性, </p><p>即找到选择器 1 匹配到的对象中的被选择器 2 匹配盗的直接子元素然后设置属性</p><p><strong>注意点</strong></p><ol><li><p>子元素选择器必须用”&gt;”连接, “&gt;”两边有没有空格都可以, 但是不建议写空格, 因为会与后代选择器的连接符混淆.</p></li><li><p><font color="orange"><code>子元素选择器只会查找”儿子”, 不会查找其他后代.</code></font></p></li><li><p>子元素选择器不仅可以使用类型选择器, 还可以使用类选择器,id 等选择器</p></li><li><p><font color="red"><code>子元素选择器不能通过”&gt;”一直延续下去, 只能有一个”&gt;”</code></font></p></li><li><p>由于 Qt 中有继承关系的 Widgets 较多, 在使用子元素选择器时, 请特别注意继承关系,比如我只想选中 QGroupBox 中的 QPushButton, 那么我即可以写成</p></li></ol>   <figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QWidget&gt;QPushButton{<span class="attribute">color</span>: red;} </span><br><span class="line"><span class="comment">/*也可以写成*/</span></span><br><span class="line">QGroupBox&gt;QPushButton{<span class="attribute">color</span>: red;} </span><br></pre></td></tr></tbody></table></figure><p>   这是因为 QGroupBox 是 QWidget 的派生类, 类型选择器 QWidget 会选中所有它的派生类对象,这些对象中包括 QGroupBox, 因此写法.1 会将所有的 QPushButton 的前景色设置为红色.鉴于此种情况, 我推荐在使用子元素选择器时, 使用类选择器替代类型选择器.</p><h5 id="一般用法-5"><a href="#一般用法-5" class="headerlink" title="一般用法"></a><strong>一般用法</strong></h5><p>子元素选择器一般用于一些特定布局条件中的控件, 例如我想给直接布局在 QGroupBox 的QCheckBox 设置一些特定属性, 那么可以这样做: </p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.QGroupBox</span> &gt; <span class="selector-class">.QCheckBox</span>{</span><br><span class="line"><span class="attribute">color</span>: blue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a><strong>属性选择器</strong></h4><h5 id="格式-6"><a href="#格式-6" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[attribute=value]</span>{ 属性: 值; }</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[attribute|=value]</span>{ 属性:值; }</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[attribute~=value]</span>{ 属性:值; }</span><br></pre></td></tr></tbody></table></figure><blockquote><p><font color="orange"><code>attribute=value 表示匹配有特定属性 attribute, 并且值为 value 的所有控件, 然后设置样式;</code></font></p><p><font color="orange"><code>attribute|=value 表示匹配有特定属性 attribute, 并且值以 value 开头的所有控件, 然后设置样式;</code></font></p><p><font color="orange"><code>attribute~=value 表示匹配有特定属性 attribute, 并且值包含 value 的所有控件, 然后设置样 式;</code></font></p></blockquote><h5 id="注意点-4"><a href="#注意点-4" class="headerlink" title="注意点"></a><strong>注意点</strong></h5><p><font color="red"><code>attribute|=value 表示 attribute 属性的值以 value 开头, 无论 value 后面还有没有值, 或者value 后面是什么, 均能匹配到</code></font>, 例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[objectName|=<span class="string">"button"</span>]</span>{</span><br><span class="line"><span class="attribute">color</span>: red; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这表示将 objectName 属性以 button 开头的所有控件的前景色设置为红色.</p><p><font color="red"><code>attribute~=value 表示 attribute 属性的值中包含 value, 这里要注意的是:value 必须是独立的单词, 也就是包含 value 并且 value 是被空格隔开的</code></font>, 例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[objectName~=<span class="string">"button"</span>]</span>{</span><br><span class="line"><span class="attribute">color</span>: red; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>而我在代码中, 设置的 objectName 的语句为:</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081327869.png"></p><p>结果是只匹配到了 pBtn2 所指的对象</p><h5 id="官方文档的解释"><a href="#官方文档的解释" class="headerlink" title="官方文档的解释:"></a>官方文档的解释:</h5><p>通常情况下, 这里的属性指的是, 使用 <font color="blue"><code>Q_PROPERTY</code> </font>宏所声明的属性, 并且属性类型要受 <font color="orange"><code>QVariant::toString()</code></font>支持.</p><p>这个选择器类型也可以用来判断动态属性，要了解更多使用自定义动态属性的细节，请参考使用自定义动态属性 </p><p><font color="orange"><code>除了使用=，你还可以使用~=来判断一个 QStringList 中是否包含给定的 QString</code></font>。警告：如果在设置了样式表后，相应的属性值发生了改变(如：flat 变成了”true”)，则有必要重新加载样式表，一个有效的方法是，取消样式表，再重新设置一次,下面的代码是其中一种方式：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">style()-&gt;unpolish(this);</span><br><span class="line"></span><br><span class="line">style()-&gt;polish(this);</span><br></pre></td></tr></tbody></table></figure><h5 id="一般用法-6"><a href="#一般用法-6" class="headerlink" title="一般用法"></a><strong>一般用法</strong></h5><p>属性选择器一般不常用, 如果要用, 请参照官方文档的方法使用</p><h4 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a><strong>并集选择器</strong></h4><h5 id="格式-7"><a href="#格式-7" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器<span class="number">1</span>,选择器<span class="number">2</span>,选择器<span class="number">3</span>{ 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>并集选择器表示, 将每个单独选择器匹配到的控件放在同一个结果集中, 并给结果集中的每个控件都设置声明语句中的样式.</p><h5 id="注意点-5"><a href="#注意点-5" class="headerlink" title="注意点"></a><strong>注意点</strong></h5><ol><li>并集选择器必须使用”,”来连接不同的选择器</li><li>并集选择器可以使用类选择器, 类型选择器, id 选择器, 属性选择器等.</li></ol><p><strong>一般用法</strong></p><p>主要用于给具有相同属性并且外观相似的的控件设置样式, 例如: </p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.QLineEdit</span>, <span class="selector-class">.QComboBox</span>{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid gray;</span><br><span class="line"><span class="attribute">background-color</span>:white; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="两个特殊的选择器"><a href="#两个特殊的选择器" class="headerlink" title="两个特殊的选择器"></a><strong>两个特殊的选择器</strong></h4><h5 id="子控件选择器"><a href="#子控件选择器" class="headerlink" title="子控件选择器"></a><strong>子控件选择器</strong></h5><h5 id="格式-8"><a href="#格式-8" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型选择器::子控{ 属性: 值; }</span><br><span class="line"></span><br><span class="line">类选择器::子控件{ 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>表示对类型选择器或类选择器指定的所有控件的<font color="orange"><code>子控件</code></font>设置样式;</p><p><strong>Qt</strong> <strong>官方说明</strong> </p><p>为了样式化你的复杂 widget，很有必要使用 widget 的 subcontrol，比如 QComboBox 的 drop-down 部分或者是 QSpinBox 的上和下箭头。选择器也许会包含 subcontrols 用于限制 widget的 subcontrols, 举个例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QComboBox::down-arrow{</span><br><span class="line">image: <span class="built_in">url</span>(<span class="string">:/res/arrowdown.png</span>); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述规则样式化所有 QComboBox 的 drop-down 部分，虽然双冒号(::)让人联想到 CSS3 的伪元素语法，但是 Qt 的 Sub-Controls 跟它是不一样的。</p><p> Sub-Controls 始终相对于另一个元素来定位–一个参考元素。这个参考元素可以是一个Widget 又或者是另一个 Sub-Control。举个例子，QComboBox 的::drop-down 默认被放置于QComboBox 的 Padding rectangle(盒子模型)的右上角。::drop-down 默认会被放置于另一个::drop-down Sub-Control 的中心。查看可样式化的 Widget 列表以了解更多使用 Sub-Control来样式化 Widget 和初始化其位置的内容。源 rectangle 可以使用 subcontrol-origin 来改变。</p><p>举个例子，如果我们想要把 drop-down 放置于 QComboBox 的 margin rectangle 而不是默认的 Padding rectangle，我们可以像下面这样指</p><p>定：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QComboBox {</span><br><span class="line"><span class="attribute">margin-right</span>: <span class="number">20px</span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">QComboBox::drop-down {</span><br><span class="line">    subcontrol-origin: margin; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>drop-down 在 Margin rectangle 内的排列方式可以由 subcontrol-position 来改变. </p><p>width 和 height 属性可以用来控制 Sub-control 的 size.需要注意的是，设置了 image 就隐式的设置了 Sub-control 的 size 了。</p><ol><li>相对定位方案（position:relative）,允许 Sub-Control 的位置从它的初始化位置作出偏移。</li></ol><p>举个例子，当 QComboBox 的 drop-down 按钮被 pressed 时，我们也许想要那个箭头作出位移以显示一种“pressed”的效果，为了达到目标，我们可以像下面那样指定</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QComboBox::down-arrow {</span><br><span class="line"> image*: <span class="built_in">url</span>(<span class="string">down_arrow.png</span>); </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">QComboBox::down-arrow:pressed {</span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">1px</span>; <span class="attribute">left</span>: <span class="number">1px</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>绝对定位方(position : absolute)，使得 Sub-control 的 position 和 size 基于其参考元素而改</li></ol><p>变。一旦定位，它们将会与 widget 同等对待并且可以使用盒子模型来样式化。查看 Sub-Control 列表以了解那些 sub-control 是被支持的，并且可以查看自定义QPushButton 的菜单指示器 Sub-Control 来了解一个实际的使用例子。注意：像 QComboBox 和 QScrollBar 这样的复杂部件，如果 sub-control 的一项属性是自定义的，那么其他所有的属性跟 sub-control 也都应该自定义。</p><h5 id="子控件表（参考）"><a href="#子控件表（参考）" class="headerlink" title="子控件表（参考）"></a>子控件表（参考）</h5><table><thead><tr><th>子部件</th><th>描述</th></tr></thead><tbody><tr><td>::down-arrow</td><td>combo box或spin box的下拉箭头</td></tr><tr><td>::down-button</td><td>spin box的向下按钮</td></tr><tr><td>::drop-down</td><td>combo box的下拉箭头</td></tr><tr><td>::indicato</td><td>checkbox、radio button或可选择group box的指示器</td></tr><tr><td>::item</td><td>menu、menu bar或status bar的子项目</td></tr><tr><td>::menu-indicator</td><td>push button的菜单指示器</td></tr><tr><td>::title</td><td>group box的标题</td></tr><tr><td>::up-arrow</td><td>spin box的向上箭头</td></tr><tr><td>::up-button</td><td>spin box的向上按钮</td></tr></tbody></table><h5 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a><strong>伪类选择器</strong></h5><h5 id="格式-9"><a href="#格式-9" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型选择器:状态{ 属性: 值; }</span><br><span class="line"></span><br><span class="line">类选择器:状态{ 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>表示对类型选择器或类选择器指定的所有控件设置它在指定状态时的样式.</p><p><strong>Qt</strong> <strong>官方说明</strong> </p><p>选择器也许会包含基于 widget 的 state 的程序限制规则的伪状态。<font color="orange"><code>伪状态以冒号(:)作为分隔紧跟着选择器</code></font>。举个例子，下面的规则在鼠标悬浮在 QPushButton 的上方时生效：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:hover</span> { <span class="attribute">color</span>: white }</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>伪状态可以使用感叹号进行取反</code></font>，下面一条规则在鼠标没有悬浮在 QRadioButton 上方时生效：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QRadioButton:!hover { <span class="attribute">color</span>: red }</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>伪状态可以链接，在这样的情况下，隐式地包含了逻辑与</code></font>。举个例子，下面一条规则在鼠标悬浮到一个已 check 的 QCheckBox 上时生效：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QCheckBox<span class="selector-pseudo">:hover</span><span class="selector-pseudo">:checked</span> { <span class="attribute">color</span>: white }</span><br></pre></td></tr></tbody></table></figure><p>伪状态的取反也可以出现在伪状态链中，举个例子，下面的规则在鼠标悬浮到一个没有被press 的 QPushButton 上时生效：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:hover</span>:!pressed { <span class="attribute">color</span>: blue; }</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>如果有需要，可以使用逗号来表示逻辑或, 即并集选择器</code></font></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QCheckBox<span class="selector-pseudo">:hover</span>, QCheckBox<span class="selector-pseudo">:checked</span> { <span class="attribute">color</span>: white }</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>伪状态可以与 subcontrol 组合使用</code></font>，举个例子：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QComboBox::drop-down:hover { *image*: <span class="built_in">url</span>(<span class="string">dropdown_bright.png</span>) }</span><br></pre></td></tr></tbody></table></figure><h5 id="伪状态表（参考）"><a href="#伪状态表（参考）" class="headerlink" title="伪状态表（参考）"></a>伪状态表（参考）</h5><table><thead><tr><th>伪状态</th><th>描述</th></tr></thead><tbody><tr><td>:unchecked</td><td>button部件未被选中</td></tr><tr><td>:checked</td><td>button部件被选中</td></tr><tr><td>:disabled</td><td>部件被禁用</td></tr><tr><td>:enabled</td><td>部件被启用</td></tr><tr><td>:focus</td><td>部件获得焦点</td></tr><tr><td>:hover</td><td>鼠标位于部件上</td></tr><tr><td>:indeterminate</td><td>checkbox或radiobutton被部分选中</td></tr><tr><td>:off</td><td>部件可以切换，且处于off状态</td></tr><tr><td>:on</td><td>部件可以切换，且处于on状态</td></tr><tr><td>:pressed</td><td>部件被鼠标按下</td></tr></tbody></table><h4 id="没有选择器的情况"><a href="#没有选择器的情况" class="headerlink" title="没有选择器的情况"></a><strong>没有选择器的情况</strong></h4><p>如果在 c++的代码中直接调用控件对象的 setStyleSheet 函数来设置样式,但样式中没有任何选择器, 例如下面这样</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pBtn1-&gt;setStyleSheet("<span class="attribute">color</span>: green;");</span><br></pre></td></tr></tbody></table></figure><p>即使这种写法可以生效, 但它不符合语法规则, 因此不推荐使用.经过测试, <font color="red"><code>这样的语句被忽略的选择器相当于通用选择器</code></font>或下面例子中的选择器, 假如 pBtn1 是一个 QPushButton 对象的指针, 那么这条语句等价于</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pBtn1-&gt;setStyleSheet("QPushButton, QPushButton *{<span class="attribute">color</span>: green;}");</span><br></pre></td></tr></tbody></table></figure><h4 id="选择器的匹配规则"><a href="#选择器的匹配规则" class="headerlink" title="选择器的匹配规则"></a><strong>选择器的匹配规则</strong></h4><p>之所以要把这个问题单独作为一个小节来写, 是因为在日常开发过程中, 经常会犯这方面的错误.</p><p>下面看一个例子:假如需要完成一个界面, 如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081409652.png"></p><p>这里用户名输入框是一个 QComboBox 对象, 密码输入框是一个 QLineEdit 对象, 它们的父控件是一个 QDialog, 有这样一个需求:给这两个输入框设置相同的边框属性: 1 个像素宽的蓝色实线框, 为了方便更改风格, 我有一个 css 文件, 将所有样式都写在了这个文件里, 这时, 观察发现, 这两个控件都是QDialog的子控件,于是可以用后代选择器或者子元素选择器, 如下:</p><p>第一种:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QDialog QComboBox,QLineEdit{</span><br><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid blue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第二种:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QDialog&gt;QComboBox,QLineEdit{</span><br><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid blue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当我写完并运行程序后, 发现无论采用哪种写法 QComboBox 是正常的, 但是我的程序界面中, <font color="orange"><code>其他所有的 QLineEdit 的边框都变成了 1 个像素款的蓝色实线框</code></font>, 而这并不是我想要的效果.</p><p>因此对于上面的现象, 我们很容易得出结论: <font color="red"><code>多个选择器组合(并集选择器)使用时, 它们的结合方向是自右向左, 而不是我们认为的自左向右</code></font>.也就是说, 这两个选择器分别被理解为<font color="orange"><code>(QDialogQComboBox), QLineEdit</code></font> 和<font color="orange"><code>(QDialog&gt;QComboBox),QLineEdit</code>.</font></p><p>其实, 这应该与 CSS 的选择器匹配规则是一样的, 是为了提高效率的一种做法, 具体原因这 里不细谈.</p><p>正确的写法应该是</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QDialog QComboBox, QDialog QLineEdit{</span><br><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid blue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>或</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QDialog&gt;QComboBox, QDialog&gt;QLineEdit{</span><br><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid blue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Qss-的特性"><a href="#Qss-的特性" class="headerlink" title="Qss 的特性"></a><strong>Qss</strong> <strong>的特性</strong></h2><h3 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a><strong>层叠性</strong></h3><p>qss 的语法来源于 css, 而 css 的全称是 Cascading StyleSheet, 翻译过来叫做层叠样式表,</p><p>也叫级联样式表, 本文中一律使用层叠样式表.</p><p>层叠性是 css 处理冲突的一种能力.</p><p>只有在多个选择器匹配到同一个控件时才会发生层叠性, 如下面的例子:</p> <figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pBtn1-&gt;setStyleSheet("QPushButton{<span class="attribute">color</span>: blue;}");</span><br><span class="line"></span><br><span class="line"> pBtn1-&gt;setStyleSheet("<span class="selector-class">.QPushButton</span>{<span class="attribute">color</span>: green;}");</span><br></pre></td></tr></tbody></table></figure><p>这两个选择器匹配到了同一个按钮, (<font color="orange"><code>选择器优先级相同的情况下</code></font>)结果是后面的样式覆盖掉了前面的, 这就是层叠现象.</p><h3 id="继承性-Qt-Version-gt-x3D-5-7"><a href="#继承性-Qt-Version-gt-x3D-5-7" class="headerlink" title="继承性(Qt-Version >= 5.7)"></a><strong>继承性</strong><strong>(Qt-Version &gt;= 5.7)</strong></h3><p>在典型的 CSS 中，如果一个标签的字体和颜色没有显式设置，它会自动从其父亲获得。当使</p><p>用 Qt 样式表时，控件**<font color="orange">不会</font>**从其<font color="orange"><strong>父亲(不是父类)</strong></font>继承字体和颜色的设置(请注意，父亲和父类、孩子和子类都是不同的概念，不要搞混)</p><p>举个例子，考虑一个 QGroupBox 内有一个 QPushButton：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qApp-&gt;setStyleSheet("QGroupBox{ <span class="attribute">color</span>: red; }");</span><br></pre></td></tr></tbody></table></figure><p>QPushButton 没有任何显式的 color 设置。因此，<font color="orange"><code>它会获得系统的颜色而不是从父亲继承 color的值</code></font>。如果我们要设置 QGroupBox 及其所有孩子的 color，我们可以这样写：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qApp-&gt;setStyleSheet("QGroupBox,QGroupBox * { <span class="attribute">color</span>: red; }");</span><br></pre></td></tr></tbody></table></figure><p>注意 QGroupBox 和*之间的空格。与此相反，使用 QWidget::setFont()可以设置字体包括孩子的字体，使用 <font color="orange"><code>QWidget::setPalette()</code></font>可以设置调色板包括孩子的调色板。如果想要字体和调 色板被孩子继承 , 可以给 QApplication 设 置<font color="orange"><code>Qt::AA_UseStyleSheetPropagationInWidgetStyles</code></font>(Qt5.7 加入)属性, 例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QCoreApplication::<span class="built_in">setAttribute</span>(Qt::AA_UseStyleSheetPropagationInWidgetStyles, true);</span><br></pre></td></tr></tbody></table></figure><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a><strong>优先级</strong></h2><p>为什么要有优先级？</p><p>当一个控件被多个选择器选中并且设置了相同的属性（值不同）时， 不能仅仅根据设置样式语句出现的先后顺序进行层叠, 那么控件的样式如何确定，于是引出了选择器的优先级问题。</p><p>一般通过下面两步进行选择器优先级的判定.</p><h3 id="第一步：-设置方式所产生的优先级问题"><a href="#第一步：-设置方式所产生的优先级问题" class="headerlink" title="第一步： 设置方式所产生的优先级问题"></a><strong>第一步：</strong> <strong>设置方式所产生的优先级问题</strong></h3><p>在 CSS 中， 有如下层叠优先级规则：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内联样式&gt;内部样式&gt;外部样式&gt;浏览器缺省</span><br></pre></td></tr></tbody></table></figure><p>而在 Qss 中, 这个规则表现为:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给控件直接设置的样式&gt;给QApplication设置的样式</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>就是说， 调用控件的 setStylesheet 设置的样式的优先级永远高于给 QApplication 设置的样式， 即使 QApplication 中的选择器优先级更高</code></font></p><h3 id="第二步：样式表本身的优先级问题"><a href="#第二步：样式表本身的优先级问题" class="headerlink" title="第二步：样式表本身的优先级问题"></a><strong>第二步：样式表本身的优先级问题</strong></h3><p>当设置方式相同，且几个样式规则为同一个控件的同一个属性指定不同的值时,就产生了冲突.此时, 如何层叠就由选择器的优先级来确定.一般而言，<font color="red"><code>选择器越特殊，它的优先级越高。也就是选择器指向的越准确，它的优先级就越高。</code></font></p><h3 id="优先级判断的三种方式"><a href="#优先级判断的三种方式" class="headerlink" title="优先级判断的三种方式"></a><strong>优先级判断的三种方式</strong></h3><h4 id="间接选中"><a href="#间接选中" class="headerlink" title="间接选中"></a>间接选中</h4><p>间接选中就是指继承, 也就是在 Qt5.7 及以上版本, 程序中给 <font color="orange"><code>QApplication</code></font> 对象设置了<font color="purple"><code>Qt::AA_UseStyleSheetPropagationInWidgetStyles</code> </font>属性时, 才会有间接选中.</p><p><font color="orange"><code>如果是间接选中,那么最终的样式就是离目标最近的那个</code></font>, 这里的近指的是两个控件的父子关系. </p><p>例如:</p><blockquote><p>一个 QPushButton 对象被布局在 QGroupBox 中, 而 QGroupBox 又被布局在 QWidget 中, 此时如果给 QGroupBox 和 QWidget 都设置了 color 属性的颜色, 那么无论设置顺序如何, QPushButton 的前景色总是表现为 QGroupBox 设置的颜色, 因为QGroupBox 显然是离 QPushButton 最近的那一个.</p></blockquote><h4 id="相同选择器-直接选中"><a href="#相同选择器-直接选中" class="headerlink" title="相同选择器(直接选中)"></a>相同选择器(直接选中)</h4><p>如果都是直接选中, 并且都是同类型的选择器, 那么写在后面的样式会覆盖掉前面的样式, 例如</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pBtn1-&gt;setStyleSheet("QPushButton{<span class="attribute">color</span>: green;}");</span><br><span class="line"></span><br><span class="line">pBtn1-&gt;setStyleSheet("QPushButton{<span class="attribute">color</span>: blue;}");</span><br></pre></td></tr></tbody></table></figure><p>显而易见, pBtn1 的前景色是蓝色.</p><h4 id="不同选择器-直接选中"><a href="#不同选择器-直接选中" class="headerlink" title="不同选择器(直接选中)"></a>不同选择器(直接选中)</h4><p>如果都是直接选中, 并且不是相同类型的选择器, 那么就会按照选择器的优先级来层叠.</p><p>具体的优先级如下: </p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Id &gt; 类 &gt; 类型 &gt; 通配符 &gt; 继承 &gt; 默认</span><br></pre></td></tr></tbody></table></figure><h3 id="优先级权重"><a href="#优先级权重" class="headerlink" title="优先级权重"></a><strong>优先级权重</strong></h3><p>为什么会有优先级权重？</p><p>当多个选择器混合在一起使用时, 我们可以通过计算权重来判断谁的优先级最高,从而确定控件的样式.</p><p>注意点： </p><p><font color="red"><code>只有选择器是直接选中控件时才需要计算权重， 否则直接选择器高于一切间接选中的选择器</code></font></p><p>优先级权重的计算方式:</p><blockquote><ol><li><p>计算选择器中的 id 选择器数量[=a]</p></li><li><p>计算选择器中类选择器的数量+属性选择器的数量[=b]</p></li><li><p>计算选择器中类型选择器的数量[=c]</p></li><li><p>忽略子控件选择器</p></li></ol><p>串联这三个数字 a-b-c 就得到优先级权重, 数字越大优先级越高.</p></blockquote><p>串联这三个数字 a-b-c 就得到优先级权重, 数字越大优先级越高.</p><p>这里给出我写的一个例子， qss 文件位于资源文件中：</p><h3 id="Qt-官方关于冲突解决的说明"><a href="#Qt-官方关于冲突解决的说明" class="headerlink" title="Qt 官方关于冲突解决的说明"></a><strong>Qt</strong> <strong>官方关于冲突解决的说明</strong></h3><p>当几个样式规则为同一个属性指定不同的值时，就产生了冲突。请考虑下面的样式表：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QPushButton**<span class="selector-id">#okButton</span>** { <span class="attribute">color</span>: gray; }</span><br><span class="line"></span><br><span class="line">QPushButton { <span class="attribute">color</span>: red; }</span><br></pre></td></tr></tbody></table></figure><p>两条规则都匹配名为 okButton 的 QPushButton 实例并且冲突于颜色属性。为了解决冲突，我们必须考虑到选择器的特殊性。在上面的例子中，QPushButton#okButton 被视为比QPushButton 更特殊，<font color="orange"><code>因为它（通常）指向一个单一的对象而不是 QPushButton 的所有实例</code></font>。 相似的，<font color="orange"><code>指定了伪状态的选择器比没有指定伪状态的更特殊</code></font>。从而，下面的样式表指明了当鼠标悬浮到 QPushButton 上方时其字体颜色应该为白色，而其余情况则为红色：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:hover</span> { <span class="attribute">color</span>: white; }</span><br><span class="line"></span><br><span class="line">QPushButton { <span class="attribute">color</span>: red; }</span><br></pre></td></tr></tbody></table></figure><p>接下来看一个很有意思的：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:hover</span> { <span class="attribute">color</span>: white; }</span><br><span class="line"></span><br><span class="line">QPushButton<span class="selector-pseudo">:enabled</span> { <span class="attribute">color</span>: red; }</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>两个选择器都有相同的特殊性</code></font>，所以当鼠标悬浮在一个 enabled 的按钮上时，第二条规则优先。</p><p>如果在这种情况下我们想要文字变成白色，我们可以像下面那样重新排布一下样式规则：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:enabled</span> { <span class="attribute">color</span>: red; }</span><br><span class="line"></span><br><span class="line">QPushButton<span class="selector-pseudo">:hover</span> { <span class="attribute">color</span>: white; }</span><br></pre></td></tr></tbody></table></figure><p>另外，我们可以使第一条规则更特殊一些：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:hover</span><span class="selector-pseudo">:enabled</span> { <span class="attribute">color</span>: white; }</span><br><span class="line"></span><br><span class="line">QPushButton<span class="selector-pseudo">:enabled</span> { <span class="attribute">color</span>: red; }</span><br></pre></td></tr></tbody></table></figure><p>相似的问题出现在相互配合的类型选择器上。考虑以下情况：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QPushButton { <span class="attribute">color</span>: red; }</span><br><span class="line"></span><br><span class="line">QAbstractButton { <span class="attribute">color</span>: gray; }</span><br></pre></td></tr></tbody></table></figure><p>两条规则都应用于 QPushButton 的实例（因为 QPushButton 继承于 QAbstractButton）并且冲突于 color 属性。因为 QPushButton 继承于 QAbstractButton，这让人不禁想到 QPushButton比 QAbstractButton 更特殊(<font color="red">并没有更特殊</font>)。然而，<font color="orange"><code>对于样式表的运算，所有的类型选择器都具有同等的特殊性，并且出现在更后面的规则优先级更高</code></font>。换句话说，QAbstractButton 的 color 会被设置成灰色，包括 QPushButton。如果我们确实想要 QPushButton 字体颜色设置为红色，<font color="orange"><code>我们总是可以使用重新排列样式表规则顺序的方式实现</code></font>。</p><p>为确定规则的特殊性，Qt 样式表跟随 CSS2 规范</p><p>一个选择器的特殊性由下面的方式计算：</p><blockquote><ul><li><p>计算选择器中 ID 属性的数量[=a] </p></li><li><p>计算选择器中其他属性和伪类的数量[=b] </p></li><li><p>计算选择器中元素名字的数量[=c] </p></li><li><p>忽略伪原素[如:subcontrol]</p></li></ul></blockquote><p>串联这三个数字<font color="orange"> <code>a-b-c</code></font>（在一个大基数的数字系统）就得到了特殊性等级。</p><p>举个例子：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* {} <span class="comment">/* a=0 b=0 c=0 -&gt; specificity = 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">LI</span> {} <span class="comment">/* a=0 b=0 c=1 -&gt; specificity = 1 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">UL</span> <span class="selector-tag">LI</span> {} <span class="comment">/* a=0 b=0 c=2 -&gt; specificity = 2 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">UL</span> <span class="selector-tag">OL</span>+<span class="selector-tag">LI</span> {} <span class="comment">/* a=0 b=0 c=3 -&gt; specificity = 3 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">H1</span> + *<span class="selector-attr">[REL=up]</span>{} <span class="comment">/* a=0 b=1 c=1 -&gt; specificity = 11 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">UL</span> <span class="selector-tag">OL</span> <span class="selector-tag">LI</span><span class="selector-class">.red</span> {} <span class="comment">/* a=0 b=1 c=3 -&gt; specificity = 13 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">LI</span><span class="selector-class">.red</span><span class="selector-class">.level</span> {} <span class="comment">/* a=0 b=2 c=1 -&gt; specificity = 21 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#x34y</span> {} <span class="comment">/* a=1 b=0 c=0 -&gt; specificity = 100 */</span></span><br></pre></td></tr></tbody></table></figure><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a><strong>盒模型</strong></h2><p>在讲解属性之前, 我们必须了解一下 QSS 的盒模型.</p><h3 id="什么是盒模型"><a href="#什么是盒模型" class="headerlink" title="**什么是盒模型? **"></a>**什么是盒模型? **</h3><p>盒模型仅仅是一个形象的比喻, 所有的 widget 都被看做是一个”盒子”, 一个盒子包括：外边距，边框，内边距，和实际内容. 它们可以看作是有包含关系的矩形, 并且这种包含关系是固定不变的.</p><p>如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081520165.png"></p><blockquote><p><strong>Margin</strong> <strong>（外边距）</strong> - 与其他盒子之间的距离.</p><p><strong>Border</strong> <strong>（边框）</strong> - 外边距与内边距之间的区域.边框有自己的颜色不会受到盒子的背景颜色影响</p><p><strong>Padding</strong> <strong>（内边距）</strong> - 内容和边框之间的区域.会受到背景颜色影响. </p><p><strong>Content</strong> <strong>（内容）</strong> - 盒子的内容,显示文本,图像或其他控件</p></blockquote><p>除了内容外, 其他三个部分均不能单独设置颜色, 只能设置其宽度, 并且是以像素为单位.</p><p>对比一张生活中的一张照片墙来看会更容易理解</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081522950.png"></p><h3 id="盒模型中的宽度与高度"><a href="#盒模型中的宽度与高度" class="headerlink" title="盒模型中的宽度与高度"></a><strong>盒模型中的宽度与高度</strong></h3><p>在属性中将要学到的 width, height 两个属性, 设置的均是盒子的<strong>内容</strong>的宽高, 而我们在 c++</p><p>代码中的窗口的 width 与 height 指的是<strong>整个盒子的宽度与高度</strong>, 这一点非常重要.</p><p>整个盒子的宽度应该等于:</p><p>左外边距 + 左边框 + 左内边距 + 内容宽度 + 右内边距 + 右边框 + 右外边距,</p><p>同理, 整个盒子的高度也是上下外边距,内边距,边框和内容高度的和.</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a><strong>属性</strong></h4><p><font color="orange"><code>属性即控件的具体外观样式</code></font>, 比如背景颜色, 边框宽度等等. 本节主要列举一些常用的属性,并介绍它们的具体格式或取值</p><p>注意:<font color="red"><code>一个属性并不是被所有 widget 都支持的</code></font>, 要想查看什么 widget 支持哪些属性, 或一个属性被哪些 widget 支持, 请查看文档后面给出的官方链接.</p><h4 id="背景属性-background"><a href="#背景属性-background" class="headerlink" title="背景属性 background"></a><strong>背景属性</strong> <strong>background</strong></h4><p>背景共有 7 个属性, <font color="orange"><code>既可以每个属性单独设置, 也可以连写</code></font>, 下面将对他们逐一进行分析,并在最后给出其连写格式</p><h5 id="background-color"><a href="#background-color" class="headerlink" title="background-color"></a><strong>background-color</strong></h5><p>取值: Brush 类型(Brush 类型介绍见本节最后)</p><p>作用: 设置控件的背景颜色, <font color="orange"><code>默认是 border 之内的矩形区域, 包括内边距和内容矩形</code></font>.</p><h5 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a><strong>background-image</strong></h5><p>取值: Url 类型, 格式是 url(filename), <font color="orange"><code>filename 是一个本地文件路径或 Qt 资源文件路径, 不支持网络图片</code></font></p><p>作用: 设置控件的背景图片. <font color="orange"><code>可以与背景颜色共存, 背景图片会覆盖背景颜色, 在没有被图片覆盖的区域, 显示背景颜色.</code></font></p><h5 id="background-repeat"><a href="#background-repeat" class="headerlink" title="background-repeat"></a><strong>background-repeat</strong></h5><p>取值:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repeat-x: 在水平方向上平铺</span><br><span class="line"></span><br><span class="line">repeat-y: 在垂直方向上平铺</span><br><span class="line"></span><br><span class="line">repeat: 在水平和垂直方向上都平铺, 这是默认值(但是 Qt 好像有 bug, 设置了 repeat 反而不会平铺, 不设置才平铺)</span><br><span class="line"></span><br><span class="line">no-repeat: 不平铺</span><br></pre></td></tr></tbody></table></figure><p>作用: <font color="orange"><code>设置背景图片的平铺方式.</code> </font></p><p>例子: </p><p>给一个 QTextEdit 设置背景图片,代码和效果分别如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>);</span><br><span class="line"><span class="attribute">background-repeat</span>: no-repeat;<span class="comment">/*repeat-x; repeat-y; repeat;*/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081535428.png" alt="repeat-x"><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081535917.png" alt="repeat-y"></p><p>​            </p><p>  <img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081535678.png" alt="repeat"><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081535053.png" alt="no-repeat">  </p><p>​</p><h5 id="background-position"><a href="#background-position" class="headerlink" title="background-position"></a><strong>background-position</strong></h5><p>取值:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">top</span>: 向上对齐 left: 向左对齐</span><br><span class="line"></span><br><span class="line">bottom: 向下对齐 right:向右对齐</span><br><span class="line"></span><br><span class="line">center: 居中</span><br></pre></td></tr></tbody></table></figure><p>格式:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-position</span>: 水平对齐方式 垂直对齐方式;</span><br></pre></td></tr></tbody></table></figure><p>这是 css 规定的标准顺序, 而 qss 并未严格规定, 但建议按照 css 的顺序写</p><p>作用: <font color="orange"><code>设置背景图片的对齐方式, 默认情况下向左向上对齐,</code></font></p><p>举例: 水平向左垂直居中对齐, 代码和效果如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>);</span><br><span class="line"><span class="attribute">background-position</span>: right center; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081535623.png"></p><h5 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a><strong>background-attachment</strong></h5><p>取值:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scroll : 滚动, 这是默认值</span><br><span class="line"></span><br><span class="line">fixed: 固定</span><br></pre></td></tr></tbody></table></figure><p>作用: <font color="orange">设置背景图片在带滚动条的控件(QAbstractScrollArea)中是固定在一个位置还是随着滚动条滚动.</font></p><p>比如: css 代码分别如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>);</span><br><span class="line"><span class="attribute">background-repeat</span>: no-repeat;<span class="comment">/*repeat-x; repeat-y; repeat;*/</span></span><br><span class="line"><span class="attribute">background-position</span>: right center;</span><br><span class="line"><span class="attribute">background-attachment</span>: scroll; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;<span class="comment">/*repeat-x; repeat-y; repeat;*/</span></span><br><span class="line"><span class="attribute">background-position</span>: right center;</span><br><span class="line"><span class="attribute">background-attachment</span>: fixed; </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p>效果图</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081541879.png" alt="scroll "><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081541064.png" alt="fixed"></p><p>​</p><h5 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a><strong>background-clip</strong></h5><p>取值:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">margin</span>: 外边距矩形</span><br><span class="line"></span><br><span class="line">border: 边框矩形</span><br><span class="line"></span><br><span class="line">padding: 内边距矩形</span><br><span class="line"></span><br><span class="line">content: 内容矩形</span><br></pre></td></tr></tbody></table></figure><p>作用: <font color="orange"><code>设置背景颜色覆盖的区域, 默认情况下背景只覆盖内边距矩形, 如果没有指定, 默认值为 border</code></font></p><p>例子: 为了区别各矩形, 我们先给 QTextEdit 设置边框,内边距和外边距, 为了区别明显, 我们将边框宽度设置大一点</p><p>代码和图片如下:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">20px</span> solid purple;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>);</span><br><span class="line"><span class="attribute">background-repeat</span>: no-repeat;<span class="comment">/*repeat-x; repeat-y; repeat;*/</span></span><br><span class="line"><span class="attribute">background-position</span>: left top;</span><br><span class="line"><span class="attribute">background-attachment</span>: fixed; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205101117655.png"></p><p>分别将 background-clip 属性的值设为 margin, border, padding, content, </p><p>效果图如下</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081542686.png" alt="margin "><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081548247.png" alt="border"></p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081543791.png" alt="padding"><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081543463.png" alt="content"></p><pre><code>                                                                 content</code></pre><p><font color="orange"><code>可见, background-clip 属性只对背景的渲染区域有关系</code></font>, 背景图片始终是靠在 padding 边上</p><h5 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a><strong>background-origin</strong></h5><p>取值: 与 background-clip 一样</p><p>作用: 与 background-position 和 background-image 一起使用,<font color="orange"> 指明背景图片的覆盖范围矩形</font>,如果没有指定, <font color="orange">默认为 padding</font></p><p>下面是分别设置为 margin, border, padding 和 content 的代码和效果图</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">20px</span> solid purple;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>);</span><br><span class="line"> <span class="comment">/*background-repeat: no-repeat;*/</span><span class="comment">/*repeat-x; repeat-y; repeat;*/</span></span><br><span class="line"><span class="attribute">background-position</span>: left top;</span><br><span class="line"><span class="attribute">background-attachment</span>: fixed;</span><br><span class="line"><span class="attribute">background-clip</span>: margin; <span class="comment">/*border; padding; content;*/</span></span><br><span class="line"><span class="attribute">background-origin</span>: margin; <span class="comment">/*border; padding; content;*/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081548330.png" alt=" margin "><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081549270.png" alt="border"></p><p>​</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081808678.png" alt="padding"><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081549494.png" alt="content"></p><p>注意观察 border 与 padding 的图片, 它们是不同的, 差别就是 border 的 20 个像素所造成的不一致。</p><h5 id="背景属性的连写格式"><a href="#背景属性的连写格式" class="headerlink" title="背景属性的连写格式"></a><strong>背景属性的连写格式</strong></h5><p>格式:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background</span>: color image repeat position;</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>在这种连写格式中, 只能包含着四个属性, 其他几个仍然需要单独写, 而且这四个属性可以省略任何一个, 最多可以省略三个, 也就是最少需要保留一个,即属性值不能为空</code></font></p><p><font color="red"><code>另外让人比较迷惑的是, 在这种连写方式中,repeat 确实是平铺了图片, 而单独写时, 它又是不平铺的, 具体原因还未找到.</code></font></p><p>举个例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">20px</span> solid purple;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">background</span>: skyblue <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>) repeat left top; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>效果图</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081552920.png"></p><h4 id="前景属性-color"><a href="#前景属性-color" class="headerlink" title="前景属性 color"></a><strong>前景属性</strong> <strong>color</strong></h4><p>与背景相对应, 背景设置的是控件的最底层的颜色, 作为背景, 但 <font color="orange"><code>color 设置的前景色, 也就是控件文字的颜色</code></font>, color 属性是被所有 widget 都支持的.</p><p>格式:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">color</span>: Brush类型的值;</span><br></pre></td></tr></tbody></table></figure><p>举个例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081556014.png"></p><h4 id="边框属性-border"><a href="#边框属性-border" class="headerlink" title="**边框属性 border"></a>**<strong>边框属性</strong> <strong>border</strong></h4><p>边框属性有四种书写方式, 同样, 先逐一进行分析, 最后给出书写格式</p><h5 id="border-width"><a href="#border-width" class="headerlink" title="border-width"></a><strong>border-width</strong></h5><p>取值: ?px 像素宽度, 数值后面一定要加上像素单位 px, 也有其他单位, 但不推荐使用</p><p>作用:用于边框宽度</p><p>例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border-width</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">border-style</span>: solid;</span><br><span class="line"><span class="attribute">border-color</span>:purple;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">20px</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>效果图</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081557565.png"></p><h5 id="border-style"><a href="#border-style" class="headerlink" title="border-style"></a><strong>border-style</strong></h5><p>设置边框的渲染样式.</p><p>取值以及效果如下:</p><p>dashed </p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081557030.png"></p><p>dot-dash </p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081557540.png"></p><p>dot-dot-dash</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081557180.png"></p><p>dotted</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081558909.png"></p><p>double</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081558333.png"></p><p>groove</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081558590.png"></p><p>inset</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081558125.png"></p><p>outset</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081558853.png"></p><p>ridge</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081559284.png"></p><p>solid</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081559793.png"></p><p>none</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081559309.png"></p><h5 id="border-color"><a href="#border-color" class="headerlink" title="border-color"></a><strong>border-color</strong></h5><p>取值: Brush 类型</p><p>作用: 设置边框的颜色</p><h5 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a><strong>border-radius</strong></h5><p>取值: 水平半径 垂直半径;</p><p>均是以像素为单位, 值必须带 px, 第二个值是可选的, 如果只有一个值, 表示同时水平半径和垂直半径, 如果有两个值, 则第一个代表水平半径, 第二个代表垂直半径.</p><p>示例图</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081600183.png"></p><p>作用: 设置边框四个角的弧度</p><p>举个例子:</p><p>代码 1:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line">border-width: 10px;</span><br><span class="line">border-style: solid;</span><br><span class="line">border-color: red;</span><br><span class="line">border-radius: 50px;</span><br><span class="line">padding: 20px;</span><br><span class="line">margin: 20px; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码 2:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border-width</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">border-style</span>: solid;</span><br><span class="line"><span class="attribute">border-color</span>: red;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">50px</span> <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">20px</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081802324.png" alt=""><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081801057.png" alt="" style="zoom:;"></p><p> 代码 1 效果图 代码 2 效果图</p><h5 id="border-image"><a href="#border-image" class="headerlink" title="border-image"></a><strong>border-image</strong></h5><p>取值: 这是一个连写格式, 下面给出具体的书写格式, 由于 <font color="orange"><code>Qt 对这个属性支持不是很好, 因此不建议使用</code></font>, 下面简要介绍一下</p><p>格式:</p><p>CSS 的连写格式如下, 每一项分别代表分开写时的一个属性.</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-image</span>: border-image-source border-image-slice (fill)/ border-image-width</span><br><span class="line">/ border-image-outset border-image-repeat</span><br></pre></td></tr></tbody></table></figure><p>其中,<font color="orange"> <code>fill, border-image-width 和 border-image-outset 在 Qt 中不被支持</code></font>, 而且 Qt 只支持连写格式, 因此在 Qt 中, 我们实际的代码格式是</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-image</span>: border-image-source border-image-slice border-image-repeat</span><br></pre></td></tr></tbody></table></figure><p>下面简略说一下每项的含义:</p><blockquote><p>border-image-source: <font color="orange">图片路径,还是只支持本地路径和 Qt 资源文件路径.</font></p><p>border-image-slice: 图片切片, 单位只能是像素值, 因此数值不必带单位 px, 它最多可以指 定 4 个值,按照顺序分别代表上右下左, 最少指定 1 个值, 左省略时和右相同,下省略时和上相同, 右省略时和上相同; 它们的含义是, 距图片顶部, 右侧, 下部, 左侧分别按照指定的像素值进行切片, 将图片分成 四个角(左上,右上,右下,左下) + 四个边(上右下左) + 中间部分 = 共 9 个部分, 在 CSS 中, 如果指定了 fill, 则中间部分会覆盖元素(控件)的背景, 否则中间部分默认被省略</p><p>border-image-repeat: 最多两个值最少一个值, 第一个值表示水平方向, 第二个值表示垂直方向. 作用是指定边框图片的四条边和四个角的平铺方式,不包括中间部分, 有三种取值, 分别为 <strong>stretch</strong>(默认), <strong>round</strong>(均分平铺), <strong>repeat</strong>(平铺). stretch 表示拉伸四条边相应的切片图片,来填补边框的间隙.round 是把四个角和四条边分成均等区域然后用背景图片切好能铺满整个边框空隙, 不能多也不能少, 正好合适. repeat 是做直接复制填满空隙.</p></blockquote><p>下面是一个切片的具体示例:利用上面这张图片,来看一下 border-image 的一些效果图</p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20220508160643576.png" alt="" style="zoom:150%;"><p>效果 1:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">30px</span> solid red;</span><br><span class="line"><span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/border.png</span>) <span class="number">30</span> round;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081607846.png"></p><p>效果 2:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">30px</span> solid red;</span><br><span class="line"><span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/border.png</span>) <span class="number">30</span> stretch;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081609325.png"></p><p>效果 3:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">30px</span> solid red;</span><br><span class="line"><span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/border.png</span>) <span class="number">30</span> repeat;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081609923.png"></p><p>效果 4:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">30px</span> solid red;</span><br><span class="line"><span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/border.png</span>) <span class="number">30</span> repeat stretch;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081610885.png"></p><h5 id="格式-10"><a href="#格式-10" class="headerlink" title="格式"></a><strong>格式</strong></h5><p>border 属性的 style, color, width 可以连写也可以单独写, 并且可以分别设置四条边的边框,</p><p>下面进行详细介绍</p><h6 id="连写格式-1"><a href="#连写格式-1" class="headerlink" title="连写格式 1"></a><strong>连写格式</strong> <strong>1</strong></h6><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>: width style color;</span><br></pre></td></tr></tbody></table></figure><p>这种格式将四条边框的宽度, 风格, 颜色全部设置为一样.</p><p>例子如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">10px</span> solid red;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20220508161138157.png" alt=""><h6 id="连写格式-2"><a href="#连写格式-2" class="headerlink" title="连写格式 2"></a><strong>连写格式</strong> <strong>2</strong></h6><p>这种格式设置指定方向的边框的样式, 可以只设置一条边, 格式如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-top</span>: width style color;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border-right</span>: width style color;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border-bottom</span>: width style color;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border-left</span>: width style color;</span><br></pre></td></tr></tbody></table></figure><p>例子如下:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border-top</span>: <span class="number">10px</span> solid red;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20220508161311854.png" alt=""><p><strong>连写格式</strong> <strong>3</strong> </p><p>这种连写格式是指定一种属性, 按照上右下左四个方向进行设置边框, 格式如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-style</span>:上 右 下 左;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border-width</span>:上 右 下 左;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border-color</span>:上 右 下 左;</span><br></pre></td></tr></tbody></table></figure><p>其中, 后三个可以省略, 左省略则与右相同, 下省略则与上相同, 右省略与上相同</p><p>这里给两个示例:</p><p>示例 1:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border-style</span>: solid dashed dotted double;</span><br><span class="line"><span class="attribute">border-color</span>: red green blue purple;</span><br><span class="line"><span class="attribute">border-width</span>: <span class="number">5px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20220508161913218.png" alt=""><p>示例 2:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border-style</span>: solid dashed ;</span><br><span class="line"><span class="attribute">border-color</span>: red green blue;</span><br><span class="line"><span class="attribute">border-width</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>单写格式</strong> </p><p>单写格式指的是, 对每条边框的每个属性分别进行设置, 格式如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-top-width</span> <span class="attribute">border-top-style</span> <span class="attribute">border-top-color</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">border-right-width</span> <span class="attribute">border-right-style</span> <span class="attribute">border-right-color</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">border-bottom-width</span> <span class="attribute">border-bottom-style</span> <span class="attribute">border-bottom-color</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">border-left-width</span> <span class="attribute">border-left-style</span> <span class="attribute">border-left-color</span></span><br></pre></td></tr></tbody></table></figure><h4 id="字体属性-font"><a href="#字体属性-font" class="headerlink" title="字体属性 font"></a><strong>字体属性</strong> <strong>font</strong></h4><h5 id="font-style"><a href="#font-style" class="headerlink" title="font-style"></a><strong>font-style</strong></h5><p>作用: 设置字体风格</p><p>取值:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">normal</span>: 正常</span><br><span class="line"></span><br><span class="line">italic: 斜体</span><br><span class="line"></span><br><span class="line">oblique: 倾斜的字体</span><br></pre></td></tr></tbody></table></figure><p>关于 italic 和 oblique 的区别:</p><p>他们都是向右倾斜的文字, 大多数情况下看不出任何区别, 但是原理却不一样.</p><p>要搞清楚这个问题，首先要明白字体是怎么回事。一种字体有粗体、斜体、下划线、删除线</p><p>等诸多属性。但是并不是所有字体都做了这些，一些不常用的字体，或许就只有个正常体，如果你用 Italic，</p><p>就没有效果了,这时候就要用 Oblique.</p><p><font color="orange"><code>可以理解成 Italic 是使用文字的斜体，Oblique 是让没有斜体属性的文字倾斜！</code></font></p><h5 id="font-weight"><a href="#font-weight" class="headerlink" title="font-weight"></a><strong>font-weight</strong></h5><p>作用: 设置文字的粗细</p><p>取值:</p><p>它有两种取值, 一种是单次表示:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">normal</span>: 正常粗细</span><br><span class="line"></span><br><span class="line">bold: 加粗</span><br></pre></td></tr></tbody></table></figure><p>另一种是整数表示, 整数越大, 字体越粗</p><p>100, 200, 300, …, 900 </p><h5 id="font-size"><a href="#font-size" class="headerlink" title="font-size"></a><strong>font-size</strong></h5><p>作用: 设置字体大小</p><p>取值:</p><p>字体大小的取值是一个数值加上单位, 它的单位有 px , pt , 但一般都使用 px, 表示多少个像素, 如 20px, 表示字体的宽和高</p><p>说明:</p><p>注意，<font color="orange"><code>实际上它设置的是字体中字符框的高度；实际的字符字形可能比这些框高或矮（通常会矮）</code></font>。</p><p>各关键字对应的字体必须比一个最小关键字相应字体要高，并且要小于下一个最大关键字对应的字体。</p><h5 id="font-family"><a href="#font-family" class="headerlink" title="font-family"></a><strong>font-family</strong></h5><p>作用: 设置文字字体</p><p>取值: 各种字体名称</p><p>如果字体是中文, 尽量用双引号括起来</p><p>QSS 中 font-family 只能指定一种字体</p><h5 id="连写格式"><a href="#连写格式" class="headerlink" title="连写格式"></a><strong>连写格式</strong></h5><p>字体属性可以单写, 也可以连写, 连写格式如下:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">font</span>: style weight size family</span><br></pre></td></tr></tbody></table></figure><p>这种书写格式中的注意点:</p><blockquote><ol><li><p>style 和 weight 的位置可以交换, 并且可以省略;</p></li><li><p>size 不能被省略</p></li><li><p>size 和 family 必须写在其他两个属性的后面, 并且位置不能交换</p></li><li><p>family 可以省略, 省略后使用默认字体</p></li></ol></blockquote><p>举个例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">font</span>: normal normal <span class="number">30px</span> <span class="string">"隶书"</span>;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081631678.png"></p><h4 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a><strong>文本属性</strong></h4><h5 id="text-align"><a href="#text-align" class="headerlink" title="text-align"></a><strong>text-align</strong></h5><p>作用:设置文本的对齐方式</p><p>取值:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">top</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">bottom</span> </span><br><span class="line"></span><br><span class="line"><span class="attribute">left</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">right</span></span><br><span class="line"></span><br><span class="line">center</span><br></pre></td></tr></tbody></table></figure><p><font color="red">注意点: 支持这个属性的控件目前只有 QPushButton 和 QProgressBar.</font></p><p>格式:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">text-align</span>: 水平对齐方式(left, right, center) 垂直对齐方式(top bottom center);</span><br></pre></td></tr></tbody></table></figure><p>举个例子</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QPushButton{</span><br><span class="line"><span class="attribute">background-color</span>: pink;</span><br><span class="line"><span class="attribute">min-height</span>: <span class="number">80px</span>;</span><br><span class="line"><span class="attribute">text-align</span>: left top; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081638898.png"></p><h5 id="text-decoration"><a href="#text-decoration" class="headerlink" title="text-decoration"></a><strong>text-decoration</strong></h5><p>作用: 给文本添加装饰</p><p>取值:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">none</span>: 没有装饰</span><br><span class="line"></span><br><span class="line">underline: 下划线</span><br><span class="line"></span><br><span class="line">overline: 上划线</span><br><span class="line"></span><br><span class="line">line-through: 删除线</span><br></pre></td></tr></tbody></table></figure><p>举个例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line">    <span class="attribute">font</span>: normal normal <span class="number">30px</span> <span class="string">"微软雅黑"</span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#text_edit_1</span>{</span><br><span class="line"><span class="attribute">text-decoration</span>: none; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#text_edit_2</span>{</span><br><span class="line"><span class="attribute">text-decoration</span>: underline; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#text_edit_3</span>{</span><br><span class="line"><span class="attribute">text-decoration</span>: overline; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#text_edit_4</span>{</span><br><span class="line"><span class="attribute">text-decoration</span>: line-through; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081639340.png"></p><h4 id="padding-和-margin"><a href="#padding-和-margin" class="headerlink" title="padding 和 margin"></a><strong>padding</strong> <strong>和</strong> <strong>margin</strong></h4><p>盒模型中的 padding 和 margin 都可以连写, 也可以单独写, 它们都能完成四个方向上的边距设置, <font color="orange"><code>默认情况下都是 0.</code></font></p><p>与边框和其他连写格式一样, 如果它们连写时, 最多可以指定 4 个值, 最少指定 1 个值,指定 4 个时, 分别表示上右下左方向的边距, 省略时, 也有相同的效果, 即左省略时默认和右一样, 下省略时默认和上一样, 右省略时和上一样.</p><p>设置边距时, 数值后面必须要带像素单位, 即 px;</p><h5 id="padding"><a href="#padding" class="headerlink" title="padding"></a><strong>padding</strong></h5><p>padding 既可以连写也可以分四个方向单独设置,</p><p>格式如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">padding</span>: 上 右 下 左;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"><span class="attribute">padding-top</span>: ?px;</span><br><span class="line"></span><br><span class="line"><span class="attribute">padding-right</span>: ?px;</span><br><span class="line"></span><br><span class="line"><span class="attribute">padding-bottom</span>: ?px;</span><br><span class="line"></span><br><span class="line"><span class="attribute">padding-left</span>: ?px;</span><br></pre></td></tr></tbody></table></figure><h5 id="margin"><a href="#margin" class="headerlink" title="margin"></a><strong>margin</strong></h5><p>格式与 padding 类似, 具体如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">margin</span>: 上 右 下 左; </span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"><span class="attribute">margin</span> -<span class="attribute">top</span>: ?px;</span><br><span class="line"></span><br><span class="line"><span class="attribute">margin</span> -<span class="attribute">right</span>: ?px;</span><br><span class="line"></span><br><span class="line"><span class="attribute">margin</span> -<span class="attribute">bottom</span>: ?px;</span><br><span class="line"></span><br><span class="line"><span class="attribute">margin</span> -<span class="attribute">left</span>: ?px;</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>由于 Qt 将整个盒子看做是一个控件, 因此在布局时, 不会考虑每个盒子的垂直方向的外边距是否有合并现象等, 所以一个控件的外边距只会对自己产生影响, 不会对其他的控件产生影响.</code></font></p><p>下面看一个例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">2px</span> solid red;</span><br><span class="line"><span class="attribute">background</span>: skyblue;</span><br><span class="line"><span class="attribute">background-clip</span>: margin;</span><br><span class="line"><span class="attribute">font</span>: normal normal <span class="number">30px</span> <span class="string">"微软雅黑"</span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#text_edit_1</span>{ </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">5px</span>; </span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>; </span><br><span class="line">    <span class="attribute">text-decoration</span>: none; </span><br><span class="line">} <span class="selector-id">#text_edit_2</span>{ </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>; </span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>; </span><br><span class="line">    <span class="attribute">text-decoration</span>: underline; </span><br><span class="line">} <span class="selector-id">#text_edit_3</span>{ </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">15px</span>; </span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span>; </span><br><span class="line">    <span class="attribute">text-decoration</span>: overline; </span><br><span class="line">} <span class="selector-id">#text_edit_4</span>{ </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>; </span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>; </span><br><span class="line">    <span class="attribute">text-decoration</span>: line-through; </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081644843.png"></p><h4 id="width-与-height"><a href="#width-与-height" class="headerlink" title="width 与 height"></a><strong>width</strong> <strong>与</strong> <strong>height</strong></h4><h5 id="width-height"><a href="#width-height" class="headerlink" title="width, height"></a><strong>width, height</strong></h5><ul><li>这两个属性设置的是<font color="orange"><code>盒子内容</code></font>的宽高.</li><li>这两个属性只对子控件选择器选中的对象有效</li><li>这两个属性的取值均是像素值, 即数字加像素单位 px;</li></ul><h5 id="max-width-min-width-与-max-height-min-height"><a href="#max-width-min-width-与-max-height-min-height" class="headerlink" title="max-width min width 与 max-height min-height"></a><strong>max-width min width</strong> <strong>与</strong> <strong>max-height min-height</strong></h5><ul><li>这四个属性对所有的 widget 都有效, 用来设置盒子内容的最小或最大尺寸</li><li>当最小宽度与最大宽度相等时, 意味着给这个盒子的内容设置了一个固定宽度.</li><li>当最小高度与最大高度相等时, 意味着给这个盒子的内容设置了一个固定高度.</li></ul><p>举个例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QComboBox{ </span><br><span class="line">    <span class="attribute">background-color</span>: skyblue; </span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red; </span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>; </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>; </span><br><span class="line">    <span class="attribute">background-clip</span>: content; </span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">50px</span>; </span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">50px</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081645397.png"></p><p><strong>outline</strong> </p><p>outline （轮廓）是控件有焦点时, 绘制在边框边缘的外围,可起到突出作用,轮廓线不占据控</p><p>件, 也不一定是矩形.</p><p>它有如下属性,</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">outline</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">outline-color</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">outline-offset</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">outline-style</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">outline</span>-radius</span><br><span class="line"></span><br><span class="line"><span class="attribute">outline</span>-<span class="attribute">bottom</span>-<span class="attribute">left</span>-radius</span><br><span class="line"></span><br><span class="line"><span class="attribute">outline</span>-<span class="attribute">bottom</span>-<span class="attribute">right</span>-radius</span><br><span class="line"></span><br><span class="line"><span class="attribute">outline</span>-<span class="attribute">top</span>-<span class="attribute">left</span>-radius</span><br><span class="line"></span><br><span class="line"><span class="attribute">outline</span>-<span class="attribute">top</span>-<span class="attribute">right</span>-radius</span><br></pre></td></tr></tbody></table></figure><p>这里对这些属性不做详细介绍, 只需要知道, 当我们想在一个控件有焦点时, 不绘制轮廓,</p><p>只需要这样做,</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">outline</span>: none;</span><br></pre></td></tr></tbody></table></figure><h3 id="属性结语"><a href="#属性结语" class="headerlink" title="属性结语"></a><strong>属性结语</strong></h3><p>这一小节主要列举了一些常用的属性, 并列举了它们的用法和取值等, 还有其他一些属性并未介绍, 但很可能在开发中需要用到. 这里啰嗦一下, 这种总结性质的东西, 不可能尽善尽美罗列所有, 如果有需要, 还是要去自己查看 Qt 官方给的资料, 查阅文档搜寻有用的知识也是一种很重要的技能.</p><h2 id="Brush-类型介绍"><a href="#Brush-类型介绍" class="headerlink" title="Brush 类型介绍"></a><strong>Brush</strong> <strong>类型介绍</strong></h2><p>brush 一般用来设置颜色, 其取值有 3 种, 分别是 <font color="orange">Color</font>, <font color="orange">Gradient </font>和 <font color="orange">PaletteRole</font>, 下面简单介绍一下</p><h3 id="Color"><a href="#Color" class="headerlink" title="Color"></a><strong>Color</strong></h3><p>color 本身又支持很多格式, 列举所有格式, 如下:</p><ul><li><p>rgb(r, g, b) 每个数字表示每个通道的值, 依次分别是红绿蓝</p></li><li><p>rgba(r, g, b, a) 与 rgb 相同, a 代表 α 通道, 是一个范围 0~1 的浮点数, 表示透明度, 1 代表不透明, 0 表示全透明</p></li><li><p>hsv(h, s, v)</p></li><li><p>hsva(h, s, v, a)</p></li><li><p>#rrggbb: 16 进制表示的 rgb 值, 每个值占两位, 但如果每个通道的两位都一样, 可以简写为</p></li><li><p>#rgb, 如#66FFAA 可以简写为 #6FA, 并且大小写不敏感.</p></li><li><p>name: 常见的表示颜色的单次, 如 red, green, blue, yellow, purple 等</p><p><font color="orange"><code>常用的是 rgb, rgba, #rrggbb, name</code></font></p></li></ul><h3 id="Gradient"><a href="#Gradient" class="headerlink" title="Gradient"></a><strong>Gradient</strong></h3><p>可实现渐变效果,三种取值:</p><ul><li>qlineargradient 线性渐变</li><li>qradialgradient 径向渐变</li><li>qconicalgradient 锥形渐变</li></ul><p>它们分别对应了 Qt 的 3 个类, <font color="orange"><code>QLinearGradient</code></font>, <font color="orange"><code>QRadialGradient</code></font>, <font color="orange"><code>QConicalGradient</code></font>, 参数可以</p><p>参考它们的函数, 这里不多赘述</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{ </span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid red; </span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">qlineargradient</span>(x1:<span class="number">0</span>, y1:<span class="number">0</span>, x2:<span class="number">1</span>, y2:<span class="number">1</span>, stop:<span class="number">0</span> </span><br><span class="line"><span class="number">#ace</span>, stop: <span class="number">0.4</span> <span class="number">#f96</span>, stop:<span class="number">1</span> <span class="number">#ace</span>); </span><br><span class="line">    <span class="attribute">background-clip</span>: margin; </span><br><span class="line">    <span class="attribute">font</span>: normal normal <span class="number">30px</span> <span class="string">"微软雅黑"</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081658453.png"></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{ </span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid red; </span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">qradialgradient</span>(cx:<span class="number">0</span>, cy:<span class="number">0</span>, radius: <span class="number">1</span>, </span><br><span class="line">        fx:<span class="number">0.5</span>, fy:<span class="number">0.5</span>, stop:<span class="number">0</span> <span class="number">#ace</span>, stop:<span class="number">1</span> <span class="number">#f96</span>); </span><br><span class="line">    <span class="attribute">background-clip</span>: margin; </span><br><span class="line">    <span class="attribute">font</span>: normal normal <span class="number">30px</span> <span class="string">"微软雅黑"</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081659550.png"></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{ </span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid red; </span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">qconicalgradient</span>(cx:<span class="number">0.5</span>, cy:<span class="number">0.5</span>, angle:<span class="number">30</span>, </span><br><span class="line">                       stop:<span class="number">0</span> <span class="number">#ace</span>, stop:<span class="number">1</span> <span class="number">#f96</span>); </span><br><span class="line">    <span class="attribute">background-clip</span>: margin; </span><br><span class="line">    <span class="attribute">font</span>: normal normal <span class="number">30px</span> <span class="string">"微软雅黑"</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Qt-官方链接"><a href="#Qt-官方链接" class="headerlink" title="Qt 官方链接"></a><strong>Qt</strong> <strong>官方链接</strong></h3><p>链接地址: <a href="http://doc.qt.io/qt-5/stylesheet.html">http://doc.qt.io/qt-5/stylesheet.html</a></p><p>assistan 搜索方法: 输入 style sheet 即可, 注意两个单词之间有空格, 然后进入</p><p>Qt Style Sheets Reference 专题, 如图:</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081701854.png"></p><h3 id="加载QSS文件方法"><a href="#加载QSS文件方法" class="headerlink" title="加载QSS文件方法"></a>加载QSS文件方法</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可用过qApp对象设置整个程序的qss或者通过this指针设置单前界面的qss</span></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">qApp-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">"file:///:qss/defaultStyle.qss"</span>); <span class="comment">//通过qApp对象设置</span></span><br><span class="line">qApp-&gt;<span class="built_in">setStyleSheet</span>(<span class="built_in">QString</span>(<span class="string">"file:///%1"</span>).<span class="built_in">arg</span>(qssFileName));</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">"file:///:qss/defaultStyle.qss"</span>); <span class="comment">//通过this对象设置当前界面的qss</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setStyleSheet</span>(<span class="built_in">QString</span>(<span class="string">"file:///%1"</span>).<span class="built_in">arg</span>(qssFileName));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">QString qss;  </span><br><span class="line"><span class="function">QFile <span class="title">qssFile</span><span class="params">(<span class="string">":/qss/luffy.qss"</span>)</span></span>;  <span class="comment">//样式表文件</span></span><br><span class="line">qssFile.<span class="built_in">open</span>(QFile::ReadOnly);   </span><br><span class="line"><span class="keyword">if</span> (qssFile.<span class="built_in">isOpen</span>()) {        </span><br><span class="line">    qss = <span class="built_in">QLatin1String</span>(qssFile.<span class="built_in">readAll</span>());       </span><br><span class="line">    qApp-&gt;<span class="built_in">setStyleSheet</span>(qss);       </span><br><span class="line">    qssFile.<span class="built_in">close</span>();  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
          <category> QSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
            <tag> QSS </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU上下文</title>
      <link href="/2022/05/05/CPU%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
      <url>/2022/05/05/CPU%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux 是一个多任务操作系统，它支持远大于 CPU 数量的任务同时运行。当然，这些任务实际上并不是真的在同时运行，而是因为系统在很短的时间内，将 CPU 轮流分配给它们，造成多任务同时运行的错觉。</p><p>而在每个任务运行前，CPU 都需要知道<font color="orange">任务从哪里加载</font>、又<font color="orange">从哪里开始运行</font>，任务执行的<font color="orange">状态</font>和<font color="orange">数据</font>等信息，也就是说，需要系统事先帮它设置好<font color="orange">CPU 寄存器</font>和<font color="orange">程序计数器</font>。</p><h2 id="什么是CPU上下文"><a href="#什么是CPU上下文" class="headerlink" title="什么是CPU上下文"></a>什么是CPU上下文</h2><blockquote><p>CPU 寄存器和程序计数器就是 CPU 上下文，因为它们都是 CPU 在运行任何任务前，必须的依赖环境。</p><ul><li>CPU 寄存器是 CPU 内置的容量小、但速度极快的内存。</li><li>程序计数器则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置</li></ul></blockquote><h2 id="什么是CPU上下文切换"><a href="#什么是CPU上下文切换" class="headerlink" title="什么是CPU上下文切换"></a>什么是CPU上下文切换</h2><blockquote><p>就是先把前一个任务的 CPU 上下文（也就是 CPU寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p><p>而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p></blockquote><h2 id="CPU上下文切换的类型"><a href="#CPU上下文切换的类型" class="headerlink" title="CPU上下文切换的类型"></a>CPU上下文切换的类型</h2><p>根据任务的不同，可以分为以下三种类型 - <font color="red">进程上下文切换</font> - <font color="red">线程上下文切换</font> - <font color="red">中断上下文切换</font></p><h4 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h4><p>Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中， CPU 特权等级的 Ring 0 和 Ring 3。</p><ul><li>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；</li><li>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205051655043.png" alt="image-20220505165129232"></p><p>进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。</p><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><blockquote><p>进程访问内核特定资源时将从用户态转为内核态。从用户态到内核态的转变，需要通过系统调用来完成。比如，当我们查看文件内容时，就需要多次系统调用来完成：首先调用 open()<br>打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件。</p><p>在这个过程中就发生了CPU上下文切换，整个过程是这样的：</p><ol><li>保存 CPU 寄存器里原来用户态的指令位</li><li>为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。</li><li>跳转到内核态运行内核任务。</li><li>当系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程<br>所以，<strong>一次系统调用的过程，其实是发生了两次 CPU 上下文切换</strong>。（<font color="orange">用户态-内核态  内核态-用户态</font>）</li></ol></blockquote><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这跟我们通常所说的进程上下文切换是不一样的：<font color="red"><code>进程上下文切换，是指从一个进程切换到另一个进程运行；而系统调用过程中一直是同一个进程在运行</code></font>.</p><p><font color="orange"><code>所以，系统调用过程通常称为特权模式切换，而不是上下文切换。系统调用属于同进程内的 CPU 上下文切换。但实际上，系统调用过程中，CPU 的上下文切换还是无法避免的。</code></font></p><h4 id="进程上下文切换与系统调用的区别"><a href="#进程上下文切换与系统调用的区别" class="headerlink" title="进程上下文切换与系统调用的区别"></a>进程上下文切换与系统调用的区别</h4><blockquote><p>进程是由内核来管理和调度的，<font color="orange"><code>进程的切换只能发生在内核态</code></font>。所以，<font color="greed"><strong>进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态</strong></font><br>因此，进程的上下文切换就比系统调用时多了一步：<font color="orange"><code>在保存内核态资源（当前进程的内核状态和 CPU 寄存器）之前，需要先把该进程的用户态资源（虚拟内存、栈等）保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</code></font></p></blockquote><p>如下图所示，保存上下文和恢复上下文的过程并不是“免费”的，需要内核在 CPU 上运行才能完成。</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205051707207.png" alt="image-20220505170736442"></p><h4 id="进程上下文切换潜在的性能问题"><a href="#进程上下文切换潜在的性能问题" class="headerlink" title="进程上下文切换潜在的性能问题"></a>进程上下文切换潜在的性能问题</h4><blockquote><p>根据 Tsuna 的测试报告，每次上下文切换都需要几十纳秒到数微秒的 CPU时间。</p><p>这个时间还是相当可观的，特别是在进程上下文切换次数较多的情况下，很容易导致 CPU将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，进而大大缩短了真正运行进程的时间。这也正是导致平均负载升高的一个重要因素。</p><p>另外，我们知道， Linux 通过 TLB（Translation LookasideBuffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB也需要刷新，内存的访问也会随之变慢。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。</p></blockquote><h4 id="发生进程上下文切换的场景"><a href="#发生进程上下文切换的场景" class="headerlink" title="发生进程上下文切换的场景"></a>发生进程上下文切换的场景</h4><blockquote><ol><li>为了保证所有进程可以得到公平调度，CPU时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU的进程运行。</li><li>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。</li><li>当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。</li><li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。</li><li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。</li></ol></blockquote><h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><blockquote><p>线程与进程最大的区别在于：<font color="red"><strong><code>线程是调度的基本单位，而进程则是资源拥有的基本单位</code></strong></font>。说白了，<font color="green">所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。</font></p><p>所以，对于线程和进程，我们可以这么理解： </p><ul><li>当进程只有一个线程时，可以认为进程就等于线程。 </li><li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。 </li><li>另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的</li></ul></blockquote><h4 id="发生线程上下文切换的场景"><a href="#发生线程上下文切换的场景" class="headerlink" title="发生线程上下文切换的场景"></a>发生线程上下文切换的场景</h4><blockquote><ol><li>前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。</li><li>前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据</li></ol></blockquote><h4 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h4><blockquote><p>为了快速响应硬件的事件，**<font color="orange"><code>中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件</code></font>。**而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。</p><p>**<font color="orange"><code>跟进程上下文不同，中断上下文切换并不涉及到进程的用户态</code></font>**。所以，即便中断过程打断了一个正处在用户态的进程，<font color="orange"><code>也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源(中断上下文切换不会覆盖这个进程的虚拟内存、全局变量等用户态资源)。</code></font>中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括CPU 寄存器、内核堆栈、硬件中断参数等。</p><p>**<font color="orange"><code>对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生</code></font>**。同样道理，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。</p><p>另外，跟进程上下文切换一样，中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的<br>CPU，甚至严重降低系统的整体性能。所以，当你发现中断次数过多时，就需要注意去排查它是否会给你的系统带来严重的性能问题。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPU上下文 </tag>
            
            <tag> 多进程hexo </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WindowsXP USB通信</title>
      <link href="/2022/05/05/WindowsXp%E8%BF%9B%E8%A1%8CUSB%E9%80%9A%E8%AE%AF/"/>
      <url>/2022/05/05/WindowsXp%E8%BF%9B%E8%A1%8CUSB%E9%80%9A%E8%AE%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>需要包含的库文件:hid.lib、SetupAPI.lib</p><p>需要包含的头文件:hid.h、SetupAPI.h</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>因为项目需要支持Windows XP系统，项目之前使用的USB通讯方法在windwos xp系统缺少相应的库文件，故选择使用Windows API 来建立USB通讯。</li></ul><h2 id="主要函数解析-可参考windows-API"><a href="#主要函数解析-可参考windows-API" class="headerlink" title="主要函数解析(可参考windows API)"></a>主要函数解析(可参考windows API)</h2><p>创建或打开文件或者I/O设备。</p><p>函数定义如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           LPCSTR                lpFileName,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DWORD                 dwDesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DWORD                 dwShareMode,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DWORD                 dwCreationDisposition,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DWORD                 dwFlagsAndAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] HANDLE                hTemplateFile</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">// 如果函数成功，则返回值是指定文件、设备、命名管道或邮件槽的打开句柄。如果函数失败，则返回值为 INVALID_HANDLE_VALUE。 要获得更多的错误信息，请调用 GetLastError。</span></span><br></pre></td></tr></tbody></table></figure><p>常用参数如下</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HANDLE handle = <span class="built_in">CreateFile</span>(</span><br><span class="line">devDetail-&gt;DevicePath,                 <span class="comment">//设备路径</span></span><br><span class="line">GENERIC_READ | GENERIC_WRITE,          <span class="comment">//访问方式</span></span><br><span class="line">FILE_SHARE_READ | FILE_SHARE_WRITE,    <span class="comment">//共享模式</span></span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">OPEN_EXISTING,                         <span class="comment">//文件不存在时，返回失败</span></span><br><span class="line">FILE_FLAG_OVERLAPPED,                  <span class="comment">//以重叠（异步）模式打开</span></span><br><span class="line"><span class="literal">NULL</span>); </span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意点：</p><ol><li>在这里，CreateFile用于打开HID设备，其中设备路径通过函数SetupDiGetDeviceInterfaceDetail取得。CreateFile有以下几点需要留意：</li><li>访问方式： 假如是系统独占设备，例如鼠标、键盘等等，应将此参数设置为0，否则后续函数操纵将失败（譬如HidD_GetAttributes）；也就是说，不能对独占设备进行除了查询以外的任何操纵，所以能够使用的函数也是很有限的，下文的一些函数并不一定适合这些设备。在此顺便列出MSDN上关于此参数的说明：（ If this parameter is zero, the application can query file and device attributes without accessing the device. This is useful if an application wants to determine the size of a floppy disk drive and the formats it supports without requiring a floppy in the drive. It can also be used to test for the file’s or directory’s existence without opening it for read or write access。)</li><li>重叠（异步）模式：此参数并不会在此处表现出明显的意义，它主要是对后续的WriteFile，ReadFile有影响。假如这里设置为重叠（异步）模式，那么在使用WriteFile，ReadFile时也应该使用重叠（异步）模式，反之亦然。这首先要求WriteFile，ReadFile的最后一个参数不能为空（NULL）。否则，便会返回87（参数错误）错误号。当然，87号错误并不代表就是此参数不正确，更多的信息将在具体讲述这两个函数时指出。此参数为0时，代表同步模式，即WriteFile，ReadFile操纵会在数据处理完成之后才返回，否则阻塞在函数内部.</li></ol></blockquote><hr><p>从指定的文件或输入/输出 (I/O) 设备读取数据。</p><p>函数定义如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ReadFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                HANDLE       hFile,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]               LPVOID       lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                DWORD        nNumberOfBytesToRead,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional]     LPDWORD      lpNumberOfBytesRead,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out, optional] LPOVERLAPPED lpOverlapped</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">// 如果函数成功，则返回值为非零 (TRUE) 。如果函数失败或异步完成，则返回值为零， (FALSE) 。 若要获取扩展的错误信息，请调用 GetLastError 函数。注意GetLastError 代码ERROR_IO_PENDING不是失败;它指定读取操作正在异步等待完成。 </span></span><br></pre></td></tr></tbody></table></figure><p>常用参数如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> bReadResult = <span class="built_in">ReadFile</span>(</span><br><span class="line">hDev,                       <span class="comment">//设备句柄，即CreateFile的返回值</span></span><br><span class="line">recvBuffer,                 <span class="comment">//用于接收数据的buffer</span></span><br><span class="line">IN_REPORT_LEN,              <span class="comment">//要读取数据的长度</span></span><br><span class="line">&amp;recvBytes,                 <span class="comment">//实际收到的数据的字节数</span></span><br><span class="line">&amp;readOverlapped);           <span class="comment">//异步模式 (为NULL表示同步模式)</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意点:</p><ol><li>ReadFile的调用不会引起设备的任何反应，即HID设备与主机之间的中断IN传输不与ReadFile打交道。实际上主机会在最大间隔时间（由设备的端点描述符来指定）内轮询设备，发出中断IN传输的请求。“读取”即意味着从某个buffer里面取回数据，实际上这个buffer就是HID设备驱动中的buffer。这个buffer的大小可以通过HidD_SetNumInputBuffers来改变。在XP上缺省值是32（个报告）。</li><li>读取的数据对象是输进报告，也即通过中断输进管道传进的数据。所以，假如设备不支持中断IN传输，那么是无法使用此函数来得到预期结果的。实际上这种情况不可能在HID中出现，由于协议指明了至少要有一个中断IN端点。</li><li>IN_REPORT_LEN代表要读取的数据的长度（实际的数据正文+一个byte的报告ID），这里是一个常数，主要是由于设备通讯协议决定，按照协议读取多少数据（也就是报告的长度）；不过也可以通过另外的函数（HidD_GetPreparsedData）来事先取得报告的长度，这里不做具体讨论。此参数假如设置过大，不会有实质性的错误，在recvBytes参数中会输出实际读到的长度；假如设置过小，即小于报告的长度，会返回1784号错误（用户提供的buffer无效）。</li><li>关于异步模式。前面已经提过，此参数的设置必须与CreateFile时的设置相对应，否则会返回87号错误（参数错误）。假如不需要异步模式，此参数需置为NULL。在这种情况下，ReadFile会一直等待直到数据读取成功，所以会阻塞住程序确当前过程。</li></ol></blockquote><hr><p>将数据写入指定的文件或输入/输出 (I/O) 设备。</p><p>函数定义如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WriteFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                HANDLE       hFile,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                LPCVOID      lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]                DWORD        nNumberOfBytesToWrite,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional]     LPDWORD      lpNumberOfBytesWritten,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, out, optional] LPOVERLAPPED lpOverlapped</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">// 如果函数成功，则返回值为非零 (TRUE) 。如果函数失败或异步完成，则返回值为零， (FALSE) 。 若要获取扩展的错误信息，请调用 GetLastError 函数。注意GetLastError 代码ERROR_IO_PENDING不是失败;它指定写入操作正在异步完成。 </span></span><br></pre></td></tr></tbody></table></figure><p>常用参数如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> bWriteResult = <span class="built_in">WriteFile</span>(</span><br><span class="line">hDev,                                 <span class="comment">//设备句柄，即CreateFile的返回值</span></span><br><span class="line">reportBuf,                            <span class="comment">//存有待发送数据的buffer</span></span><br><span class="line">OUT_REPORT_LEN,             <span class="comment">//待发送数据的长度</span></span><br><span class="line">&amp;sendBytes,                           <span class="comment">//实际收到的数据的字节数</span></span><br><span class="line">&amp;writeOverlapped);                    <span class="comment">//异步模式 (为NULL表示同步模式)</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意点：</p><ol><li>与ReadFile不同，WriteFile函数被调用后，固然也是经过驱动程序，但是终极会反映到设备中。也就是说，调用WriteFile后，设备会接收到输出报告的请求。假如设备使用了中断OUT传输，则WriteFile会通过中断OUT管道来进行传输；否则会使用SetReport请求通过控制管道来传输。</li><li>OUT_REPORT_LEN代表要写进的数据长度（实际的数据正文+一个byte的报告ID）。硬度计假如大于实际报告的长度，则使用实际报告长度；假如小于实际报告长度，会返回1784号错误（用户提供的buffer无效）。</li><li>reportBuf[0]必须存有待发送报告的ID，并且此报告ID指示的必须是输出报告，否则会返回87号错误（参数错误）。这种情况可能轻易被程序员忽略，结果不知错误号所反映的是什么，网上也经常有类似疑问的帖子。顺便指出，输进报告、输进报告、特征报告这些报告类型，是反映在HID设备的报告描述符中。后文将做举例讨论。</li><li>关于异步模式。前面已经提过，此参数的设置必须与CreateFile时的设置相对应，否则会返回87号错误（参数错误）。假如不需要异步模式，此参数需置为NULL。在这种情况下，WriteFile会一直等待直到数据读取成功，所以会阻塞住程序确当前过程。</li></ol></blockquote><hr><p>参考：</p><p><a href="https://blog.csdn.net/phenixyf/article/details/39929033">(70条消息) HID ReadFile()使用_Phenixyf的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/kemawcz/article/details/50704978">(70条消息) 关于GetOverlappedResult函数的一些知识_kemaWCZ的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> usb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WindowsXP </tag>
            
            <tag> I/O设备 </tag>
            
            <tag> usb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回调函数</title>
      <link href="/2022/05/05/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
      <url>/2022/05/05/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><font color="orange"><code>回调函数</code></font>就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p><h3 id="基于C语言的回调函数来实现一个回调的过程"><a href="#基于C语言的回调函数来实现一个回调的过程" class="headerlink" title="基于Ｃ语言的回调函数来实现一个回调的过程"></a>基于Ｃ语言的回调函数来实现一个回调的过程</h3><h4 id="回调函数机制："><a href="#回调函数机制：" class="headerlink" title="回调函数机制："></a>回调函数机制：</h4><p>1、定义一个函数（普通函数即可）；<br>2、将此函数的地址注册给调用者；<br>3、特定的事件或条件发生时，调用者使用函数指针调用回调函数。</p><h4 id="回调函数的参数传递"><a href="#回调函数的参数传递" class="headerlink" title="回调函数的参数传递"></a>回调函数的参数传递</h4><p>回调函数的参数定义和普通函数是一致的（回调函数一般就是普通函数）。</p><p><font color="red"><code>一般而言回调函数的参数通过调用该回调函数（调用者）的参数传入</code></font>。</p><ol><li><p>参数通过<font color="orange"><code>调用者</code></font>传递</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*callback)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, intc, callback p)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> (*p)(a,b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *args[])</span></span>{</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">Add</span>(<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，可以看到，我们定义了一个callbak的函数指针，参数为两个int，返回值为int，通过调用函数地址来进行简单的相加运算。<font color="orange"><code>回调函数add中的参数是通过调用者Add传递的（Add的前两个参数都是为回调函数add服务的，当然调用者Add可以有不用为回调函数add传递参数的有实际作用的其他参数，本例中的c）</code></font></p></li><li><p>参数由<font color="orange"><code>调用者</code></font>内部定义</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*callback)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(callback p)</span></span>{</span><br><span class="line">    <span class="type">int</span> a{<span class="number">5</span>}, b{<span class="number">6</span>};</span><br><span class="line">    <span class="keyword">return</span> (*p)(a,b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *args[])</span></span>{</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">Add</span>(add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，可以看到，我们定义了一个callbak的函数指针，参数为两个int，返回值为int，通过调用函数地址来进行简单的相加运算。<font color="orange"><code>回调函数add中的参数是用者Add内部定义的，没有通过形参从外部获取。</code></font></p></li><li><p>回调函数的输出参数</p><p>前面两个示例都是输入参数，<font color="orange"><code>回调函数当然也可以有输出参数来返回调用者需要的信息</code></font>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*callback)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">addInfo</span>{</span><br><span class="line">    <span class="type">int</span> add1;</span><br><span class="line">    <span class="type">int</span> add2;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, callback p)</span></span>{</span><br><span class="line">    <span class="comment">//定义一个对象作为输出参数</span></span><br><span class="line">    addInfo info;</span><br><span class="line">    <span class="comment">//通过回调函数获取需要的输出信息</span></span><br><span class="line">    (*p)(a, b, info);</span><br><span class="line">    <span class="comment">//使用回去的输出参数内容</span></span><br><span class="line">    <span class="keyword">return</span> info.sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">info <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b, addInfo&amp; info)</span></span>{</span><br><span class="line">    info.add1 = a;</span><br><span class="line">    info.add2 = b;</span><br><span class="line">    info.sum = a + b;</span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *args[])</span></span>{</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">Add</span>(<span class="number">4</span>, <span class="number">2</span>, add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，可以看到，我们定义了一个callbak的函数指针，参数为两个int，返回值为int，通过调用函数地址来进行简单的相加运算。<font color="orange"><code>回调函数add中的参数既有输入参数也有输出给调用者Add的输出参数。</code></font></p></li></ol><h3 id="基于C＋＋面向对象过程的代码"><a href="#基于C＋＋面向对象过程的代码" class="headerlink" title="基于Ｃ＋＋面向对象过程的代码"></a>基于Ｃ＋＋面向对象过程的代码</h3><p>举个例子：</p><p>　财务处是负责对公司财务状况和每个月的开销进行汇总，老板只会去看每个月的报表。</p><p>​那么在这个当中，老板不会去关心，财务整个汇总的过程，他只会去关心结果，那么，如果从面向对象的方法去理解的话，老板是一个对象．财务部是一个对象，当老板想看报表的时候，会跟财务打个招呼，等财务部汇总完了．然后将报表再去提交给老板，那么问题来了，而两个类之间实现通信的就是接口回调，从财务类的中，将结果回调到对象中．<font color="green"><strong><code>这种实现是通过接口自动完成的</code></strong></font><br>　<br>　如果用Ｃ语言的面向过程去理解的话，那么老板想看报表可以理解为一个函数，而财务处计算过程可以看成一个回调函数，如果老板想看报表的话，可以直接通过财务处回调函数的返回结果来查看．这中主要是依赖于函数指针的形式来实现。</p><hr><p>为了对比先基于C实现回调</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> *财务的统计状况函数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">finance_result</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> *老板想看财务报表</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">boss_read_finance</span><span class="params">(<span class="type">int</span> *array,<span class="type">int</span> n,<span class="type">int</span> (*fp)(<span class="type">int</span>*,<span class="type">int</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span>{</span><br><span class="line">  <span class="comment">//定义一个数组数据</span></span><br><span class="line">  <span class="type">int</span> array[<span class="number">10</span>] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>};</span><br><span class="line">  <span class="comment">//因为Ｃ语言中函数名也是地址，因此对于形参数是函数指针的话，这个时候直接将地址传进去就可以了；</span></span><br><span class="line">  <span class="comment">//注意：函数指针是指向函数的地址,对于fp是地址，那么调用的时候固然需要(*fp)</span></span><br><span class="line">  <span class="comment">//也可以这样写：</span></span><br><span class="line">  <span class="comment">//int (*fp)(int *a,int n);</span></span><br><span class="line">  <span class="comment">//fp = finance_result;</span></span><br><span class="line">  <span class="comment">//boss_read_finance(array,10,finance_result);</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">boss_read_finance</span>(array,<span class="number">10</span>,finance_result);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> *老板查看财务状况的实现，参数中有一个函数指针，</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">boss_read_finance</span><span class="params">(<span class="type">int</span>* array,<span class="type">int</span> n,<span class="type">int</span> (*fp)(<span class="type">int</span>* a,<span class="type">int</span> n))</span></span>{</span><br><span class="line">  <span class="comment">//对于老板来说，他是不需要去了解财务部的具体实现的过程，只要结果就行了</span></span><br><span class="line">  <span class="comment">//这就有助于我们对函数封装</span></span><br><span class="line">  <span class="type">int</span> result = (*fp)(array,n);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"caculate result:%d\n"</span>,result);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* **</span></span><br><span class="line"><span class="comment"> *财务计算报表的具体实现</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">finance_result</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span> n)</span></span>{</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i =  <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++){</span><br><span class="line">    result += *(a+i);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>基于C++面相对象实现代码</p><p>finance.h</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __FINANCE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FINANCE_H__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> zzf{</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::std;</span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> *定义一个ｃａｌｌｂａｃｋ的接口</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallBack</span>{</span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setFinanceResult</span><span class="params">(<span class="type">int</span> result)</span>  <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> *财务：</span></span><br><span class="line"><span class="comment"> 专门用于计算结果的</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Finance</span>{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Finance</span>(CallBack* mCallBack2):<span class="built_in">mCallBack</span>(mCallBack2){</span><br><span class="line">      cout &lt;&lt; <span class="string">"finance constructor"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">Finance</span>(){</span><br><span class="line">      cout &lt;&lt; <span class="string">"finance destructor"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">caculateFinance</span><span class="params">(<span class="type">int</span> * a,<span class="type">int</span> n)</span></span>{</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ;i &lt; n;i++){</span><br><span class="line">      result += *(a + i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(mCallBack != <span class="literal">NULL</span>){</span><br><span class="line">      cout &lt;&lt;<span class="string">"result:"</span>&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">       mCallBack-&gt;<span class="built_in">setFinanceResult</span>(result);</span><br><span class="line">    }</span><br><span class="line">  }  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">     CallBack* mCallBack;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> *老板，实现接口ｃａｌｌｂａｃｋ</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boss</span>:<span class="keyword">public</span> CallBack{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">Boss</span>(){</span><br><span class="line">       <span class="comment">//将接口实例化后，传递给Ｆｉｎａｎｃｅ</span></span><br><span class="line">       mFinace = <span class="keyword">new</span> <span class="built_in">Finance</span>(<span class="keyword">this</span>);</span><br><span class="line">      cout &lt;&lt; <span class="string">"boss constructor"</span> &lt;&lt; endl;</span><br><span class="line">     }</span><br><span class="line">     ~<span class="built_in">Boss</span>(){</span><br><span class="line">       <span class="keyword">delete</span> mFinace;</span><br><span class="line">       cout &lt;&lt; <span class="string">"boss destructor"</span> &lt;&lt; endl;</span><br><span class="line">     }</span><br><span class="line">     <span class="comment">//查看财务的函数</span></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">readFianace</span><span class="params">(<span class="type">int</span> *array ,<span class="type">int</span> n)</span></span>{</span><br><span class="line">       cout &lt;&lt; <span class="string">"boss readFianace"</span>&lt;&lt; endl;</span><br><span class="line">       mFinace -&gt; <span class="built_in">caculateFinance</span>(array,n);</span><br><span class="line">     }</span><br><span class="line">    <span class="comment">//实现后的回调函数，这个函数就是用来接收回调的值的</span></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">setFinanceResult</span><span class="params">(<span class="type">int</span> result)</span> <span class="type">const</span></span>{</span><br><span class="line">       cout &lt;&lt; <span class="string">"caculate result:"</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">     }</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">     Finance *mFinace;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>finance.cpp</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;finance.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::zzf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv [])</span></span>{</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> array[<span class="number">10</span>] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>};</span><br><span class="line"></span><br><span class="line">  Boss boss;</span><br><span class="line"></span><br><span class="line">  boss.<span class="built_in">readFianace</span>(array,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>其实这个案例能够让我们对回调有更加深刻的认识：</p><ol><li>老板想查看财务(调用自己函数,函数在ｂｏｓｓ内)</li><li>通知财务，我要查看报表(进行计算的过程，函数在ｆｉｎａｎｃｅ内部)</li><li>财务算好之后，返回给老板(回调的函数在ｂｏｓｓ内部)也就是回调就是把不需要自己处理的东西放到别的类去，然后等其处理完毕之后，再返回给调用的类．</li></ol><h4 id="面向对象回调函数机制"><a href="#面向对象回调函数机制" class="headerlink" title="面向对象回调函数机制"></a>面向对象回调函数机制</h4><ol><li>定义一个回调接口</li><li>定义一个调用类，继承接口类去实现这个接口，重写方法</li><li>被调用者(任务具体实现类)将接口做为参数传递进去，并且在某个时刻进行出发</li><li>调用者在调用的时候去实例化这个回调接口(如上述案例中因为已经实现了接口，所以将类本身对应的对象作为参数传递进去)</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 回调函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数指针</title>
      <link href="/2022/05/05/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
      <url>/2022/05/05/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h3 id="指向函数的指针–函数指针"><a href="#指向函数的指针–函数指针" class="headerlink" title="指向函数的指针–函数指针"></a>指向函数的指针–函数指针</h3><p> 函数具有可赋值给指针的物理内存地址，一个函数的<font color="orange"><code>函数名</code></font>就是一个指针，它指向函数的代码。<font color="orange"><code>一个函数的地址是该函数的进入点，也是调用函数的地址</code></font>。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数。</p><blockquote><p>不带括号和变量列表的函数名，这可以表示函数的地址，正如不带下标的数组名可以表示数组的首地址。</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">定义形式：</span><br><span class="line">类型 （*指针变量名）（参数列表）；</span><br><span class="line">例如：</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> i + j;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">int</span> (*p)(<span class="type">int</span> i,<span class="type">int</span> j);</span><br><span class="line">p = add; <span class="comment">// p = &amp;add;</span></span><br><span class="line"></span><br><span class="line">使用<span class="keyword">typedef</span>定义函数指针类型别名：</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*funPtr)</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>; <span class="comment">//定义别名</span></span><br><span class="line">funPtr p; <span class="comment">//实例函数指针对象</span></span><br><span class="line">p = add;</span><br><span class="line">使用<span class="keyword">using</span>定义函数指针类型别名：</span><br><span class="line">    <span class="keyword">using</span> funPtr = <span class="built_in">int</span> (*)(<span class="type">int</span> i, <span class="type">int</span> j); <span class="comment">//定义别名</span></span><br><span class="line">funPtr p; <span class="comment">//实例函数指针对象</span></span><br><span class="line">p = add;</span><br><span class="line"><span class="comment">//3个p是同一个类型变量</span></span><br><span class="line"><span class="built_in">p</span>(<span class="number">5</span> , <span class="number">6</span>); <span class="comment">//通过函数指针调用函数</span></span><br></pre></td></tr></tbody></table></figure><p> p是一个指针，它指向一个函数，该函数有2个整形参数，返回类型为int。p首先和*结合，表明p是一个指针。然后再与（）结合，表明它指向的是一个函数。指向函数的指针也称为函数指针。</p><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GET_MAX 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GET_MIN 1</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_max</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> i&gt;j?i:j;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_min</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> i&gt;j?j:i;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//这里定义了一个函数指针，就可以根据传入的flag，灵活地决定其是指向求大数或求小数的函数</span></span><br><span class="line"><span class="comment">//便于方便灵活地调用各类函数</span></span><br><span class="line"><span class="built_in">int</span> (*p)(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(flag == GET_MAX)</span><br><span class="line">p = get_max;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p = get_min;</span><br><span class="line"> </span><br><span class="line">ret = <span class="built_in">p</span>(i,j);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> i = <span class="number">5</span>,j = <span class="number">10</span>,ret;</span><br><span class="line"> </span><br><span class="line">ret = <span class="built_in">compare</span>(i,j,GET_MAX);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The MAX is %d\n"</span>,ret);</span><br><span class="line"> </span><br><span class="line">ret = <span class="built_in">compare</span>(i,j,GET_MIN);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The MIN is %d\n"</span>,ret);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">char</span> *a,<span class="type">char</span> *b,<span class="type">int</span> (*cmp)(<span class="type">const</span> <span class="type">char</span> *,<span class="type">const</span> <span class="type">char</span> *))</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> s1[<span class="number">80</span>],s2[<span class="number">80</span>];</span><br><span class="line">    <span class="built_in">int</span> (*p)(<span class="type">const</span> <span class="type">char</span> *,<span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将库函数strcmp的地址赋值给函数指针p</span></span><br><span class="line">    p=strcmp;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter two strings.\n"</span>);</span><br><span class="line">    <span class="built_in">gets</span>(s1);</span><br><span class="line">    <span class="built_in">gets</span>(s2);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">check</span>(s1,s2,p);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">char</span> *a,<span class="type">char</span> *b,<span class="type">int</span> (*cmp)(<span class="type">const</span> <span class="type">char</span> *,<span class="type">const</span> <span class="type">char</span> *))</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Testing for equality.\n"</span>);</span><br><span class="line"><span class="comment">//表达式(*cmp)(a,b)调用strcmp，由cmp指向库函数strcmp()，由a和b作调用strcmp()的参数。</span></span><br><span class="line"><span class="comment">//调用时，与声明的情况类似，必须在*cmp周围使用一对括号，使编译程序正确操作，</span></span><br><span class="line"><span class="comment">//同时这也是一种良好的编码风格，指示函数是通过指针调用的，而不是函数名。</span></span><br><span class="line">    <span class="keyword">if</span>((*cmp)(a,b)==<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Equal\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not Equal\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//check()函数的第3个函数是函数指针，就可以根据具体情况传入不同的处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">char</span> *a,<span class="type">char</span> *b,<span class="type">int</span> (*cmp)(<span class="type">const</span> <span class="type">char</span> *,<span class="type">const</span> <span class="type">char</span> *))</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//自定义的比较两个字符串的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compvalues</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a,<span class="type">const</span> <span class="type">char</span> *b)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> s1[<span class="number">80</span>],s2[<span class="number">80</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter two values or two strings.\n"</span>);</span><br><span class="line">    <span class="built_in">gets</span>(s1);</span><br><span class="line">    <span class="built_in">gets</span>(s2);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//如果是数字，则用函数指针传入数字比较函数进行处理</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isdigit</span>(*s1)){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Testing values for equality.\n"</span>);</span><br><span class="line">        <span class="built_in">check</span>(s1,s2,compvalues);</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//如果是字符串，则用函数指针传入库函数strcmp进行处理</span></span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Testing strings for equality.\n"</span>);</span><br><span class="line">        <span class="built_in">check</span>(s1,s2,strcmp);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">char</span> *a,<span class="type">char</span> *b,<span class="type">int</span> (*cmp)(<span class="type">const</span> <span class="type">char</span> *,<span class="type">const</span> <span class="type">char</span> *))</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>((*cmp)(a,b)==<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Equal.\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not Equal.\n"</span>);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compvalues</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a,<span class="type">const</span> <span class="type">char</span> *b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">atoi</span>(a)==<span class="built_in">atoi</span>(b))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意：</p><p>函数指针本质是一个指针可以执行解引用操作。函数指针多用于回调使用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态库常用关键字</title>
      <link href="/2022/05/05/%E5%8A%A8%E6%80%81%E5%BA%93%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2022/05/05/%E5%8A%A8%E6%80%81%E5%BA%93%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="declspec-dllexport-与-declspec-dllimport"><a href="#declspec-dllexport-与-declspec-dllimport" class="headerlink" title="__declspec(dllexport)与__declspec(dllimport)"></a>__declspec(dllexport)与__declspec(dllimport)</h3><p>__declspec是Microsoft VC中专用的关键字，它配合着一些属性可以对标准C/C++进行扩充。__declspec关键字应该出现在声明的前面。</p><p>__declspec(dllexport)用于Windows中的动态库中，声明导出函数、类、对象等供外面调用，省略给出.def文件。即将函数、类等声明为导出函数，供其它程序调用，作为动态库的对外接口函数、类等。</p><p>.def文件(模块定义文件)是包含一个或多个描述各种DLL属性的Module语句的文本文件。.def文件或__declspec(dllexport)都是将公共符号导入到应用程序或从DLL导出函数。如果不提供__declspec(dllexport)导出DLL函数，则DLL需要提供.def文件。</p><p>__declspec(dllimport)用于Windows中，从别的动态库中声明导入函数、类、对象等供本动态库或exe文件使用。当你需要使用DLL中的函数时，往往不需要显示地导入函数，编译器可自动完成。不使用__declspec(dllimport)也能正确编译代码，但使用__declspec(dllimport)使编译器可以生成更好的代码。编译器之所以能够生成更好的代码，是因为它可以确定函数是否存在于DLL中，这使得编译器可以生成跳过间接寻址级别的代码，而这些代码通常会出现在跨DLL边界的函数调用中。声明一个导入函数，是说这个函数是从别的DLL导入。一般用于使用某个DLL的exe中。</p><p>他们都是DLL内的关键字，即<font color="orange"><code>导出</code></font>与<font color="orange"><code>导入</code></font>。他们是将DLL内部的类与函数以及数据导出与导入时使用的。</p><p> <font color="orange"><code>dllexport</code></font>是在这些类、函数以及数据的<font color="orange"><code>申明</code></font>的时候使用。用他表明这些东西可以被外部函数使用，<font color="red"><code>即（dllexport）是把 DLL中的相关代码（类，函数，数据）暴露出来为其他应用程序使用。</code></font><font color="red"><code>使用了（dllexport）关</code>键字，相当于声明了紧接在（dllexport）关键字后面的相关内容是可以为其他程序使用的</font>。</p><p> <font color="orange"><code>dllimport</code></font>是在<font color="orange"><code>外部程序</code></font>需要使用DLL内相关内容时使用的关键字。当一个外部程序要使用DLL 内部代码（类，函数，全局变量）时，只需要在程序内部使用（dllimport）关键字声明需要使用的代码就可以了，<font color="red"><code>即（dllimport）关键字是在外部程序需要使用DLL内部相关内容的时候才使用。（dllimport）作用是把DLL中的相关代码插入到应用程序中。</code></font></p><p> __declspec(dllexport)与__declspec(dllimport)是相互呼应，只有在DLL内部用dllexport作了声明，才能在外部函数中用dllimport导入相关代码。</p><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><p>  在为方便使用，我们经常在代码中定义宏<font color="orange"><code>DLL_EXPORT</code></font>，此宏用在需要导出的类和函数前，而此宏我们定义如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DLL_EXPORTS </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIMPLE_CLASS_EXPORT __declspec(dllexport) </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIMPLE_CLASS_EXPORT __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>作为动态库，在需要导出的类或函数前必须使用关键字<font color="orange">__declspec(dllexport)</font>声明，因此动态库需要定义宏<font color="orange">DLL_EXPORTS</font>(使用Vistualstudio建立动态库工程时，此宏已经定义好)。</p><p>  应用程序需要使用关键字<font color="orange">__declspec(dllimport)</font>，因此不能定义宏<font color="orange">DLL_EXPORTS</font>。</p><h3 id="可以省略dllimport"><a href="#可以省略dllimport" class="headerlink" title="可以省略dllimport???"></a>可以省略dllimport???</h3><p> 但MSDN文档里面，对于 __declspec(dllimport)的说明让人感觉有点奇怪，先来看看MSDN里面是怎么说的：</p><p>​     不使用 __declspec(dllimport)也能正确编译代码，但使用 __declspec(dllimport) 使编译器可以生成更好的代码。编译器之所以能够生成更好的代码，是因为它可以确定函数是否存在于 DLL 中，这使得编译器可以生成跳过间接寻址级别的代码，而这些代码通常会出现在跨DLL 边界的函数调用中。但是，必须使用 __declspec(dllimport) 才能导入 DLL 中使用的变量。</p><p>   使用__declspec(dllimport)可以生成更好的代码，这点好理解，但必须使用它才能导出dll中的变量，真的是如此吗？那我们就来测试一下:</p><p>   建立动态库，由SimpleClass.h和SimpleClass.cpp组成，SimpleClass.h的代码实现如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//file  SimpleClass.h</span><br><span class="line">#ifndef _SIMPLE_CLASS_H_</span><br><span class="line">#define _SIMPLE_CLASS_H_</span><br><span class="line"> </span><br><span class="line">#ifdef DLL_EXPORTS</span><br><span class="line">    #define SIMPLE_CLASS_EXPORT__declspec(dllexport)</span><br><span class="line">#else</span><br><span class="line">    #define SIMPLE_CLASS_EXPORT</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">extern int SIMPLE_CLASS_EXPORT g_Vaule; //全局变量</span><br><span class="line"> </span><br><span class="line">class SIMPLE_CLASS_EXPORT CSimpleClass</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">    CSimpleClass(void);</span><br><span class="line">    ~CSimpleClass(void);</span><br><span class="line">     int GetVale(void)const;</span><br><span class="line">};</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure><p>SimpleClass.cpp代码实现如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleClass.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"SimpleClass.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> g_Vaule = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">CSimpleClass::<span class="built_in">CSimpleClass</span>(<span class="type">void</span>)</span><br><span class="line">    :<span class="built_in">m_iValue</span>(<span class="number">100</span>)</span><br><span class="line">{}</span><br><span class="line">CSimpleClass::~<span class="built_in">CSimpleClass</span>(<span class="type">void</span>)</span><br><span class="line">{}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CSimpleClass::GetVale</span><span class="params">(<span class="type">void</span>)</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> g_Vaule;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果应用程序中不直接使用g_Vaule，能顺利编译通过，且调用函数GetVale能正确返回100.</p><p>  但如果在应用程序中直接使用g_Vaule,编译错误提示如下：</p><p>1&gt;main.obj : error LNK2001: unresolvedexternal symbol “int g_Vaule” (?g_Vaule@@3HA) </p><hr><p>如果将SimpleClass.h中的宏定义修改为下面值，成功编译：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DLL_EXPORTS</span></span><br><span class="line">      <span class="meta">#<span class="keyword">define</span> SIMPLE_CLASS_EXPORT __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="meta">#<span class="keyword">define</span> SIMPLE_CLASS_EXPORT __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><font color="orange"><strong>总结如下：对于动态库本身必须使用关键字__declspec(dllexport)，对于应用程序，如果不使用动态库导出的变量，不使用关键字__declspec(dllimport)也可以保证动态库的正常使用，但实际使用中，还是建议应用程序使用关键字__declspec(dllimport)，具体原因，还是上面MSDN的那段话。</strong></font></p></blockquote><h3 id="动态库与静态库并存"><a href="#动态库与静态库并存" class="headerlink" title="动态库与静态库并存"></a>动态库与静态库并存</h3><p>另外，有时我们的程序需要同时提供动态库和静态库库，且都使用一个头文件，为了解决关键字的使用冲突，建议使用如下的宏定义：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifdefined DLL_EXPORTS</span></span><br><span class="line">    <span class="meta">#ifdefined INSIDE_DLL</span></span><br><span class="line">         <span class="meta">#<span class="keyword">define</span> SIMPLE_CLASS_EXPORT__declspec(dllexport)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> SIMPLE_CLASS_EXPORT__declspec(dllimport)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="meta">#<span class="keyword">define</span> SIMPLE_CLASS_EXPORT</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>对于动态库本身，需要定义宏DLL_EXPORTS和INSIDE_DLL 使用动态库的应用程序定义宏DLL_EXPORTS</p><p>对于静态库，不需要定义DLL_EXPORTS，当然静态库的应用程序也不需要定义。</p><p>如此定义，就可以让动态库和静态库的导出都使用同一份头文件。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下是测试代码：新建一个动态库工程Library，然后在CppBaseTest工程中调用Library的接口：</p><p>library.hpp：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// library.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FBC_LIBRARY_LIBRARY_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FBC_LIBRARY_LIBRARY_HPP_</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// reference: http://geoffair.net/ms/declspec.htm</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> FBC_STATIC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FBC_API</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined FBC_EXPORT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FBC_API __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FBC_API __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">FBC_API <span class="type">int</span> <span class="title">library_add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line">FBC_API <span class="type">int</span> value;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FBC_API</span> Simple {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Simple</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(T a, T b)</span></span>;</span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T a, b;</span><br><span class="line">};</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// FBC_LIBRARY_LIBRARY_HPP_</span></span></span><br></pre></td></tr></tbody></table></figure><p>library.cpp:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"library.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">FBC_API <span class="type">int</span> <span class="title">library_add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">value = <span class="number">11</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">"File: %s, Function: %s, Line: %d\n"</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"><span class="keyword">return</span> (a+b);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Simple&lt;T&gt;::<span class="built_in">Init</span>(T a, T b)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T Simple&lt;T&gt;::<span class="built_in">Add</span>() <span class="type">const</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">"File: %s, Function: %s, Line: %d\n"</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"><span class="keyword">return</span> (a + b);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Simple</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Simple</span>&lt;std::string&gt;;</span><br></pre></td></tr></tbody></table></figure><p>test_library.hpp:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FBC_CPPBASE_TEST_TEST_LIBRARY_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FBC_CPPBASE_TEST_TEST_LIBRARY_HPP_</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;library.hpp&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> test_library_ {</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">__declspec(dllimport) <span class="function"><span class="type">int</span> <span class="title">library_add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>; <span class="comment">//应用程序中使用dll中的方法可变量</span></span><br><span class="line">__declspec(dllimport) <span class="type">int</span> value;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_library_1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_library_2</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">} <span class="comment">// namespace test_library_</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// FBC_CPPBASE_TEST_TEST_LIBRARY_HPP_</span></span></span><br></pre></td></tr></tbody></table></figure><p>test_library.cpp:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"test_library.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;library.hpp&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> test_library_ {</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_library_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> a{ <span class="number">4</span> }, b{ <span class="number">5</span> }, c{ <span class="number">0</span> };</span><br><span class="line"> </span><br><span class="line">c = <span class="built_in">library_add</span>(a, b);</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">"%d + %d = %d\n"</span>, a, b, c);</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">"value: %d\n"</span>, value);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_library_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Simple&lt;<span class="type">int</span>&gt; simple1;</span><br><span class="line"><span class="type">int</span> a{ <span class="number">4</span> }, b{ <span class="number">5</span> }, c{ <span class="number">0</span> };</span><br><span class="line"> </span><br><span class="line">simple1.<span class="built_in">Init</span>(a, b);</span><br><span class="line">c = simple1.<span class="built_in">Add</span>();</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">"%d + %d = %d\n"</span>, a, b, c);</span><br><span class="line"> </span><br><span class="line">Simple&lt;std::string&gt; simple2;</span><br><span class="line">std::string str1{ <span class="string">"csdn blog: "</span> }, str2{ <span class="string">"http://blog.csdn.net/fengbingchun"</span> }, str3;</span><br><span class="line"> </span><br><span class="line">simple2.<span class="built_in">Init</span>(str1, str2);</span><br><span class="line">str3 = simple2.<span class="built_in">Add</span>();</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">"contents: %s\n"</span>, str3.<span class="built_in">c_str</span>());</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">} <span class="comment">// namespace test_library_</span></span><br></pre></td></tr></tbody></table></figure><h3 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MVYQZ_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MVYQZ_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MV_EXP_API __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WINAPI __stdcall</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MV_EXP_API _EXPORTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MV_EXP_API __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">//MV_EXP_API</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MV_EXP_API __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//MV_EXP_API</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// _MSC_VER</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WINAPI</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MV_EXP_API</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _MSC_VER</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">IrisInfo</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> x1; </span><br><span class="line"><span class="type">int</span> y1;</span><br><span class="line"><span class="type">int</span> width1;</span><br><span class="line"><span class="type">int</span> height1;</span><br><span class="line"><span class="type">int</span> integrity1; <span class="comment">//完整度</span></span><br><span class="line"><span class="type">int</span>brightness1; <span class="comment">//亮度</span></span><br><span class="line"><span class="type">int</span>clarity1;<span class="comment">//清晰度</span></span><br><span class="line"><span class="type">int</span>gray_rate1; <span class="comment">//灰度比</span></span><br><span class="line"><span class="type">int</span>avg_score1; <span class="comment">//平均分数</span></span><br><span class="line">std::vector&lt;<span class="type">float</span>&gt; vec1;</span><br><span class="line"><span class="type">int</span> x2;</span><br><span class="line"><span class="type">int</span> y2;</span><br><span class="line"><span class="type">int</span> width2;</span><br><span class="line"><span class="type">int</span> height2;</span><br><span class="line"><span class="type">int</span> integrity2;</span><br><span class="line"><span class="type">int</span>brightness2;</span><br><span class="line"><span class="type">int</span>clarity2;</span><br><span class="line"><span class="type">int</span>gray_rate2;</span><br><span class="line"><span class="type">int</span>avg_score2;</span><br><span class="line">std::vector&lt;<span class="type">float</span>&gt; vec2;</span><br><span class="line">}IrisInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*功能：初始化模型</span></span><br><span class="line"><span class="comment">*参数modelPath：模型文件的文件夹路径</span></span><br><span class="line"><span class="comment">*返回值：1 -- 成功， 0 -- 失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">MV_EXP_API <span class="type">int</span>  __stdcall <span class="title">Init</span><span class="params">(<span class="type">char</span>* modelPath)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*功能：反初始化</span></span><br><span class="line"><span class="comment">*参数</span></span><br><span class="line"><span class="comment">*返回值：1 -- 成功， 0 -- 失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">MV_EXP_API <span class="type">int</span>  __stdcall <span class="title">UnInit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*CallbackFun 指向函数的指针类型</span></span><br><span class="line"><span class="comment">*info        回调参数，IrisInfo结构体</span></span><br><span class="line"><span class="comment">*contex      回调上下文，在C中一般传入nullptr，在C++中可传入对象指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*CallbackFun)</span><span class="params">(IrisInfo info, <span class="type">void</span>* contex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*功能：计算虹膜分数</span></span><br><span class="line"><span class="comment">*参数imgData：图片的char*类型</span></span><br><span class="line"><span class="comment">*参数length：图片转成char*长度</span></span><br><span class="line"><span class="comment">*参数IrisData：返回两只眼睛信息的回调函数</span></span><br><span class="line"><span class="comment">*返回值：0 -- 两只眼睛的检测结果，-1 -- 图片为空</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">MV_EXP_API <span class="type">int</span> __stdcall <span class="title">EvaluateScore</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* imgData, <span class="type">int</span> length, CallbackFun IrisData, <span class="type">void</span>* contex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">MV_EXP_API <span class="type">float</span> __stdcall <span class="title">SimilarityScore</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">float</span>&gt;&amp; vec1, <span class="type">const</span> std::vector&lt;<span class="type">float</span>&gt;&amp; vec2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*功能：控制灯</span></span><br><span class="line"><span class="comment">*参数nMode：1 开  0 是关</span></span><br><span class="line"><span class="comment">*返回值1 -- 成功， 0 -- 失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">MV_EXP_API <span class="type">int</span> __stdcall <span class="title">LightControl</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> nMode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 动态库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 动态库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类型转换</title>
      <link href="/2022/05/05/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2022/05/05/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>最近在看公司其他同事写的代码时频繁出现<font color="orange"><code>reinterpret_cast</code></font>关键字，只知道是关于类型转换的，细节方面不是很清楚，所有花了点时间整理C++中的类型转换知识。</p><hr><p>C/C++是强类型语言,不同类型之间的相互转换是比较麻烦的.但是在编程实践中,不可避免的要用到类型转换.有2种类型转换:<font color="orange">隐式类型转换</font>和<font color="orange">强制类型转换</font>。</p><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><ol><li><font color="red"><code>提升精度</code></font>，此种是编译器<font color="orange">自动完成的,安全的</font>.所以编译的时候不会有任何错误或者警告信息提示。</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例: &lt;&lt;C++ <span class="built_in">Primer</span> (第三版)&gt;&gt; P147</span><br><span class="line"><span class="type">int</span> ival = <span class="number">3</span>;</span><br><span class="line"><span class="type">double</span> dval = <span class="number">3.14159</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ival 被提升为 double 类型: 3.0</span></span><br><span class="line">ival + dval;</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li><font color="red"><code>降低精度</code></font>,也是有编译器自动完成,会造成精度丢失,所以编译时得到一个警告信息提示.</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"><span class="type">double</span> dval = <span class="number">3.14159</span>;</span><br><span class="line"><span class="comment">// dval的值被截取为 int 值3</span></span><br><span class="line"><span class="type">int</span> ival = dval;</span><br></pre></td></tr></tbody></table></figure><h3 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a><strong>显式类型转换</strong></h3><h4 id="C风格的强制转换-包括旧式C-风格的强制转换"><a href="#C风格的强制转换-包括旧式C-风格的强制转换" class="headerlink" title="C风格的强制转换(包括旧式C++风格的强制转换)"></a>C风格的强制转换(包括旧式C++风格的强制转换)</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式: </span><br><span class="line">类型(表达式); <span class="comment">// 旧的C++风格</span></span><br><span class="line">或者 </span><br><span class="line">(类型)表达式 <span class="comment">// C风格</span></span><br><span class="line"></span><br><span class="line">示例: <span class="built_in">int</span>(dval) 或者 (<span class="type">int</span>)dval</span><br></pre></td></tr></tbody></table></figure><p>此种强制转换是比较粗暴直接的,有可能导致<font color="orange">精度丢失</font>(如从 double 转换为 int)或者一些莫名其妙的错误(<font color="red">如把 int 转换为 函数指针</font>),一旦使用了强制转换,编译器将不提示任何警告.这也往往成为错误的源泉.而且这种错误非常难找.我想这也是C++要使用新的强制转换操作符的原因之一吧。</p><h4 id="C-强制转换操作符"><a href="#C-强制转换操作符" class="headerlink" title="C++强制转换操作符"></a>C++强制转换操作符</h4><p>C++增加了4个关键字用于强制类型转换:<br><font color="orange"><code>static_cast</code></font>, <font color="orange"><code>reinterpret_cast</code></font>, <font color="orange"><code>const_cast</code> </font>和 <font color="orange"><code>dynamic_cast</code></font>。</p><h5 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h5><p><font color="orange"><code>const_cast</code></font>一般用于强制消除对象的常量性。它是<font color="red">唯一</font>能做到这一点的C++风格的强制转型。这个转换能剥离一个对象的const属性，也就是说允许你对常量进行修改。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">代码:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> {};</span><br><span class="line"><span class="type">const</span> C *a = <span class="keyword">new</span> C;</span><br><span class="line">C *b = <span class="built_in">const_cast</span>&lt;C *&gt;(a);</span><br></pre></td></tr></tbody></table></figure><h5 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h5><p><font color="orange"><code>dynamic_cast</code> </font>主要用于执行“安全的向下转型(safe downcasting)”，也就是说，要确定一个对象是否是一个继承体系中的一个特定类型。支持父类指针到子类指针的转换，这种转换时最安全的转换。它是唯一不能用旧风格语法执行的强制类型转换，也是唯一可能有重大运行时代价的强制转换。</p><hr><p>通俗来说，<font color="orange"><code>dynamic_cast</code> </font>需要 RTTI 支持, 主要用于把基类指针转换为派生类指针.这里的基类指针其实是指向一个派生类实例,只是类型为基类.</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"><span class="comment">// 前提假设: class B 由 class A 派生</span></span><br><span class="line">A *ptrA = <span class="keyword">new</span> <span class="keyword">class</span> B;</span><br><span class="line">B *ptrB = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(ptrA);</span><br></pre></td></tr></tbody></table></figure><h5 id="static-cast和reinterpret-cast"><a href="#static-cast和reinterpret-cast" class="headerlink" title="static_cast和reinterpret_cast"></a>static_cast和reinterpret_cast</h5><p><strong>本文主要谈谈 static_cast 和 reinterpret_cast 的用法和区别。</strong><br>&lt;&lt;C++程序程序设计语言&gt;&gt;里有一句话我认为说到点子上了: <font color="red"><code>static_cast 运算符完成相关类型之间的转换. 而 reinterpret_cast 处理互不相关的类型之间的转换</code></font>。</p><p>所谓”相关类型”指的是从逻辑上来说,多多少少还有那么一点联系的类型,比如从 double 到 int,我们知道它们之间还是有联系的,只是精度差异而已,使用 static_cast 就是告诉编译器:我知道会引起精度损失,但是我不在乎. 又如从 void* 到 具体类型指针像 char*,从语义上我们知道 void* 可以是任意类型的指针,当然也有可能是 char* 型的指针,这就是所谓的”多多少少还有那么一点联系”的意思. 又如从派生类层次中的上行转换(即从派生类指针到基类指针,因为是安全的,所以可以用隐式类型转换)或者下行转换(不安全,应该用 dynamic_cast 代替).<br>对于static_cast操作符,如果需要截断,补齐或者指针偏移编译器都会自动完成.注意这一点,是和 reinterpret_cast 的一个根本区别。</p><hr><p>“互不相关的类型”指的是两种完全不同的类型,如从整型到指针类型,或者从一个指针到另一个毫不相干的指针.</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"><span class="type">int</span> ival = <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> *dptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">double</span>*&gt;(ival);</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"><span class="type">int</span> *iptr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">double</span> *dptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">double</span>*&gt;(iptr);</span><br></pre></td></tr></tbody></table></figure><p><font color="red"><code>reinterpret_cast 操作执行的是比特位拷贝,就好像用 memcpy() 一样.</code></font></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *iptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(<span class="number">1</span>);</span><br><span class="line"><span class="type">double</span> *dptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">double</span>*&gt;(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;dptr, &amp;iptr, <span class="built_in">sizeof</span>(<span class="type">double</span>*)); <span class="comment">// 等效于 dptr = reinterpret_cast&lt;double*&gt;(iptr);结果 dptr 的值为1; </span></span><br></pre></td></tr></tbody></table></figure><p>上面这个示例也说明了 <font color="orange"><code>reinterpret_cast</code></font> 的意思:<font color="orange">编译器不会做任何检查,截断,补齐的操作,只是把比特位拷贝过去.</font><br>所以 <font color="orange"><code>reinterpret_cast</code></font><font color="red">常常被用作不同类型指针间的相互转换,因为所有类型的指针的长度都是一致的(32位系统上都是4字节),按比特位拷贝后不会损失数据.</font></p><h4 id="编程实践中几种典型的应用场景"><a href="#编程实践中几种典型的应用场景" class="headerlink" title="编程实践中几种典型的应用场景"></a>编程实践中几种典型的应用场景</h4><p>数值精度提示或者降低,包括把无符号型转换为带符号型(也是精度损失的一种),用 static_cast 可以消除编译器的警告信息,前面提到好几次了。</p><ol><li><p>任意类型指针到 void*, 隐式类型转换,自动完成。</p><p>看看 memcpy 的原型:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memcpy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">void</span> *dest,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">const</span> <span class="type">void</span> *src,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">size_t</span> count </span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>参数定义为 void* 是有道理的,不管我们传入什么类型的指针都符合语义,并且不会有编译器警告。</p></li><li><p>void* 到任意类型指针, 用 static_cast 和 reinterpret_cast 都可以,这是由 void* 是通用指针这个语义决定的.我个人倾向用 reinterpret_cast,表达要”重新解释”指针的语义.</p></li><li><p>不同类型指针间的相互转换用 reinterpret_cast。</p><p>例如：动态库调用时的函数指针间的转换</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HINSTANCE hIYolo = <span class="built_in">LoadLibrary</span>(<span class="string">"./MyDLL.dll"</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">"hIYolo:"</span> &lt;&lt; hIYolo &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//将Init变量类型转换为DLL对象hIYolo中的Init，即Init等价于hIYolo中的Init指针对象</span></span><br><span class="line"><span class="keyword">auto</span> Init = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">bool</span>(__stdcall *)(<span class="type">char</span>*)&gt;(<span class="built_in">GetProcAddress</span>(hIYolo, <span class="string">"Init"</span>));</span><br></pre></td></tr></tbody></table></figure><p>代码中将<font color="orange">Init</font>转换为动态库中的<font color="red">Init</font>函数指针类型。</p></li><li><p>int 型和指针类型间的相互转换用 reinterpret_cast.<br>比如我写代码的时候经常这样做: new 一个 struct,然后把指针返回给外部函数作为一个”句柄”,我不希望外部函数知道这是一个指针,只需要外部函数在调用相关函数时把这个”句柄”重新传回来.这时,就可以把指针转换为一个 int 型返回. 这是 reinterpret_cast 存在的绝佳理由.</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">car</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> doors;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">float</span> weight; </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">create_car</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    car *c = <span class="keyword">new</span> car;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>&gt;(c);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_car_doors</span><span class="params">(<span class="type">int</span> car_id)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    car *c = <span class="built_in">reinterpret_cast</span>&lt;car*&gt;(car_id);</span><br><span class="line">    <span class="keyword">return</span> c-&gt;doors;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy_car</span><span class="params">(<span class="type">int</span> car_id)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    car *c = <span class="built_in">reinterpret_cast</span>&lt;car*&gt;(car_id);</span><br><span class="line">    <span class="keyword">delete</span> c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如上,外部函数不需要知道 struct car 的具体定义,只需要调用 create_car() 得到一个 car id,然后用此 car_id 调用其他相关函数即可,至于 car_id 是什么,根本没必要关心.</p></li><li><p>派生类指针和基类指针间的相互转换.</p><p>派生类指针到基类指针用隐式类型转换(直接赋值)或者用 static_cast. 显然不应该也没必要用 reinterpret_cast.</p></li><li><p>基类指针到派生类指针</p><p>基类指针到派生类指针用 dynamic_cast (运行期检查)或者 static_cast (运行期不检查,由程序员保证正确性). 考虑到C++对象模型的内存分布可能引起的指针偏移问题,绝对不能用 reinterpret_cast.</p></li></ol><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>几乎所有提到 reinterpret_cast 的书籍都要附带说什么”不可移植”,”危险”之类的词,好像 reinterpret_cast 是洪水猛兽,碰不得摸不得.其实理解了之后就知道没什么神秘的,存在即是理由,该用的时候就要大胆的用,否则C++保留这个关键字干什么? 关键是程序员应该清楚的知道自己要的结果是什么,如此,就是用C风格的强制转换又有何妨?</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++11新特性 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>列表初始化</title>
      <link href="/2022/04/27/%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2022/04/27/%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>关于 C++ 中的变量，数组，对象等都有不同的初始化方法，在这些繁琐的初始化方法中没有任何一种方式适用于所有的情况。为了统一初始化方式，并且让初始化行为具有确定的效果，在 C++11 中提出了列表初始化的概念。</p><h3 id="统一的初始化"><a href="#统一的初始化" class="headerlink" title="统一的初始化"></a>统一的初始化</h3><p>在 C++98/03 中，对应普通数组和可以直接进行内存拷贝（memcpy ()）的对象是可以使用列表初始化来初始化数据的</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的初始化</span></span><br><span class="line"><span class="type">int</span> array[] = { <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span> };</span><br><span class="line"><span class="type">double</span> array1[<span class="number">3</span>] = { <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span> };</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的初始化</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">double</span> salary;</span><br><span class="line">}zhang3{ <span class="number">1</span>, <span class="number">3000</span> };</span><br></pre></td></tr></tbody></table></figure><p>在 C++11 中，列表初始化变得更加灵活了，来看一下下面这段初始化类对象的代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span>) {}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test &amp;);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">520</span>)</span></span>;</span><br><span class="line">    Test t2 = <span class="number">520</span>;  <span class="comment">//err</span></span><br><span class="line">    Test t3 = { <span class="number">520</span> };</span><br><span class="line">    Test t4{ <span class="number">520</span> };</span><br><span class="line">    <span class="type">int</span> a1 = { <span class="number">1314</span> };</span><br><span class="line">    <span class="type">int</span> a2{ <span class="number">1314</span> };</span><br><span class="line">    <span class="type">int</span> arr1[] = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> };</span><br><span class="line">    <span class="type">int</span> arr2[]{ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> };</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>具体地来解读一下上面代码中使用的各种初始化方式：</p><ul><li><font color="orange">t1</font>：最中规中矩的初始化方式，通过提供的带参构造进行对象的初始化</li><li><font color="orange">t2</font>：语法错误，因为提供的拷贝构造函数是私有的。<font color="orange">如果拷贝构造函数是公共的，520 会通过隐式类型转换被 Test(int) 构造成一个匿名对象，然后再通过对这个匿名对象进行拷贝构造得到 t2</font>（<font color="red">这个错误在 VS 中不会出现，在 Linux 中使用 g++ 编译会提示描述的这个错误，截图如下。</font>）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202204271803213.png" alt="image-20210519095041852"></p><ul><li><p><font color="orange">t3</font> 和 <font color="orange">t4</font>：使用了 C++11 的初始化方式来初始化对象，效果和 <font color="red">t1 </font>的方式是相同的。</p><ul><li><font color="orange">在初始时，{} 前面的等号是否书写对初始化行为没有任何影响。</font></li><li><font color="orange">t3</font> 虽然使<font color="orange">用了等号，但是它仍然是列表初始化</font>，因此私有的拷贝构造对它没有任何影响。</li></ul></li><li><p><font color="orange">t1</font>、<font color="orange">arr1 </font>和 <font color="orange">t2</font>、<font color="orange">arr2</font>：这两个是基础数据类型的列表初始化方式，可以看到，和对象的初始化方式是统一的。</p></li><li><p><font color="orange">t4</font>、<font color="orange">a2</font>、<font color="orange">arr2 </font>的写法，是 C++11 中新添加的语法格式，<font color="orange"><code>使用这种方式可以直接在变量名后边跟上初始化列表，来进行变量或者对象的初始化</code></font>。</p></li></ul><p>+++</p><p>既然使用列表初始化可以对普通类型以及对象进行直接初始化，那么在使用 new 操作符创建新对象的时候可以使用列表初始化进行对象的初始化吗？答案是肯定的，来看下面的例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * p = <span class="keyword">new</span> <span class="type">int</span>{<span class="number">520</span>};</span><br><span class="line"><span class="type">double</span> b = <span class="type">double</span>{<span class="number">52.134</span>};</span><br><span class="line"><span class="type">int</span> * array = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};</span><br></pre></td></tr></tbody></table></figure><ul><li><font color="orange">指针p</font> 指向了一个 new 操作符返回的内存，通过列表初始化将内存数据初始化为了 520</li><li><font color="orange">变量b</font> 是对匿名对象使用列表初始之后，再进行拷贝初始化。</li><li><font color="orange">数组array</font> 在堆上动态分配了一块内存，通过列表初始化的方式直接完成了多个元素的初始化。</li></ul><p>除此之外，列表初始化还可以直接用在函数返回值上：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> id, string name)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"id: "</span> &lt;&lt; id &lt;&lt; <span class="string">", name: "</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> { <span class="number">9527</span>, <span class="string">"华安"</span> };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Person p = <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码中的 <font color="orange"><code>return { 9527, "华安" };</code></font> 就相当于 <font color="orange"><code>return (9527, "华安" );</code></font>，直接返回了一个匿名对象。通过上面的几个例子可以看出在 C++11 使用列表初始化是非常便利的，它统一了各种对象的初始化方式，而且还让代码的书写更加简单清晰。</p><h3 id="列表初始化细节"><a href="#列表初始化细节" class="headerlink" title="列表初始化细节"></a>列表初始化细节</h3><h4 id="聚合体"><a href="#聚合体" class="headerlink" title="聚合体"></a>聚合体</h4><p>在 C++11 中，列表初始化的使用范围被大大增强了，但是一些模糊的概念也随之而来，在前面的例子可以得知，列表初始化可以用于自定义类型的初始化，但是对于一个自定义类型，列表初始化可能有两种执行结果：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T1</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">}a = { <span class="number">123</span>, <span class="number">321</span> };</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T2</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="built_in">T2</span>(<span class="type">int</span>, <span class="type">int</span>) : <span class="built_in">x</span>(<span class="number">10</span>), <span class="built_in">y</span>(<span class="number">20</span>) {}</span><br><span class="line">}b = { <span class="number">123</span>, <span class="number">321</span> };</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"a.x: "</span> &lt;&lt; a.x &lt;&lt; <span class="string">", a.y: "</span> &lt;&lt; a.y &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"b.x: "</span> &lt;&lt; b.x &lt;&lt; <span class="string">", b.y: "</span> &lt;&lt; b.y &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序执行的结果是这样的:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.x: <span class="number">123</span>, a.y: <span class="number">321</span></span><br><span class="line">b.x: <span class="number">10</span>, b.y: <span class="number">20</span></span><br></pre></td></tr></tbody></table></figure><p>在上边的程序中都是用列表初始化的方式对对象进行了初始化，但是得到结果却不同，对象 b 并没有被初始化列表中的数据初始化，这是为什么呢？</p><ul><li><font color="red">对象 a 是对一个自定义的聚合类型进行初始化，它将以拷贝的形式使用初始化列表中的数据来初始化 T1 结构体中的成员。</font></li><li><font color="red">在结构体 T2 中自定义了一个构造函数，因此实际的初始化是通过这个构造函数完成的。</font></li></ul><p>现在很多小伙伴可能就一头雾水了，同样是自定义结构体并且在创建对象的时候都使用了列表初始化来初始化对象，为什么在类内部对对象的初始化方式却不一样呢？<font color="orange"><code>因为如果使用列表初始化对对象初始化时，还需要判断这个对象对应的类型是不是一个聚合体，如果是初始化列表中的数据就会拷贝到对象中。</code></font></p><p>那么，使用列表初始化时，对于什么样的类型 C++ 会认为它是一个聚合体呢？</p><ul><li>普通数组本身可以看做是一个聚合类型</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x[] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>};</span><br><span class="line"><span class="type">double</span> y[<span class="number">3</span>][<span class="number">3</span>] = {</span><br><span class="line">    {<span class="number">1.23</span>, <span class="number">2.34</span>, <span class="number">3.45</span>},</span><br><span class="line">    {<span class="number">4.56</span>, <span class="number">5.67</span>, <span class="number">6.78</span>},</span><br><span class="line">    {<span class="number">7.89</span>, <span class="number">8.91</span>, <span class="number">9.99</span>},</span><br><span class="line">};</span><br><span class="line"><span class="type">char</span> carry[] = {<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>};</span><br><span class="line">std::string sarry[] = {<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"nihao"</span>, <span class="string">"shijie"</span>};</span><br></pre></td></tr></tbody></table></figure><ul><li><p>满足以下条件的类（class、struct、union）可以被看做是一个聚合类型：</p><ul><li><p>无用户自定义的构造函数。</p></li><li><p>无私有或保护的非静态数据成员。</p><ul><li>场景 1: 类中有私有成员，无法使用列表初始化进行初始化</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T1</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">long</span> y;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">}t{ <span class="number">1</span>, <span class="number">100</span>, <span class="number">2</span>};<span class="comment">// error, 类中有私有成员, 无法使用初始化列表初始化</span></span><br></pre></td></tr></tbody></table></figure><ul><li>场景 2：类中有非静态成员可以通过列表初始化进行初始化，但它不能初始化静态成员变量。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T2</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">long</span> y;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> z;</span><br><span class="line">}t{ <span class="number">1</span>, <span class="number">100</span>， <span class="number">2</span>};<span class="comment">// error</span></span><br></pre></td></tr></tbody></table></figure><ul><li>结构体中的静态变量 z 不能使用列表初始化进行初始化，它的初始化遵循静态成员的初始化方式。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T2</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">long</span> y;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> z;</span><br><span class="line">}t{ <span class="number">1</span>, <span class="number">100</span>};<span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 静态成员的初始化</span></span><br><span class="line"><span class="type">int</span> T2::z = <span class="number">2</span>;</span><br></pre></td></tr></tbody></table></figure></li><li><p>无基类。</p></li><li><p>无虚函数。</p></li><li><p>类中不能有使用 {} 和 = 直接初始化的非静态数据成员（从 c++14 开始就支持了）。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T2</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">long</span> y;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> z;</span><br><span class="line">}t1{ <span class="number">1</span>, <span class="number">100</span> };<span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 静态成员的初始化</span></span><br><span class="line"><span class="type">int</span> T2::z = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T3</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">1.34</span>;</span><br><span class="line">    <span class="type">int</span> z[<span class="number">3</span>]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    T3 t{<span class="number">520</span>, <span class="number">13.14</span>, {<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>}};<span class="comment">// error, c++11不支持,从c++14开始就支持了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><blockquote><p><font color="orange"><code>从C++14开始，使用列表初始化也可以初始化在类中使用{}和=初始化过的非静态数据成员。</code></font></p></blockquote><h4 id="非聚合体"><a href="#非聚合体" class="headerlink" title="非聚合体"></a>非聚合体</h4><p>对于聚合类型的类可以直接使用列表初始化进行对象的初始化，如果不满足聚合条件还想使用列表初始化其实也是可以的，<font color="orange"><code>需要在类的内部自定义一个构造函数, 在构造函数中使用初始化列表对类成员变量进行初始化:</code></font></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T1</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">    <span class="comment">// 在构造函数中使用初始化列表初始化类成员</span></span><br><span class="line">    <span class="built_in">T1</span>(<span class="type">int</span> a, <span class="type">double</span> b, <span class="type">int</span> c) : <span class="built_in">x</span>(a), <span class="built_in">y</span>(b), <span class="built_in">z</span>(c){}</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"x: "</span> &lt;&lt; x &lt;&lt; <span class="string">", y: "</span> &lt;&lt; y &lt;&lt; <span class="string">", z: "</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    T1 t{ <span class="number">520</span>, <span class="number">13.14</span>, <span class="number">1314</span> };<span class="comment">// ok, 基于构造函数使用初始化列表初始化类成员</span></span><br><span class="line">    t.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>另外，需要额外注意的是<font color="orange"><code>聚合类型的定义并非递归的</code></font>，也就是说<font color="orange"><code>当一个类的非静态成员是非聚合类型时，这个类也可能是聚合类型</code></font>，比如下面的这个例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T1</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T2</span></span><br><span class="line">{</span><br><span class="line">    T1 t1;</span><br><span class="line">    <span class="type">long</span> x1;</span><br><span class="line">    <span class="type">double</span> y1;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    T2 t2{ {}, <span class="number">520</span>, <span class="number">13.14</span> };</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，T1 并非一个聚合类型，因为它有一个 Private 的非静态成员。但是尽管 T2 有一个非聚合类型的非静态成员 t1，T2 依然是一个聚合类型，可以直接使用列表初始化的方式进行初始化。</p><p>最后强调一下 t2 对象的初始化过程，对于非聚合类型的成员 t1 做初始化的时候，可以直接写一对空的大括号 <font color="orange">{}</font>，这相当于调用是 T1 的无参构造函数。</p><blockquote><p><font color="red">对于一个聚合类型，使用列表初始化相当于对其中的每个元素分别赋值，而对于非聚合类型，则需要先自定义一个合适的构造函数，此时使用列表初始化将会调用它对应的构造函数。</font></p></blockquote><h4 id="std-initializer-list"><a href="#std-initializer-list" class="headerlink" title="std::initializer_list"></a>std::initializer_list</h4><p>在 C++ 的 STL 容器中，可以进行任意长度的数据的初始化，使用初始化列表也只能进行固定参数的初始化，如果想要做到和 STL 一样有任意长度初始化的能力，可以使用 <font color="orange">std::initializer_list</font> 这个轻量级的类模板来实现。</p><p>先来介绍一下这个类模板的一些特点：</p><ul><li>它是一个轻量级的容器类型，内部定义了迭代器 <font color="orange">iterator </font>等容器必须的概念，<font color="orange">遍历时得到的迭代器是只读的</font>。</li><li>对于<font color="orange">&nbsp;<code>std::initializer_list&lt;T&gt;</code></font> 而言，它可以接收任意长度的初始化列表，但是要求元素必须是同种类型 T</li><li>在<font color="orange"> std::initializer_list</font> 内部有三个成员接口：<font color="orange">size(), begin(), end()</font>。</li><li><font color="orange">std::initializer_list </font>对象只能被整体初始化或者赋值。</li></ul><h5 id="作为普通函数参数"><a href="#作为普通函数参数" class="headerlink" title="作为普通函数参数"></a>作为普通函数参数</h5><p>如果想要自定义一个函数并且接收任意个数的参数（变参函数），只需要将函数参数指定为 <font color="orange"><code>std::initializer_list</code></font>，使用初始化列表 <font color="orange"><code>{ }</code> </font>作为实参进行数据传递即可。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt; a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = a.<span class="built_in">begin</span>(); it != a.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    initializer_list&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">    cout &lt;&lt; <span class="string">"current list size: "</span> &lt;&lt; list.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">traversal</span>(list);</span><br><span class="line"></span><br><span class="line">    list = { <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span> };</span><br><span class="line">    cout &lt;&lt; <span class="string">"current list size: "</span> &lt;&lt; list.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">traversal</span>(list);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    list = { <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span> };</span><br><span class="line">    cout &lt;&lt; <span class="string">"current list size: "</span> &lt;&lt; list.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">traversal</span>(list);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">////////////// 直接通过初始化列表传递数据 //////////////</span></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="built_in">traversal</span>({ <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span> });</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">traversal</span>({ <span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span> });</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>示例代码输出的结果：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">current list size: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">current list size: <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">current list size: <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>std::initializer_list拥有一个无参构造函数</code></font>，因此，它可以直接定义实例，此时将<font color="orange"><code>得到一个空的std::initializer_list</code></font>，因为在遍历这种类型的容器的时候得到的是一个只读的迭代器，因此我们不能修改里边的数据，只能通过值覆盖的方式进行容器内部数据的修改。虽然如此，在效率方面也无需担心，<font color="orange"><code>std::initializer_list的效率是非常高的，它的内部并不负责保存初始化列表中元素的拷贝，仅仅存储了初始化列表中元素的引用。</code></font></p><h5 id="作为构造函数参数"><a href="#作为构造函数参数" class="headerlink" title="作为构造函数参数"></a>作为构造函数参数</h5><p>自定义的类如果在构造对象的时候想要接收任意个数的实参，可以给构造函数指定为 <font color="orange"><code>std::initializer_list</code> </font>类型，在自定义类的内部还是使用容器来存储接收的多个实参。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(std::initializer_list&lt;string&gt; list)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        {</span><br><span class="line">            cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            m_names.<span class="built_in">push_back</span>(*it);</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; m_names;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">({ <span class="string">"jack"</span>, <span class="string">"lucy"</span>, <span class="string">"tom"</span> })</span></span>;</span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">({ <span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"nihao"</span>, <span class="string">"shijie"</span> })</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出的结果:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jack lucy tom</span><br><span class="line">hello world nihao shijie</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++11新特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于范围的for循环</title>
      <link href="/2022/04/27/%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF/"/>
      <url>/2022/04/27/%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p>在 C++98/03 中，不同的容器和数组遍历的方式不尽相同，写法不统一，也不够简洁，而 C++11 <font color="orange">基于范围的 for 循环</font>可以以简洁、统一的方式来遍历容器和数组，用起来也更方便了。</p><h3 id="for循环新语法"><a href="#for循环新语法" class="headerlink" title="for循环新语法"></a>for循环新语法</h3><p>在介绍新语法之前，先来看一个使用迭代器遍历容器的例子</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t{ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> };</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = t.<span class="built_in">begin</span>(); it != t.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们在遍历的过程中需要给出容器的两端：开头（begin）和结尾（end），因为这种遍历方式不是基于范围来设计的。<font color="orange"><code>在基于范围的for循环中，不需要再传递容器的两端，循环会自动以容器为范围展开，并且循环中也屏蔽掉了迭代器的遍历细节，直接抽取容器中的元素进行运算，使用这种方式进行循环遍历会让编码和维护变得更加简便。</code></font></p><p>C++98/03 中普通的 for 循环，语法格式：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式 <span class="number">1</span>; 表达式 <span class="number">2</span>; 表达式 <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>C++11 基于范围的 for 循环，语法格式：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上面的语法格式中 <font color="orange"><code>declaration</code> </font>表示遍历声明，在遍历过程中，当前被遍历到的元素会被存储到声明的变量中。<font color="orange"><code>expression</code> </font>是要遍历的对象，它可以是<font color="orange"><code>表达式</code></font>、<font color="orange"><code>容器</code></font>、<font color="orange"><code>数组</code></font>、<font color="orange"><code>初始化列表</code></font>等。</p><p>使用基于范围的 for 循环遍历容器，示例代码如下。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t{ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> };</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> value : t)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上面的例子中，<font color="red"><code>是将容器中遍历的当前元素拷贝一个复本到声明的变量 value 中，因此无法对容器中的元素进行写操作，如果需要在遍历过程中修改元素的值，需要使用引用。</code></font></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t{ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> };</span><br><span class="line">    cout &lt;&lt; <span class="string">"遍历修改之前的容器: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;value : t)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; value++ &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">"遍历修改之后的容器: "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;value : t)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码输出的结果：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">遍历修改之前的容器: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">遍历修改之后的容器: <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></tbody></table></figure><p>对容器的遍历过程中，如果只是读数据，不允许修改元素的值，可以使用 <font color="orange"><code>const</code> </font>定义保存元素数据的变量，在定义的时候建议使用 <font color="orange"><code>const auto &amp;</code></font>，这样相对于 <font color="orange"><code>const auto</code> </font>效率要更高一些。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t{ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> };</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; value : t)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><h4 id="关系型容器"><a href="#关系型容器" class="headerlink" title="关系型容器"></a>关系型容器</h4><p>使用基于范围的 for 循环有一些需要注意的细节，先来看一下对关系型容器 map 的遍历：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; m{</span><br><span class="line">        {<span class="number">1</span>, <span class="string">"lucy"</span>},{<span class="number">2</span>, <span class="string">"lily"</span>},{<span class="number">3</span>, <span class="string">"tom"</span>}</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于范围的for循环方式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : m)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"id: "</span> &lt;&lt; it.first &lt;&lt; <span class="string">", name: "</span> &lt;&lt; it.second &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通的for循环方式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"id: "</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">", name: "</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上面的例子中使用两种方式对 map 进行了遍历，通过对比有两点需要注意的事项：</p><ol><li><font color="red"><code>使用普通的 for 循环方式（基于迭代器）遍历关联性容器， auto 自动推导出的是一个迭代器类型，需要使用迭代器的方式取出元素中的键值对（和指针的操作方法相同）：</code></font><ul><li>it-&gt;first</li><li>it-&gt;second</li></ul></li><li><font color="red"><code>使用基于范围的 for 循环遍历关联性容器，auto 自动推导出的类型是容器中的 value_type，相当于一个对组（std::pair）对象，提取键值对的方式如下：</code></font><ul><li>it.first</li><li>it.second</li></ul></li></ol><h4 id="元素只读"><a href="#元素只读" class="headerlink" title="元素只读"></a>元素只读</h4><p>通过对基于范围的 for 循环语法的介绍可以得知，在 for 循环内部声明一个变量的引用就可以修改遍历的表达式中的元素的值，但是这并不适用于所有的情况，<font color="red"><code>对应 set 容器来说，内部元素都是只读的，这是由容器的特性决定的，因此在 for 循环中 auto &amp; 会被视为 const auto &amp;</code> </font>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; st{ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> };</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : st) </span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; item++ &lt;&lt; endl;<span class="comment">// error, 不能给常量赋值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>除此之外，<font color="red"><code>在遍历关联型容器时也会出现同样的问题，基于范围的for循环中，虽然可以得到一个std::pair引用，但是我们是不能修改里边的first值的，也就是key值。</code></font></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; m{</span><br><span class="line">        {<span class="number">1</span>, <span class="string">"lucy"</span>},{<span class="number">2</span>, <span class="string">"lily"</span>},{<span class="number">3</span>, <span class="string">"tom"</span>}</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : m)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// item.first 是一个常量</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"id: "</span> &lt;&lt; item.first++ &lt;&lt; <span class="string">", name: "</span> &lt;&lt; item.second &lt;&lt; endl;  <span class="comment">// error</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="访问次数"><a href="#访问次数" class="headerlink" title="访问次数"></a>访问次数</h4><p>基于范围的 for 循环遍历的对象可以是一个表达式或者容器 / 数组等。假设我们对一个容器进行遍历，在遍历过程中 for 循环对这个容器的访问频率是一次还是多次呢？我们通过下面的例子验证一下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v{ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> };</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt;&amp; <span class="title">getRange</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"get vector range..."</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : <span class="built_in">getRange</span>())</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出的结果如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get vector range...</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure><p>从上面的结果中可以看到，不论基于范围的 for 循环迭代了多少次，函数 <font color="orange"><code>getRange ()</code> </font>只在第一次迭代之前被调用，得到这个容器对象之后就不会再去重新获取这个对象了。</p><blockquote><p>结论：</p><p><font color="red">对应基于范围的 for 循环来说，冒号后边的表达式只会被执行一次。在得到遍历对象之后会先确定好迭代的范围，基于这个范围直接进行遍历。如果是普通的 for 循环，在每次迭代的时候都需要判断是否已经到了结束边界。</font></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++11新特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>using</title>
      <link href="/2022/04/27/using/"/>
      <url>/2022/04/27/using/</url>
      
        <content type="html"><![CDATA[<p>在 C++ 中 using 用于声明命名空间，使用命名空间也可以防止命名冲突。在程序中声明了命名空间之后，就可以直接使用命名空间中的定义的类了。在 C++11 中赋予了 <font color="orange">using </font>新的功能，让 C++ 变得更年轻，更灵活。</p><h4 id="定义别名"><a href="#定义别名" class="headerlink" title="定义别名"></a>定义别名</h4><p>在 C++ 中可以通过 <font color="orange">typedef </font>重定义一个类型，语法格式如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> 旧的类型名 新的类型名;</span><br><span class="line"><span class="comment">// 使用举例</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint_t</span>;</span><br></pre></td></tr></tbody></table></figure><p><font color="red"><code>被重定义的类型并不是一个新的类型，仅仅只是原有的类型取了一个新的名字</code></font>。和以前的声明语句一样，这里的声明符也可以包含类型修饰，从而也能由基本数据类型构造出复合类型来。C++11 中规定了一种新的方法，使用别名声明 (alias declaration) 来定义类型的别名，即使用 <font color="orange"><code>using</code></font>。</p><p>在使用的时候，关键字 using 作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。<font color="orange"><code>类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名。使用typedef定义的别名和使用using定义的别名在语义上是等效的。</code></font></p><p>使用 using 定义别名的语法格式是这样的：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> 新的类型 = 旧的类型;</span><br><span class="line"><span class="comment">// 使用举例</span></span><br><span class="line"><span class="keyword">using</span> <span class="type">uint_t</span> = <span class="type">int</span>;</span><br></pre></td></tr></tbody></table></figure><p>通过 using 和 typedef 的语法格式可以看到二者的使用没有太大的区别，假设我们定义一个函数指针，using 的优势就能凸显出来了，看一下下面的例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用typedef定义函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*func_ptr)</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用using定义函数指针</span></span><br><span class="line"><span class="keyword">using</span> func_ptr1 = <span class="built_in">int</span>(*)(<span class="type">int</span>, <span class="type">double</span>);</span><br></pre></td></tr></tbody></table></figure><p>如果不是特别熟悉函数指针与 typedef，第一眼很难看出 func_ptr 其实是一个别名，其本质是一个函数指针，指向的函数返回类型是 int，函数参数有两个分别是 int，double 类型。</p><p>使用 using 定义函数指针别名的写法看起来就非常直观了，<font color="orange"><code>把别名的名字强制分离到了左边，而把别名对应的实际类型放在了右边</code></font>，比较清晰，可读性比较好。</p><h4 id="模板的别名"><a href="#模板的别名" class="headerlink" title="模板的别名"></a>模板的别名</h4><p>使用 typedef 重定义类似很方便，但是它有一点限制，比如无法重定义一个模板，比如我们需要一个固定以 int 类型为 key 的 map，它可以和很多类型的 value 值进行映射，如果使用 typedef 这样直接定义就非常麻烦:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> map&lt;<span class="type">int</span>, string&gt; m1;</span><br><span class="line"><span class="keyword">typedef</span> map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m2;</span><br><span class="line"><span class="keyword">typedef</span> map&lt;<span class="type">int</span>, <span class="type">double</span>&gt; m3;</span><br></pre></td></tr></tbody></table></figure><p>在这种情况下我们就不自觉的想到了模板：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typedef</span> map&lt;<span class="type">int</span>, T&gt; type;<span class="comment">// error, 语法错误</span></span><br></pre></td></tr></tbody></table></figure><p>使用 typename 不支持给模板定义别名，这个简单的需求仅通过 typedef 很难办到，需要添加一个外敷类：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 定义外敷类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyMap</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">typedef</span> map&lt;<span class="type">int</span>, T&gt; type;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    MyMap&lt;string&gt;::type m;</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">"luffy"</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">"ace"</span>));</span><br><span class="line"></span><br><span class="line">    MyMap&lt;<span class="type">int</span>&gt;::type m1;</span><br><span class="line">    m1.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    m1.<span class="built_in">insert</span>(<span class="number">2</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过上边的例子可以直观的感觉到，需求简单但是实现起来并不容易。<strong>在 C++11 中，新增了一个特性就是可以通过使用 using 来为一个模板定义别名</strong>，对于上面的需求可以写成这样：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> mymap = map&lt;<span class="type">int</span>, T&gt;;</span><br></pre></td></tr></tbody></table></figure><p>完整的示例代码如下:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> mymap = map&lt;<span class="type">int</span>, T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// map的value指定为string类型</span></span><br><span class="line">    mymap&lt;string&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">"luffy"</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">"ace"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map的value指定为int类型</span></span><br><span class="line">    mymap&lt;<span class="type">int</span>&gt; m1;</span><br><span class="line">    m1.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    m1.<span class="built_in">insert</span>(<span class="number">2</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的例子中通过使用 using 给模板指定别名，就可以基于别名非常方便的给 value 指定相应的类型，这样使编写的程序变得更加灵活，看起来也更加简洁一些。</p><p><font color="red"><code>最后在强调一点：using 语法和 typedef 一样，并不会创建出新的类型，它们只是给某些类型定义了新的别名。using 相较于 typedef 的优势在于定义函数指针别名时看起来更加直观，并且可以给模板定义别名。</code></font></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++11新特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>final和override</title>
      <link href="/2022/04/27/final%E5%92%8Coverride/"/>
      <url>/2022/04/27/final%E5%92%8Coverride/</url>
      
        <content type="html"><![CDATA[<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>C++ 中增加了 <font color="orange"><code>final</code> </font>关键字来<font color="red"><code>限制某个类不能被继承，或者某个虚函数不能被重写</code></font>，和 Jave 的 <font color="orange"><code>final</code></font> 关键字的功能是类似的。如果使用 <font color="orange"><code>final</code> </font>修饰函数，<font color="red"><code>只能修饰虚函数</code></font>，并且<font color="red"><code>要把final关键字放到类或者函数的后面。</code></font></p><h4 id="修饰函数"><a href="#修饰函数" class="headerlink" title="修饰函数"></a>修饰函数</h4><p>如果使用 <font color="orange"><code>final</code> </font>修饰函数，<font color="red">只能修饰虚函数，这样就能阻止子类重写父类的这个函数了</font>：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base class..."</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">final</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Child class..."</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> : <span class="keyword">public</span> Child</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 语法错误, 不允许重写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"GrandChild class..."</span>;</span><br><span class="line">    }</span><br><span class="line">};   </span><br></pre></td></tr></tbody></table></figure><p>在上面的代码中一共有三个类：</p><ul><li>基类：Base</li><li>子类：Child</li><li>孙子类：GrandChild</li></ul><p><font color="orange"><code>test()</code> </font>是基类中的一个虚函数，在子类中重写了这个方法，但是不希望孙子类中继续重写这个方法了，因此在子类中将 <font color="orange"><code>test()</code> </font>方法标记为 <font color="orange"><code>final</code></font>，孙子类中对这个方法就只有使用的份了。</p><h4 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h4><p>使用 <font color="orange"><code>final</code> </font>关键字修饰过的类是不允许被继承的，也就是说这个类不能有派生类。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base class..."</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">final</span>: <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Child class..."</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// error, 语法错误</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> : <span class="keyword">public</span> Child</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>Child</code> </font>类是被 <font color="orange">final </font>修饰过的，因此 <font color="orange">Child </font>类不允许有派生类 <font color="orange">GrandChild </font>类的继承是非法的，<font color="orange">Child </font>是个断子绝孙的类。</p><h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p><font color="orange">override </font>关键字确保在派生类中声明的重写函数与基类的虚函数有相同的签名，同时也明确表明将会重写基类的虚函数，这样就可以保证重写的虚函数的正确性，也提高了代码的可读性，和 final 一样<font color="orange">这个关键字要写到方法的后面。</font>使用方法如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base class..."</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Child class..."</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> : <span class="keyword">public</span> Child</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Child class..."</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>上述代码中第 13 行和第 22 行就是显示指定了要重写父类的<font color="orange"> test()</font> 方法，使用了<font color="orange"> override </font>关键字之后，假设在重写过程中因为误操作，写错了函数名或者函数参数或者返回值编译器都会提示语法错误，提高了程序的正确性，降低了出错的概率。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++11新特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11新特性 </tag>
            
            <tag> 类继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11新特性--委托构造和继承构造函数</title>
      <link href="/2022/04/24/%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%92%8C%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
      <url>/2022/04/24/%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%92%8C%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>委托构造函数允许使用同一个类中的一个构造函数调用其它的构造函数，从而简化相关变量的初始化。下面举例说明：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() {};</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> max)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;              <span class="comment">// 冗余代码</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;   </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min, <span class="type">int</span> mid)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;             <span class="comment">// 冗余代码</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;  <span class="comment">// 冗余代码</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_middle = mid &lt; max &amp;&amp; mid &gt; min ? mid : <span class="number">50</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_min;</span><br><span class="line">    <span class="type">int</span> m_max;</span><br><span class="line">    <span class="type">int</span> m_middle;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">90</span>, <span class="number">30</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"min: "</span> &lt;&lt; t.m_min &lt;&lt; <span class="string">", middle: "</span> </span><br><span class="line">         &lt;&lt; t.m_middle &lt;&lt; <span class="string">", max: "</span> &lt;&lt; t.m_max &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上面的程序中有三个构造函数，但是这三个函数中都有重复的代码，在 C++11 之前构造函数是不能调用构造函数的，加入了委托构造之后，我们就可以轻松地完成代码的优化了：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() {};</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> max)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min):<span class="built_in">Test</span>(max)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min, <span class="type">int</span> mid):<span class="built_in">Test</span>(max, min)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_middle = mid &lt; max &amp;&amp; mid &gt; min ? mid : <span class="number">50</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_min;</span><br><span class="line">    <span class="type">int</span> m_max;</span><br><span class="line">    <span class="type">int</span> m_middle;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">90</span>, <span class="number">30</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"min: "</span> &lt;&lt; t.m_min &lt;&lt; <span class="string">", middle: "</span> </span><br><span class="line">         &lt;&lt; t.m_middle &lt;&lt; <span class="string">", max: "</span> &lt;&lt; t.m_max &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在修改之后的代码中可以看到，重复的代码全部没有了，并且在一个构造函数中调用了其他的构造函数用于相关数据的初始化，相当于是一个链式调用。在使用委托构造函数的时候还需要注意一些几个问题：</p><ul><li><font color="red">这种链式的构造函数调用不能形成一个闭环（死循环），否则会在运行期抛异常。</font></li><li><font color="red">如果要进行多层构造函数的链式调用，建议将构造函数的调用的写在初始列表中而不是函数体内部，否则编译器会提示形参的重复定义。</font></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">Test</span>(max);<span class="comment">// error, 此处编译器会报错, 提示形参max被重复定义</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><font color="red">在初始化列表中调用了代理构造函数初始化某个类成员变量之后，就不能在初始化列表中再次初始化这个变量了。</font></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误, 使用了委托构造函数就不能再次m_max初始化了</span></span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min) : <span class="built_in">Test</span>(max), <span class="built_in">m_max</span>(max)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h3><p>C++11 中提供的继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大地简化派生类构造函数的编写。先来看没有继承构造函数之前的处理方式：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i) :<span class="built_in">m_i</span>(i) {}</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j) {}</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j), <span class="built_in">m_k</span>(k) {}</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    <span class="type">double</span> m_j;</span><br><span class="line">    string m_k;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Child</span>(<span class="type">int</span> i) :<span class="built_in">Base</span>(i) {}</span><br><span class="line">    <span class="built_in">Child</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">Base</span>(i, j) {}</span><br><span class="line">    <span class="built_in">Child</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">Base</span>(i, j, k) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">Child <span class="title">c</span><span class="params">(<span class="number">520</span>, <span class="number">13.14</span>, <span class="string">"i love you"</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"int: "</span> &lt;&lt; c.m_i &lt;&lt; <span class="string">", double: "</span> </span><br><span class="line">         &lt;&lt; c.m_j &lt;&lt; <span class="string">", string: "</span> &lt;&lt; c.m_k &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过测试代码可以看出，<font color="orange"><code>在子类中初始化从基类继承的类成员，需要在子类中重新定义和基类一致的构造函数</code></font>，这是非常繁琐的，C++11 中通过添加继承构造函数这个新特性完美的解决了这个问题，使得代码更加精简。</p><p>继承构造函数的使用方法是这样的：通过使用<font color="orange"> <code>using 类名::构造函数名</code></font>（其实类名和构造函数名是一样的）来声明使用基类的构造函数，这样子类中就可以不定义相同的构造函数了，直接使用基类的构造函数来构造派生类对象。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i) :<span class="built_in">m_i</span>(i) {}</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j) {}</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j), <span class="built_in">m_k</span>(k) {}</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    <span class="type">double</span> m_j;</span><br><span class="line">    string m_k;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">Child <span class="title">c1</span><span class="params">(<span class="number">520</span>, <span class="number">13.14</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"int: "</span> &lt;&lt; c1.m_i &lt;&lt; <span class="string">", double: "</span> &lt;&lt; c1.m_j &lt;&lt; endl;</span><br><span class="line">    <span class="function">Child <span class="title">c2</span><span class="params">(<span class="number">520</span>, <span class="number">13.14</span>, <span class="string">"i love you"</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"int: "</span> &lt;&lt; c2.m_i &lt;&lt; <span class="string">", double: "</span> </span><br><span class="line">         &lt;&lt; c2.m_j &lt;&lt; <span class="string">", string: "</span> &lt;&lt; c2.m_k &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在修改之后的子类中，没有添加任何构造函数，而是添加了 <font color="orange"><code>using Base::Base;</code> </font>这样就可以在子类中直接继承父类的所有的构造函数，通过他们去构造子类对象了。</p><p>另外如果在子类中隐藏了父类中的同名函数，也可以通过 <font color="orange"><code>using</code> </font>的方式在子类中使用基类中的这些父类函数：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i) :<span class="built_in">m_i</span>(i) {}</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j) {}</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j), <span class="built_in">m_k</span>(k) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"base class: i = "</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i, string str)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"base class: i = "</span> &lt;&lt; i &lt;&lt; <span class="string">", str = "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    <span class="type">double</span> m_j;</span><br><span class="line">    string m_k;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">    <span class="keyword">using</span> Base::func;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"child class: i'am luffy!!!"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">Child <span class="title">c</span><span class="params">(<span class="number">250</span>)</span></span>;</span><br><span class="line">    c.<span class="built_in">func</span>();</span><br><span class="line">    c.<span class="built_in">func</span>(<span class="number">19</span>);</span><br><span class="line">    c.<span class="built_in">func</span>(<span class="number">19</span>, <span class="string">"luffy"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述示例代码输出的结果为：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">child <span class="keyword">class</span>: i<span class="number">'</span>am luffy!!!</span><br><span class="line">base <span class="keyword">class</span>: i = <span class="number">19</span></span><br><span class="line">base <span class="keyword">class</span>: i = <span class="number">19</span>, str = luffy</span><br></pre></td></tr></tbody></table></figure><p>子类中的 <font color="orange"><code>func()</code> </font>函数隐藏了基类中的两个 <font color="orange"><code>func()</code> </font>因此默认情况下通过子类对象只能调用无参的  <font color="orange"><code>func()</code> </font>，在上面的子类代码中添加了  <font color="orange"><code>using Base::func; </code> </font>之后，就可以通过子类对象直接调用父类中被隐藏的带参  <font color="orange"><code>func()</code> </font>函数了。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++11新特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++新特性--智能指针</title>
      <link href="/2022/04/22/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2022/04/22/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="智能指针类型"><a href="#智能指针类型" class="headerlink" title="智能指针类型"></a>智能指针类型</h2><p>在 C++ 中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成内存泄露。解决这个问题最有效的方法是使用智能指针（smart pointer）。<font color="orange"><code>智能指针是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。</code></font></p><p>C++11 中提供了三种智能指针，使用这些智能指针时需要引用头文件<font color="orange"><code>&lt;memory&gt;</code></font>:</p><p><font color="orange"><code>std::shared_ptr</code></font>：共享的智能指针<br><font color="orange"><code>std::unique_ptr</code></font>：独占的智能指针<br><font color="orange"><code>std::weak_ptr</code></font>：弱引用的智能指针，它不共享指针，不能操作资源，是用来监视 <font color="orange"><code>shared_ptr</code> </font>的。</p><h3 id="共享智能指针–shared-ptr"><a href="#共享智能指针–shared-ptr" class="headerlink" title="共享智能指针–shared_ptr"></a>共享智能指针–shared_ptr</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>共享智能指针是指多个智能指针可以同时管理同一块有效的内存，共享智能指针<font color="orange"> shared_ptr</font> 是一个模板类，如果要进行初始化有三种方式：<font color="orange">通过构造函数</font>、<font color="orange">std::make_shared 辅助函数</font>以及<font color="orange"> reset </font>方法。共享智能指针对象初始化完毕之后就指向了要管理的那块堆内存，如果想要查看当前有多少个智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数 <font color="orange">use_count</font>，函数原型如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管理当前对象的 shared_ptr 实例数量，或若无被管理对象则为 0。</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></tbody></table></figure><h5 id="通过构造函数初始化"><a href="#通过构造函数初始化" class="headerlink" title="通过构造函数初始化"></a>通过构造函数初始化</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shared_ptr&lt;T&gt; 类模板中，提供了多种实用的构造函数, 语法格式如下:</span></span><br><span class="line">std::shared_ptr&lt;T&gt; 智能指针名字(创建堆内存);</span><br></pre></td></tr></tbody></table></figure><p>测试代码如下:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">520</span>))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"ptr1管理的内存引用计数: "</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块字符数组对应的堆内存</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">char</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="type">char</span>[<span class="number">12</span>])</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"ptr2管理的内存引用计数: "</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 创建智能指针对象, 不管理任何内存</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3;</span><br><span class="line">    cout &lt;&lt; <span class="string">"ptr3管理的内存引用计数: "</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 创建智能指针对象, 初始化为空</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr4</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"ptr4管理的内存引用计数: "</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试代码输出的结果如下:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ptr1管理的内存引用计数: <span class="number">1</span></span><br><span class="line">ptr2管理的内存引用计数: <span class="number">1</span></span><br><span class="line">ptr3管理的内存引用计数: <span class="number">0</span></span><br><span class="line">ptr4管理的内存引用计数: <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><font color="red">如果智能指针被初始化了一块有效内存，那么这块内存的引用计数 + 1，如果智能指针没有被初始化或者被初始化为 nullptr 空指针，引用计数不会 + 1。另外，不要使用一个原始指针初始化多个 shared_ptr。</font></p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(p)</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p)</span></span>;<span class="comment">// error, 编译不会报错, 运行会出错</span></span><br></pre></td></tr></tbody></table></figure><h5 id="通过拷贝和移动构造函数初始化"><a href="#通过拷贝和移动构造函数初始化" class="headerlink" title="通过拷贝和移动构造函数初始化"></a>通过拷贝和移动构造函数初始化</h5><p>当一个智能指针被初始化之后，就可以通过这个智能指针初始化其他新对象。在创建新对象的时候，对应的拷贝构造函数或者移动构造函数就被自动调用了。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">520</span>))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"ptr1管理的内存引用计数: "</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"ptr2管理的内存引用计数: "</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3 = ptr1;</span><br><span class="line">    cout &lt;&lt; <span class="string">"ptr3管理的内存引用计数: "</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用移动构造函数</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr4</span><span class="params">(std::move(ptr1))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"ptr4管理的内存引用计数: "</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr5 = std::<span class="built_in">move</span>(ptr2);</span><br><span class="line">    cout &lt;&lt; <span class="string">"ptr5管理的内存引用计数: "</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试程序输入的结果:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ptr1管理的内存引用计数: <span class="number">1</span></span><br><span class="line">ptr2管理的内存引用计数: <span class="number">2</span></span><br><span class="line">ptr3管理的内存引用计数: <span class="number">3</span></span><br><span class="line">ptr4管理的内存引用计数: <span class="number">3</span></span><br><span class="line">ptr5管理的内存引用计数: <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure><h5 id="通过-std-make-shared初始化"><a href="#通过-std-make-shared初始化" class="headerlink" title="通过 std::make_shared初始化"></a>通过 std::make_shared初始化</h5><p>通过 C++ 提供的<font color="orange"> <code>std::make_shared()</code> </font>就可以完成内存对象的创建并将其初始化给智能指针，函数原型如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">make_shared</span><span class="params">( Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><font color="orange">T</font>：模板参数的数据类型</li><li><font color="orange">Args&amp;&amp;… args </font>：要初始化的数据，如果是通过 make_shared 创建对象，需按照构造函数的参数列表指定</li></ul><p>测试代码如下:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() </span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"construct Test..."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> x) </span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"construct Test, x = "</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">Test</span>(string str) </span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"construct Test, str = "</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"destruct Test ..."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"ptr1管理的内存引用计数: "</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Test&gt; ptr2 = <span class="built_in">make_shared</span>&lt;Test&gt;();</span><br><span class="line">    cout &lt;&lt; <span class="string">"ptr2管理的内存引用计数: "</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Test&gt; ptr3 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="number">520</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"ptr3管理的内存引用计数: "</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Test&gt; ptr4 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="string">"我是要成为海贼王的男人!!!"</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"ptr4管理的内存引用计数: "</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><font color="red">使用 std::make_shared() 模板函数可以完成内存地址的创建，并将最终得到的内存地址传递给共享智能指针对象管理。如果申请的内存是普通类型，通过函数的（）可完成地址的初始化，如果要创建一个类对象，函数的（）内部需要指定构造对象需要的参数，也就是类构造函数的参数。</font></p></blockquote><h5 id="通过-reset-方法初始化"><a href="#通过-reset-方法初始化" class="headerlink" title="通过 reset 方法初始化"></a>通过 reset 方法初始化</h5><p><font color="orange"> <code>std::shared_ptr::reset</code></font> 有两种功能：</p><ul><li><font color="orange">通过 reset 方法来初始化</font></li><li><font color="orange">调用 reset 会将共享智能指针引用计数减 1。</font></li></ul><p>共享智能指针类提供的<font color="orange"> <code>std::shared_ptr::reset</code></font> 方法函数原型如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Y &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">( Y* ptr )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Y, <span class="keyword">class</span> Deleter &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">( Y* ptr, Deleter d )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Y, <span class="keyword">class</span> Deleter, <span class="keyword">class</span> Alloc &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">( Y* ptr, Deleter d, Alloc alloc )</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><font color="orange">ptr</font>：指向要取得所有权的对象的指针</li><li><font color="orange">d</font>：指向要取得所有权的对象的指针</li><li><font color="orange">aloc</font>：内部存储所用的分配器aloc</li></ul><p>测试代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3 = ptr1;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr4 = ptr1;</span><br><span class="line">    cout &lt;&lt; <span class="string">"ptr1管理的内存引用计数: "</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"ptr2管理的内存引用计数: "</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"ptr3管理的内存引用计数: "</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"ptr4管理的内存引用计数: "</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ptr4.<span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"ptr1管理的内存引用计数: "</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"ptr2管理的内存引用计数: "</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"ptr3管理的内存引用计数: "</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"ptr4管理的内存引用计数: "</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr5;</span><br><span class="line">    ptr5.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">"ptr5管理的内存引用计数: "</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试代码输入的结果:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ptr1管理的内存引用计数: <span class="number">4</span></span><br><span class="line">ptr2管理的内存引用计数: <span class="number">4</span></span><br><span class="line">ptr3管理的内存引用计数: <span class="number">4</span></span><br><span class="line">ptr4管理的内存引用计数: <span class="number">4</span></span><br><span class="line">    </span><br><span class="line">ptr1管理的内存引用计数: <span class="number">3</span></span><br><span class="line">ptr2管理的内存引用计数: <span class="number">3</span></span><br><span class="line">ptr3管理的内存引用计数: <span class="number">3</span></span><br><span class="line">ptr4管理的内存引用计数: <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">ptr5管理的内存引用计数: <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><font color="red">对于一个未初始化的共享智能指针，可以通过 reset 方法来初始化，当智能指针中有值的时候，调用 reset 会使引用计数减 1。</font></p></blockquote><hr><h4 id="获取原始指针"><a href="#获取原始指针" class="headerlink" title="获取原始指针"></a>获取原始指针</h4><p>对应基础数据类型来说，通过操作智能指针和操作智能指针管理的内存效果是一样的，<font color="red">可以直接完成数据的读写</font>。但是如果共享智能指针管理的是一个对象，那么就需要<font color="red">取出原始内存的地址再操作</font>，可以调用共享智能指针类提供的 <font color="orange">get () </font>方法得到原始地址，其函数原型如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>测试代码如下:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> len = <span class="number">128</span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">char</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">char</span>[len])</span></span>;</span><br><span class="line">    <span class="comment">// 得到指针的原始地址</span></span><br><span class="line">    <span class="type">char</span>* add = ptr.<span class="built_in">get</span>();</span><br><span class="line">    <span class="built_in">memset</span>(add, <span class="number">0</span>, len);</span><br><span class="line">    <span class="built_in">strcpy</span>(add, <span class="string">"我是要成为海贼王的男人!!!"</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"string: "</span> &lt;&lt; add &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; *p.<span class="built_in">get</span>() &lt;&lt; <span class="string">"  "</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="指定删除器"><a href="#指定删除器" class="headerlink" title="指定删除器"></a>指定删除器</h4><p>当智能指针管理的内存对应的引用计数变为 0 的时候，这块内存就会被智能指针析构掉了。另外，我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为删除器，<font color="orange">这个删除器函数本质是一个回调函数</font>，我们只需要进行实现，其调用是由智能指针完成的。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义删除器函数，释放int型内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteIntPtr</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    cout &lt;&lt; <span class="string">"int 型内存被释放了..."</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">250</span>), deleteIntPtr)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>删除器函数也可以是 lambda 表达式，因此代码也可以写成下面这样：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">250</span>), [](<span class="type">int</span>* p) {<span class="keyword">delete</span> p; })</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上面的代码中，<font color="orange">lambda表达式的参数就是智能指针管理的内存的地址，有了这个地址之后函数体内部就可以完成删除操作了。</font>font&gt;</p><p>在 C++11 中使用<font color="orange"> shared_ptr</font> 管理动态数组时，需要指定删除器，因为 <font color="orange">std::shared_ptr的默认删除器不支持数组对象</font>，具体的处理代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], default_delete&lt;<span class="type">int</span>[]&gt;())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>另外，我们还可以自己封装一个 make_shared_array 方法来让 shared_ptr 支持数组，代码如下:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">make_share_array</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 返回匿名对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T[size], <span class="built_in">default_delete</span>&lt;T[]&gt;());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_share_array</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;<span class="type">char</span>&gt; ptr2 = <span class="built_in">make_share_array</span>&lt;<span class="type">char</span>&gt;(<span class="number">128</span>);</span><br><span class="line">    cout &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>shared_ptr使用注意事项：</p><ul><li>不能使用一个原始地址初始化多个共享智能指针</li><li>函数不能返回管理了this的共享智能指针对象</li><li>共享智能指针不能循环引用</li></ul><h3 id="独占智能指针–unique-ptr"><a href="#独占智能指针–unique-ptr" class="headerlink" title="独占智能指针–unique_ptr"></a>独占智能指针–unique_ptr</h3><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p><font color="orange">std::unique_ptr</font> 是一个独占型的智能指针，它不允许其他的智能指针共享其内部的指针，可以通过它的构造函数初始化一个独占智能指针对象，但是不允许通过赋值将一个 <font color="orange">unique_ptr</font> 赋值给另一个 <font color="orange">unique_ptr</font>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过构造函数初始化对象</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="comment">// error, 不允许将一个unique_ptr赋值给另一个unique_ptr</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1;</span><br></pre></td></tr></tbody></table></figure><p><font color="orange">std::unique_ptr 不允许复制</font>，但是可以通过<font color="orange">函数返回</font>给其他的 <font color="orange">std::unique_ptr</font>，还可以通过 <font color="orange">std::move </font>来<font color="orange">转移</font>font&gt;给其他的<font color="orange"> std::unique_ptr</font>，这样原始指针的所有权就被转移了，这个原始指针还是被独占的。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">520</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 通过构造函数初始化</span></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="comment">// 通过转移所有权的方式初始化</span></span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr3 = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>unique_ptr 独占智能指针类也有一个 reset 方法与shared_ptr::reset作用一致，函数原型如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">( pointer ptr = pointer() )</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p><font color="red">使用 reset 方法可以让 unique_ptr 解除对原始内存的管理，也可以用来初始化一个独占的智能指针。</font></p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line"></span><br><span class="line">    ptr1.<span class="built_in">reset</span>();</span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><font color="orange">ptr1.reset();</font> 解除对原始内存的管</li><li><font color="orange">ptr2.reset(new int(250));</font> 重新指定智能指针管理的原始内存</li></ul><h4 id="获取原始指针-1"><a href="#获取原始指针-1" class="headerlink" title="获取原始指针"></a>获取原始指针</h4><p>如果想要获取独占智能指针管理的原始地址，可以调用 <font color="red">get () </font>方法，函数原型如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line"></span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>));</span><br><span class="line">    cout &lt;&lt; *ptr2.<span class="built_in">get</span>() &lt;&lt; endl;<span class="comment">// 得到内存地址中存储的实际数值 250</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="指定删除器-1"><a href="#指定删除器-1" class="headerlink" title="指定删除器"></a>指定删除器</h4><p>unique_ptr 指定删除器和 shared_ptr 指定删除器是有区别的，unique_ptr 指定删除器的时候需要确定删除器的类型，所以不能像 shared_ptr 那样直接指定删除器，举例说明：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) {<span class="keyword">delete</span> p; })</span></span>;<span class="comment">// ok</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) {<span class="keyword">delete</span> p; })</span></span>;<span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>*);</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>, func_ptr&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) {<span class="keyword">delete</span> p; })</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上面的代码中第 7 行，<font color="orange">func_ptr</font> 的类型和 <font color="orange">lambda表达式</font>的类型是一致的。在 lambda 表达式没有捕获任何变量的情况下是正确的，如果捕获了变量，编译时则会报错：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>*);</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>, func_ptr&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [&amp;](<span class="type">int</span>*p) {<span class="keyword">delete</span> p; })</span></span>;<span class="comment">// error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的代码中错误原因是这样的，在 lambda 表达式没有捕获任何外部变量时，可以直接转换为函数指针，一旦捕获了就无法转换了，如果想要让编译器成功通过编译，那么需要使用可调用<font color="orange">对象包装器</font>来处理声明的函数指针：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>*);</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>, function&lt;<span class="type">void</span>(<span class="type">int</span>*)&gt;&gt; <span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>), [&amp;](<span class="type">int</span>*p) {<span class="keyword">delete</span> p; });</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="弱引用智能指针"><a href="#弱引用智能指针" class="headerlink" title="弱引用智能指针"></a>弱引用智能指针</h3><h4 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h4><p>弱引用智能指针<font color="orange"> std::weak_ptr </font>可以看做是 <font color="orange">shared_ptr</font> 的助手，它不管理 <font color="orange">shared_ptr </font>内部的指针。<font color="orange">std::weak_ptr </font>没有重载操作符<font color="orange">. </font>和 <font color="orange">-&gt;</font>，因为它不共享指针，不能操作资源，所以<font color="red">它的构造不会增加引用计数，析构也不会减少引用计数</font>，它的主要作用就是作为一个<font color="orange">旁观者监视 shared_ptr 中管理的资源是否存在</font>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">weak_ptr</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="built_in">weak_ptr</span> (<span class="type">const</span> weak_ptr&amp; x) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="built_in">weak_ptr</span> (<span class="type">const</span> weak_ptr&lt;U&gt;&amp; x) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">// 通过shared_ptr对象构造</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="built_in">weak_ptr</span> (<span class="type">const</span> shared_ptr&lt;U&gt;&amp; x) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></tbody></table></figure><p>在 C++11 中，<font color="orange">weak_ptr </font>的初始化可以通过以上提供的构造函数来完成初始化，具体使用方法如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp1;</span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp2</span><span class="params">(wp1)</span></span>;</span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp3</span><span class="params">(sp)</span></span>;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp4;</span><br><span class="line">    wp4 = sp;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp5;</span><br><span class="line">    wp5 = wp3;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><font color="orange">weak_ptr&lt;int&gt; wp1;</font>构造了一个空 <font color="orange">weak_ptr </font>对象</li><li><font color="orange">weak_ptr&lt;int&gt; wp2(wp1);</font> 通过一个空 <font color="orange">weak_ptr </font>对象构造了另一个空 <font color="orange">weak_ptr </font>对象</li><li><font color="orange">weak_ptr&lt;int&gt;wp3(sp);</font>font&gt; 通过一个 <font color="orange">shared_ptr </font>对象构造了一个可用的 <font color="orange">weak_ptr </font>实例对象</li><li><font color="orange">wp4 = sp;</font>font&gt; 通过一个 <font color="orange">shared_ptr </font>对象构造了一个可用的 <font color="orange">weak_ptr </font>实例对象（这是一个隐式类型转换）</li><li><font color="orange">wp5 = wp3; </font>通过一个 <font color="orange">weak_ptr</font> 对象构造了一个可用的 weak_ptr 实例对象</li></ul><h4 id="其他常用方法"><a href="#其他常用方法" class="headerlink" title="其他常用方法"></a>其他常用方法</h4><h5 id="use-count"><a href="#use-count" class="headerlink" title="use_count()"></a>use_count()</h5><p>通过调用 <font color="orange">std::weak_ptr</font>font&gt; 类提供的 <font color="orange">use_count() </font>方法可以获得当前所观测资源的引用计数，函数原型如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数返回所监测的资源的引用计数</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>修改一下上面的测试程序，添加打印资源引用计数的代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp1;</span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp2</span><span class="params">(wp1)</span></span>;</span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp3</span><span class="params">(sp)</span></span>;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp4;</span><br><span class="line">    wp4 = sp;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp5;</span><br><span class="line">    wp5 = wp3;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"use_count: "</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"wp1: "</span> &lt;&lt; wp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"wp2: "</span> &lt;&lt; wp2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"wp3: "</span> &lt;&lt; wp3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"wp4: "</span> &lt;&lt; wp4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"wp5: "</span> &lt;&lt; wp5.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试程序输出的结果为:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use_count:</span><br><span class="line">wp1: <span class="number">0</span></span><br><span class="line">wp2: <span class="number">0</span></span><br><span class="line">wp3: <span class="number">1</span></span><br><span class="line">wp4: <span class="number">1</span></span><br><span class="line">wp5: <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>通过打印的结果可以知道，虽然弱引用智能指针 <font color="orange">wp3</font>、<font color="orange">wp4</font>、<font color="orange">wp5 </font>监测的资源是同一个，但是它的引用计数并没有发生任何的变化，也进一步证明了 <font color="orange">weak_ptr只是监测资源，并不管理资源。</font></p><h5 id="expired"><a href="#expired" class="headerlink" title="expired()"></a>expired()</h5><p>通过调用 <font color="orange">std::weak_ptr</font> 类提供的 <font color="orange">expired()</font> 方法来判断观测的资源是否已经被释放，函数原型如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回true表示资源已经被释放, 返回false表示资源没有被释放</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">expired</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>函数的使用方法如下:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">shared</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">weak</span><span class="params">(shared)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"1. weak "</span> &lt;&lt; (weak.<span class="built_in">expired</span>() ? <span class="string">"is"</span> : <span class="string">"is not"</span>) &lt;&lt; <span class="string">" expired"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared.<span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"2. weak "</span> &lt;&lt; (weak.<span class="built_in">expired</span>() ? <span class="string">"is"</span> : <span class="string">"is not"</span>) &lt;&lt; <span class="string">" expired"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试代码输出的结果:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> weak is <span class="keyword">not</span> expired</span><br><span class="line"><span class="number">2.</span> weak is expired</span><br></pre></td></tr></tbody></table></figure><p><font color="orange">weak_ptr </font>监测的就是 <font color="orange">shared_ptr </font>管理的资源，当共享智能指针调用 <font color="orange">shared.reset(); </font>之后管理的资源被释放，因此<font color="orange"> weak.expired()</font> 函数的结果返回 <font color="orange">true</font>，表示监测的资源已经不存在了。</p><h5 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h5><p>通过调用 <font color="orange">std::weak_ptr</font> 类提供的<font color="orange"> lock() </font>方法来获取管理所监测资源的 <font color="orange">shared_ptr </font>对象，函数原型如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;element_type&gt; <span class="title">lock</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>函数的使用方法如下:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; sp1, sp2;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp;</span><br><span class="line"></span><br><span class="line">    sp1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);</span><br><span class="line">    wp = sp1;</span><br><span class="line">    sp2 = wp.<span class="built_in">lock</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"use_count: "</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    sp1.<span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"use_count: "</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    sp1 = wp.<span class="built_in">lock</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"use_count: "</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"*sp1: "</span> &lt;&lt; *sp1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"*sp2: "</span> &lt;&lt; *sp2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试代码输出的结果为:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use_count: <span class="number">2</span></span><br><span class="line">use_count: <span class="number">1</span></span><br><span class="line">use_count: <span class="number">2</span></span><br><span class="line">*sp1: <span class="number">520</span></span><br><span class="line">*sp2: <span class="number">520</span></span><br></pre></td></tr></tbody></table></figure><ul><li><font color="orange">sp2 = wp.lock(); </font>通过调用 <font color="orange">lock() </font>方法得到一个用于管理 <font color="orange">weak_ptr </font>对象所监测的资源的共享智能指针对象，使用这个对象初始化 <font color="orange">sp2</font>，此时所监测资源的引用计数为 <font color="orange">2</font></li><li><font color="orange">sp1.reset();</font> 共享智能指针<font color="orange"> sp1</font>font&gt; 被重置，<font color="orange">weak_ptr </font>对象所监测的资源的引用计数减1</li><li><font color="orange">sp1 = wp.lock();</font><font color="cornflowerblue">sp1</font> 重新被初始化，并且管理的还是 <font color="orange">weak_ptr </font>font&gt;对象所监测的资源，因此引用计数加 1</li><li>共享智能指针对象 <font color="orange">sp1 </font>和 <font color="orange">sp2 </font>管理的是同一块内存，因此最终打印的内存中的结果是相同的，都是 <font color="orange">520</font></li></ul><h5 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h5><p>通过调用 <font color="orange">std::weak_ptr </font>类提供的 <font color="orange">reset() </font>方法来清空对象，使其不监测任何资源，函数原型如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>函数的使用是非常简单的，示例代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"1. wp "</span> &lt;&lt; (wp.<span class="built_in">expired</span>() ? <span class="string">"is"</span> : <span class="string">"is not"</span>) &lt;&lt; <span class="string">" expired"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    wp.<span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"2. wp "</span> &lt;&lt; (wp.<span class="built_in">expired</span>() ? <span class="string">"is"</span> : <span class="string">"is not"</span>) &lt;&lt; <span class="string">" expired"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><p>测试代码输出的结果为:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> wp is <span class="keyword">not</span> expired</span><br><span class="line"><span class="number">2.</span> wp is expired</span><br></pre></td></tr></tbody></table></figure><p><font color="orange">weak_ptr </font>对象 <font color="orange">sp </font>被重置之后 <font color="orange">wp.reset();</font> 变成了空对象，不再监测任何资源，因此<font color="orange"> wp.expired()</font> 返回 <font color="orange">true</font></p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><h5 id="返回管理-this-的-shared-ptr"><a href="#返回管理-this-的-shared-ptr" class="headerlink" title="返回管理 this 的 shared_ptr"></a>返回管理 this 的 shared_ptr</h5><p>如果在一个类中编写了一个函数，通过这个得到管理当前对象的共享智能指针，我们可能会写出如下代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">getSharedPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Test&gt;(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"class Test is disstruct ..."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> Test)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"use_count: "</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;Test&gt; sp2 = sp1-&gt;<span class="built_in">getSharedPtr</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"use_count: "</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>执行上面的测试代码，运行中会出现异常，在终端还是能看到对应的日志输出：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use_count: <span class="number">1</span></span><br><span class="line">use_count: <span class="number">1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> is disstruct ...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> is disstruct ...</span><br></pre></td></tr></tbody></table></figure><p>通过输出的结果可以看到<font color="orange">一个对象被析构了两次</font>，其原因是这样的：<font color="red">在这个例子中使用同一个指针 this 构造了两个智能指针对象 sp1 和 sp2，这二者之间是没有任何关系的，因为 sp2 并不是通过 sp1 初始化得到的实例对象。在离开作用域之后 this 将被构造的两个智能指针各自析构，导致重复析构的错误。</font></p><p>这个问题可以通过 <font color="red">weak_ptr </font>来解决，通过 <font color="red">wek_ptr </font>返回管理 <font color="red">this </font>资源的共享智能指针对象 <font color="red">shared_ptr</font>。C++11 中为我们提供了一个模板类叫做 <font color="orange">std::enable_shared_from_this&lt;T&gt;</font>，这个类中有一个方法叫做 <font color="orange">shared_from_this()</font>，通过这个方法可以返回一个共享智能指针，在函数的内部就是使用 <font color="orange">weak_ptr </font>来监测 this 对象，并通过调用 <font color="orange">weak_ptr </font>的 <font color="orange">lock()</font> 方法返回一个 <font color="orange">shared_ptr </font>对象。</p><p>修改之后的代码为：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> : <span class="keyword">public</span> enable_shared_from_this&lt;Test&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">getSharedPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"class Test is disstruct ..."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> Test)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"use_count: "</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;Test&gt; sp2 = sp1-&gt;<span class="built_in">getSharedPtr</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"use_count: "</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试代码输出的结果为:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use_count: <span class="number">1</span></span><br><span class="line">use_count: <span class="number">2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> is disstruct ...</span><br></pre></td></tr></tbody></table></figure><p>最后需要强调一个细节：<font color="red">在调用 enable_shared_from_this 类的 shared_from_this () 方法之前，必须要先初始化函数内部 weak_ptr 对象，否则该函数无法返回一个有效的 shared_ptr 对象（具体处理方法可以参考上面的示例代码）。</font></p><h5 id="解决循环引用问题"><a href="#解决循环引用问题" class="headerlink" title="解决循环引用问题"></a>解决循环引用问题</h5><p>智能指针如果循环引用会导致内存泄露，比如下面的例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TA</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TA</span></span><br><span class="line">{</span><br><span class="line">    shared_ptr&lt;TB&gt; bptr;</span><br><span class="line">    ~<span class="built_in">TA</span>()</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"class TA is disstruct ..."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TB</span></span><br><span class="line">{</span><br><span class="line">    shared_ptr&lt;TA&gt; aptr;</span><br><span class="line">    ~<span class="built_in">TB</span>()</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"class TB is disstruct ..."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">shared_ptr&lt;TA&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> TA)</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;TB&gt; <span class="title">bp</span><span class="params">(<span class="keyword">new</span> TB)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"TA object use_count: "</span> &lt;&lt; ap.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"TB object use_count: "</span> &lt;&lt; bp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ap-&gt;bptr = bp;</span><br><span class="line">    bp-&gt;aptr = ap;</span><br><span class="line">    cout &lt;&lt; <span class="string">"TA object use_count: "</span> &lt;&lt; ap.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"TB object use_count: "</span> &lt;&lt; bp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">testPtr</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试程序输出的结果如下:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TA object use_count: <span class="number">1</span></span><br><span class="line">TB object use_count: <span class="number">1</span></span><br><span class="line">TA object use_count: <span class="number">2</span></span><br><span class="line">TB object use_count: <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure><p>在测试程序中，共享智能指针 <font color="orange">ap</font>、<font color="orange">bp </font>对 <font color="orange">TA</font>、<font color="orange">TB</font> 实例对象的引用计数变为<font color="orange">2</font>，<font color="orange">在共享智能指针离开作用域之后引用计数只能减为1</font>，这种情况下不会去删除智能指针管理的内存，导致类 <font color="orange">TA</font>、<font color="orange">TB </font>的实例对象不能被析构，最终造成内存泄露。通过使用 <font color="orange">weak_ptr </font>font&gt;可以解决这个问题，只要将类 <font color="orange">TA </font>或者 <font color="orange">TB </font>的任意一个成员改为 <font color="orange">weak_ptr</font>，修改之后的代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TA</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TA</span></span><br><span class="line">{</span><br><span class="line">    weak_ptr&lt;TB&gt; bptr;</span><br><span class="line">    ~<span class="built_in">TA</span>()</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"class TA is disstruct ..."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TB</span></span><br><span class="line">{</span><br><span class="line">    shared_ptr&lt;TA&gt; aptr;</span><br><span class="line">    ~<span class="built_in">TB</span>()</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"class TB is disstruct ..."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">shared_ptr&lt;TA&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> TA)</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;TB&gt; <span class="title">bp</span><span class="params">(<span class="keyword">new</span> TB)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"TA object use_count: "</span> &lt;&lt; ap.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"TB object use_count: "</span> &lt;&lt; bp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ap-&gt;bptr = bp;</span><br><span class="line">    bp-&gt;aptr = ap;</span><br><span class="line">    cout &lt;&lt; <span class="string">"TA object use_count: "</span> &lt;&lt; ap.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"TB object use_count: "</span> &lt;&lt; bp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">testPtr</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序输出的结果:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TA object use_count: <span class="number">1</span></span><br><span class="line">TB object use_count: <span class="number">1</span></span><br><span class="line">TA object use_count: <span class="number">2</span></span><br><span class="line">TB object use_count: <span class="number">1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TB</span> is disstruct ...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TA</span> is disstruct ...</span><br></pre></td></tr></tbody></table></figure><p>通过输出的结果可以看到类 <font color="orange">TA </font>或者 <font color="orange">TB </font>的对象被成功析构了。</p><p>上面程序中，在对类 <font color="orange">TA </font>成员赋值时 <font color="orange">ap-&gt;bptr = bp; </font>由于 <font color="orange">bptr </font>是 <font color="orange">weak_ptr </font>类型，这个赋值操作并不会增加引用计数，所以 <font color="orange">bp </font>的引用计数仍然为 <font color="orange">1</font>，在离开作用域之后 <font color="orange">bp </font>的引用计数减为 <font color="orange">0</font>，类 TB 的实例对象被析构。</p><p>在类 <font color="orange">TB </font>的实例对象被析构的时候，内部的 <font color="orange">aptr </font>也被析构，其对 <font color="orange">TA </font>对象的管理解除，内存的引用计数减为 <font color="orange">1</font>，当共享智能指针 <font color="orange">ap </font>离开作用域之后，对 <font color="orange">TA </font>对象的管理也解除了，内存的引用计数减为 <font color="orange">0</font>，类 <font color="orange">TA </font>的实例对象被析构。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++11新特性 </category>
          
          <category> 指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11新特性--右值引用</title>
      <link href="/2022/04/21/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
      <url>/2022/04/21/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><h4 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h4><p>C++11 增加了一个新的类型，称为<font color="orange">右值引用</font>（ R-value reference），标记为 <font color="orange">&amp;&amp;</font>。在介绍<font color="orange">右值引用</font>类型之前先要了解什么是<font color="orange">左值</font>和<font color="orange">右值</font>：</p><ul><li><font color="orange">lvalue </font>是 <font color="cornflowerblue">loactor value</font> 的缩写，<font color="orange">rvalue </font>是 <font color="orange">read value</font> 的缩写</li><li><font color="orange">左值</font>是<font color="red">指存储在内存中、有明确存储地址（可取地址）的数据；</font></li><li><font color="orange">右值</font>是<font color="red">指可以提供数据值的数据（不可取地址）</font></li></ul><p>通过描述可以看出，区分左值与右值的便捷方法是：<font color="red">可以对表达式取地址（&amp;）就是左值，否则为右值 </font>。<font color="orange">所有有名字的变量或对象都是左值，而右值是匿名的。</font></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">1314</span>;</span><br><span class="line">a = b;</span><br></pre></td></tr></tbody></table></figure><p>一般情况下，位于<font color="orange"> =</font> 前的表达式为左值，位于 <font color="orange">= </font>后边的表达式为右值。也就是说例子中的<font color="orange"> a, b</font> 为左值，<font color="orange">520,1314 </font>为右值。<font color="orange">a=b</font> 是一种特殊情况，在这个表达式中<font color="orange"> a, b </font>都是左值，因为变量<font color="orange"> b</font> 是可以被取地址的，不能视为右值。</p><hr><p>C++11 中右值可以分为两种：一个是<font color="orange">将亡值</font>（ xvalue, expiring value），另一个则是<font color="orange">纯右值</font>（ prvalue, PureRvalue）：</p><p><font color="orange">纯右值</font>：<font color="red">非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和 lambda 表达式等</font><br><font color="orange">将亡值</font>：<font color="red">与右值引用相关的表达式，比如，T&amp;&amp; 类型函数的返回值、 std::move 的返回值等。</font></p><hr><h4 id="右值引用-1"><a href="#右值引用-1" class="headerlink" title="右值引用"></a>右值引用</h4><p>右值引用就是对一个右值进行引用的类型。因为右值是匿名的，所以我们只能通过引用的方式找到它。<font color="orange">无论声明左值引用还是右值引用都必须立即进行初始化，因为引用类型本身并不拥有所绑定对象的内存，只是该对象的一个别名。通过右值引用的声明，该右值又“重获新生”</font>，<font color="red">其生命周期与右值引用类型变量的生命周期一样，只要该右值引用类型变量还活着，该右值临时量将会一直存活下去。</font></p><p>关于右值引用的使用，参考代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp;&amp; value = <span class="number">520</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>()</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"construct: my name is jerry"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; a)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"copy construct: my name is tom"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Test</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a1;</span><br><span class="line">    <span class="type">int</span> &amp;&amp;a2 = a1;        <span class="comment">// error</span></span><br><span class="line">    Test&amp; t = <span class="built_in">getObj</span>();   <span class="comment">// error</span></span><br><span class="line">    Test &amp;&amp; t = <span class="built_in">getObj</span>();</span><br><span class="line">    <span class="type">const</span> Test&amp; t = <span class="built_in">getObj</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>在上面的例子中<font color="orange"> int&amp;&amp; value = 520;</font> 里面<font color="orange"> 520 </font>是纯右值，<font color="orange">value </font>是对字面量 <font color="orange">520 </font>这个右值的引用。</li><li>在 <font color="orange">int &amp;&amp;a2 = a1; </font>中 <font color="orange">a1</font> 虽然写在了 <font color="orange">= </font>右边，但是它仍然是一个左值，<font color="orange">使用左值初始化一个右值引用类型是不合法的。</font></li><li>在 <font color="orange">Test&amp; t = getObj()</font> 这句代码中语法是错误的，<font color="orange">右值不能给普通的左值引用赋值。</font></li><li>在 <font color="orange">Test &amp;&amp; t = getObj();</font> 中 <font color="orange">getObj() </font>返回的<font color="orange">临时对象</font>被称之为<font color="orange">将亡值</font>，<font color="orange">t </font>是这个<font color="orange">将亡值</font>的右值引用。</li><li><font color="orange">const Test&amp; t = getObj() </font>这句代码的语法是正确的，<font color="orange">常量左值引用是一个万能引用类型，它可以接受左值、右值、常量左值和常量右值。</font></li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>在 C++ 中在进行对象赋值操作的时候，很多情况下会发生对象之间的深拷贝，如果堆内存很大，这个拷贝的代价也就非常大，在某些情况下，如果想要<font color="orange">避免对象的深拷贝，就可以使用右值引用进行性能的优化</font>。</p><p>再来修改一下上面的实例代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>))</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"construct: my name is jerry"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; a) : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*a.m_num))</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"copy construct: my name is tom"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">delete</span> m_num;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* m_num;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Test t = <span class="built_in">getObj</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"t.m_num: "</span> &lt;&lt; *t.m_num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>测试代码执行的结果为:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">construct: my name is jerry</span><br><span class="line">copy construct: my name is tom</span><br><span class="line">t.m_num: <span class="number">100</span></span><br></pre></td></tr></tbody></table></figure><p>通过输出的结果可以看到调用 <font color="orange">Test t = getObj();</font> 的时候调用拷贝构造函数对返回的临时对象进行了深拷贝得到了对象 <font color="orange">t</font>，在<font color="orange"> getObj()</font> 函数中创建的对象虽然进行了内存的申请操作，但是没有使用就释放掉了。如果能够使用临时对象已经申请的资源，既能节省资源，还能节省资源申请和释放的时间，如果要执行这样的操作就需要使用右值引用了，<font color="red">右值引用具有移动语义，移动语义可以将资源（堆、系统对象等）通过浅拷贝从一个对象转移到另一个对象这样就能减少不必要的临时对象的创建、拷贝以及销毁，可以大幅提高 C++ 应用程序的性能。</font></p><hr><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>))</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"construct: my name is jerry"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; a) : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*a.m_num))</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"copy construct: my name is tom"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加移动构造函数</span></span><br><span class="line">    <span class="built_in">Test</span>(Test&amp;&amp; a) : <span class="built_in">m_num</span>(a.m_num)</span><br><span class="line">    {</span><br><span class="line">        a.m_num = <span class="literal">nullptr</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"move construct: my name is sunny"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">delete</span> m_num;</span><br><span class="line">        cout &lt;&lt; <span class="string">"destruct Test class ..."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* m_num;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Test t = <span class="built_in">getObj</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"t.m_num: "</span> &lt;&lt; *t.m_num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>测试代码执行的结果如下:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">construct: my name is jerry</span><br><span class="line">move construct: my name is sunny</span><br><span class="line">destruct Test <span class="keyword">class</span> ...</span><br><span class="line">t.m_num: <span class="number">100</span></span><br><span class="line">destruct Test <span class="keyword">class</span> ...</span><br></pre></td></tr></tbody></table></figure><p>通过修改，在上面的代码给 <font color="orange">Test </font>类添加了<font color="orange">移动构造函数（参数为右值引用类型）</font>，这样在进行 <font color="orange">Test t = getObj(); </font>操作的时候并没有调用拷贝构造函数进行深拷贝，而是调用了移动构造函数，在这个函数中只是进行了浅拷贝，没有对临时对象进行深拷贝，提高了性能。</p><p>如果不使用移动构造，<font color="orange"><del>也没有提供深拷贝构造函数</del></font>，在执行<font color="orange"> Test t = getObj() </font>的时候也是进行了浅拷贝，但是当临时对象被析构的时候，类成员指针 <font color="orange">int* m_num;</font> 指向的内存也就被析构了，对象 t 也就无法访问这块内存地址了。</p><p>在测试程序中 <font color="orange">getObj() </font>的返回值就是一个将亡值，也就是说是一个右值，在进行赋值操作的时候如果 <font color="orange">= </font>右边是一个右值，那么移动构造函数就会被调用。<font color="orange">移动构造中使用了右值引用，会将临时对象中的堆内存地址的所有权转移给对象t，这块内存被成功续命，因此在t对象中还可以继续使用这块内存。</font></p><hr><blockquote><p><font color="red">对于需要动态申请大量资源的类，应该设计移动构造函数，以提高程序效率。需要注意的是，我们一般在提供移动构造函数的同时，也会提供常量左值引用的拷贝构造函数，以保证移动不成还可以使用拷贝构造函数</font><font color="red">。</font></p></blockquote><h3 id="amp-amp-的特性"><a href="#amp-amp-的特性" class="headerlink" title="&amp;&amp;的特性"></a>&amp;&amp;的特性</h3><p>在 C++ 中，并不是所有情况下 <font color="orange">&amp;&amp;</font> 都代表是一个右值引用，具体的场景体现在模板和自动类型推导中，如果是模板参数需要指定为<font color="orange"> T&amp;&amp;</font>，如果是自动类型推导需要指定为 <font color="orange">auto &amp;&amp;</font>，在这两种场景下 <font color="orange">&amp;&amp; </font>被称作<font color="orange">未定的引用类型</font>。另外还有一点需要额外注意 <font color="orange">const T&amp;&amp;</font> 表示一个右值引用，不是未定引用类型。</p><p>先来看第一个例子，在函数模板中使用<font color="orange"> &amp;&amp;</font>:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>); </span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">f</span>(x); </span><br><span class="line"><span class="built_in">f1</span>(x);</span><br></pre></td></tr></tbody></table></figure><p>在上面的例子中函数模板进行了自动类型推导，需要通过传入的实参来确定参数 param 的实际类型。</p><ul><li>第 4 行中，对于<font color="orange"> f(10) </font>来说传入的实参 10 是右值，因此 <font color="orange">T&amp;&amp;</font> 表示右值引用</li><li>第 6 行中，对于 <font color="orange">f(x)</font> 来说传入的实参是 x 是左值，因此 <font color="orange">T&amp;&amp; </font>表示左值引用</li><li>第 7 行中，<font color="orange">f1(x) </font>的参数是 <font color="orange">const T&amp;&amp;</font> 不是未定引用类型，不需要推导，本身就表示一个右值引用</li></ul><p>再来看第二个例子:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> x = <span class="number">520</span>, y = <span class="number">1314</span>;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; v1 = x;</span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; v2 = <span class="number">250</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(x)&amp;&amp; v3 = y;   <span class="comment">// error</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"v1: "</span> &lt;&lt; v1 &lt;&lt; <span class="string">", v2: "</span> &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li>第 4 行中 <font color="orange">auto&amp;&amp; </font>表示一个整形的左值引用</li><li>第 5 行中 <font color="orange">auto&amp;&amp;</font> 表示一个整形的右值引用</li><li>第 6 行中 <font color="orange">decltype(x)&amp;&amp;</font> 等价于 <font color="orange">int&amp;</font>&amp; 是一个右值引用不是未定引用类型，y 是一个左值，<font color="orange">不能使用左值初始化一个右值引用类型。</font></li></ul><p>由于上述代码中存在 <font color="orange">T&amp;&amp; </font>或者 <font color="orange">auto&amp;&amp;</font> 这种未定引用类型，当它作为参数时，有可能被一个右值引用初始化，也有可能被一个左值引用初始化，在进行类型推导时右值引用类型（&amp;&amp;）会发生变化，这种变化被称为<font color="orange">引用折叠</font>。在 C++11 中引用折叠的规则如下：</p><ul><li><font color="red">通过右值推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个右值引用类型</font></li><li><font color="red">通过非右值（右值引用、左值、左值引用、常量右值引用、常量左值引用）推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个左值引用类型</font></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; a1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; bb = a1;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; bb1 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a2 = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;a3 = a2;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; cc = a3;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; cc1 = a2;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; s1 = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; s2 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; dd = s1;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; ee = s2;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp;&amp; x = <span class="number">5</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>第 2 行：<font color="orange">a1 </font>为右值引用，推导出的 <font color="orange">bb </font>为<font color="orange">左值引用</font>类型</li><li>第 3 行：<font color="orange">5 </font>为右值，推导出的 <font color="orange">bb1 </font>为<font color="orange">右值引用</font>类型</li><li>第 7 行：<font color="orange">a3 </font>为左值引用，推导出的 <font color="orange">cc </font>为<font color="orange">左值引用</font>类型</li><li>第 8 行：<font color="orange">a2 </font>为左值，推导出的 <font color="orange">cc1 </font>为<font color="orange">左值引用</font>类型</li><li>第 12 行：<font color="orange">s1 </font>为常量左值引用，推导出的 <font color="orange">dd </font>为<font color="orange">常量左值引用</font>类型</li><li>第 13 行：<font color="orange">s2 </font>为常量右值引用，推导出的 <font color="orange">ee </font>为<font color="orange">常量左值引用</font>类型</li><li>第 15 行：<font color="orange">x </font>为右值引用，不需要推导，只能通过右值初始化</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"l-value: "</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span> &amp;&amp;i)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"r-value: "</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward</span><span class="params">(<span class="type">int</span> &amp;&amp;k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printValue</span>(k);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> i = <span class="number">520</span>;</span><br><span class="line">    <span class="built_in">printValue</span>(i);</span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">1314</span>);</span><br><span class="line">    forward(<span class="number">250</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>测试代码输出的结果如下:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l-value: <span class="number">520</span></span><br><span class="line">r-value: <span class="number">1314</span></span><br><span class="line">l-value: <span class="number">250</span></span><br></pre></td></tr></tbody></table></figure><p>根据测试代码可以得知，编译器会根据传入的参数的类型（左值还是右值）调用对应的重置函数（printValue），函数 <font color="orange">forward ()</font> 接收的是一个右值，但是在这个函数中调用函数 printValue () 时，参数 <font color="orange">k </font>变成了一个命名对象，编译器会将其当做左值来处理。</p><p>最后总结一下关于 &amp;&amp; 的使用：</p><ul><li><font color="red">左值和右值是独立于他们的类型的，右值引用类型可能是左值也可能是右值。</font></li><li><font color="red">编译器会将已命名的右值引用视为左值，将未命名的右值引用视为右值。</font></li><li><font color="red">auto&amp;&amp;或者函数参数类型自动推导的T&amp;&amp;是一个未定的引用类型，它可能是左值引用也可能是右值引用类型，这取决于初始化的值类型（上面有例子）。</font></li><li><font color="red">通过右值推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个右值引用类型，其余都是左值引用类型。</font></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++11新特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11新特性--自动类型推导</title>
      <link href="/2022/04/20/%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"/>
      <url>/2022/04/20/%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<p>在 C++11 中增加了很多新的特性，比如可以使用 <font color="orange"><code>auto</code></font> 自动推导变量的类型，还能够结合 <font color="orange"><code>decltype</code></font> 来表示函数的返回值。使用新的特性可以让我们写出更加简洁，更加现代的代码。</p><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>在 C++11 之前 <font color="orange"><code>auto</code></font> 和<font color="orange"> <code>static</code> </font>是对应的，表示变量是自动存储的，但是非 static 的局部变量默认都是自动存储的，因此这个关键字变得非常鸡肋，在 C++11 中他们赋予了新的含义，使用这个关键字能够像别的语言一样<font color="red"><code>自动推导出变量的实际类型</code></font>。</p><h4 id="推导规则"><a href="#推导规则" class="headerlink" title="推导规则"></a>推导规则</h4><p>C++11 中 <font color="orange"><code>auto</code></font> 并不代表一种实际的数据类型，只是一个类型声明的 <font color="cornflowerblue"><code>“占位符”</code></font>，<font color="orange"><code>auto</code></font> 并不是万能的在任意场景下都能够推导出变量的实际类型，<font color="red">使用auto声明的变量必须要进行初始化，以让编译器推导出它的实际类型，在编译时将auto占位符替换为真正的类型</font>。使用语法如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;font color=<span class="string">'orange'</span>&gt;`<span class="keyword">auto</span>`&lt;/font&gt; 变量名 = 变量值;</span><br></pre></td></tr></tbody></table></figure><hr><p>根据上述语法，来列举一些简单的例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;font color=<span class="string">'orange'</span>&gt;`<span class="keyword">auto</span>`&lt;/font&gt; x = <span class="number">3.14</span>;      <span class="comment">// x 是浮点型 double</span></span><br><span class="line">&lt;font color=<span class="string">'orange'</span>&gt;`<span class="keyword">auto</span>`&lt;/font&gt; y = <span class="number">520</span>;       <span class="comment">// y 是整形 int</span></span><br><span class="line">&lt;font color=<span class="string">'orange'</span>&gt;`<span class="keyword">auto</span>`&lt;/font&gt; z = <span class="string">'a'</span>;       <span class="comment">// z 是字符型 char</span></span><br><span class="line">&lt;font color=<span class="string">'orange'</span>&gt;`<span class="keyword">auto</span>`&lt;/font&gt; nb;            <span class="comment">// error，变量必须要初始化</span></span><br><span class="line">&lt;font color=<span class="string">'orange'</span>&gt;`<span class="keyword">auto</span>`&lt;/font&gt; <span class="type">double</span> nbl;    <span class="comment">// 语法错误, 不能修改数据类型   </span></span><br></pre></td></tr></tbody></table></figure><p>不仅如此，<font color="orange"><code>auto</code></font> 还可以和<font color="orange"><code>指针</code></font>、<font color="orange"><code>引用</code></font>结合起来使用也可以带上 <font color="orange"><code>const</code></font>、<font color="orange"><code>volatile</code></font> 限定符，在不同的场景下有对应的推导规则，规则内容如下：</p><ul><li><font color="red">当变量不是指针或者引用类型时，推导的结果中不会保留 const、volatile 关键字</font></li><li><font color="red">当变量是指针或者引用类型时，推导的结果中会保留 const、volatile 关键字</font></li></ul><hr><p>先来看一组变量带指针和引用并使用 <font color="orange"><code>auto</code></font> 进行类型推导的例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp = <span class="number">110</span>;</span><br><span class="line">&lt;font color=<span class="string">'orange'</span>&gt;`<span class="keyword">auto</span>`&lt;/font&gt; *a = &amp;temp;</span><br><span class="line">&lt;font color=<span class="string">'orange'</span>&gt;`<span class="keyword">auto</span>`&lt;/font&gt; b = &amp;temp;</span><br><span class="line">&lt;font color=<span class="string">'orange'</span>&gt;`<span class="keyword">auto</span>`&lt;/font&gt; &amp;c = temp;</span><br><span class="line">&lt;font color=<span class="string">'orange'</span>&gt;`<span class="keyword">auto</span>`&lt;/font&gt; d = temp;</span><br></pre></td></tr></tbody></table></figure><p>变量 <font color="orange"><code>a</code> </font>的数据类型为<font color="orange"><code>int*</code></font>，因此 <font color="orange"><code>auto</code></font>  关键字被推导为 <font color="orange"><code>int类型</code></font><br>变量 <font color="orange"><code>b</code> </font>的数据类型为 <font color="orange"><code>int*</code></font>，因此 <font color="orange"><code>auto</code></font> 关键字被推导为  <font color="orange"><code>int*</code></font> 类型<br>变量 <font color="orange"><code>c</code> </font> 的数据类型为<font color="orange"> int&amp;</font>，因此 <font color="orange"><code>auto</code></font> 关键字被推导为  <font color="orange"><code>int类型</code></font><br>变量 <font color="orange"><code>d</code> </font> 的数据类型为 <font color="orange"><code>int</code></font>，因此 <font color="orange"><code>auto</code></font> 关键字被推导为  <font color="orange"><code>int</code></font>类型</p><p>在来看一组带 <font color="orange"><code>const</code></font> 限定的变量，使用 <font color="orange"><code>auto</code></font> 进行类型推导的例子:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp = <span class="number">250</span>;</span><br><span class="line"><span class="type">const</span> &lt;font color=<span class="string">'orange'</span>&gt;`<span class="keyword">auto</span>`&lt;/font&gt; a1 = tmp;</span><br><span class="line">&lt;font color=<span class="string">'orange'</span>&gt;`<span class="keyword">auto</span>`&lt;/font&gt; a2 = a1;</span><br><span class="line"><span class="type">const</span> &lt;font color=<span class="string">'orange'</span>&gt;`<span class="keyword">auto</span>`&lt;/font&gt; &amp;a3 = tmp;</span><br><span class="line">&lt;font color=<span class="string">'orange'</span>&gt;`<span class="keyword">auto</span>`&lt;/font&gt; &amp;a4 = a3;</span><br></pre></td></tr></tbody></table></figure><p>变量 <font color="orange"><code>a1</code> </font> 的数据类型为 <font color="orange"><code>const int</code></font>，因此 <font color="orange"><code>auto</code></font> 关键字被推导为 <font color="orange"><code>int</code></font> 类型<br>变量 <font color="orange"><code>a2</code> </font> 的数据类型为  <font color="orange"><code>int</code></font> ，但是 <font color="orange"><code>a2</code> </font> 没有声明为指针或引用因此 <font color="orange"><code>const</code></font>  属性被去掉，<font color="orange"><code>auto</code></font> 被推导为 <font color="orange"><code>int</code></font> 类型<br>变量 <font color="orange"><code>a3</code> </font>的数据类型为  <font color="orange"><code>const int&amp;</code></font> ，<font color="orange"><code>a2</code> </font>被声明为引用因此 <font color="orange"><code>const</code></font>属性被保留，<font color="orange"><code>auto</code></font> 关键字被推导为 <font color="orange"><code>int</code></font>  类型<br>变量 <font color="orange"><code>a4</code> </font> 的数据类型为 <font color="orange"><code>const int&amp;</code></font> ，<font color="orange"><code>a2</code> </font> 被声明为引用因此 <font color="orange"><code>const</code></font>属性被保留，<font color="orange"><code>auto</code></font> 关键字被推导为 <font color="orange"><code>const int</code></font> 类型</p><hr><h4 id="auto的限制"><a href="#auto的限制" class="headerlink" title="auto的限制"></a>auto的限制</h4><p><font color="orange"><code>auto</code></font> 关键字并不是万能的，在以下这些场景中是不能完成类型推导的：</p><ul><li>不能作为函数参数使用。因为<font color="red"><code>只有在函数调用的时候才会给函数参数传递实参(auto没有在定义时初始化)</code></font>，<font color="orange"><code>auto</code></font> 要求必须要给修饰的变量赋值，因此二者矛盾。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)</span><span class="comment">// error</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"a: "</span> &lt;&lt; a &lt;&lt;<span class="string">", b: "</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>不能用于类的非静态成员变量的初始化<font color="red"><code>（类的静态非常量成员不允许在类内部直接初始化</code>）</font></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">auto</span> v1 = <span class="number">0</span>;                    <span class="comment">// error</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">auto</span> v2 = <span class="number">0</span>;             <span class="comment">// error,类的静态非常量成员不允许在类内部直接初始化</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="keyword">auto</span> v3 = <span class="number">10</span>;      <span class="comment">// ok</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>不能使用<font color="orange"><code>auto</code></font> 关键字定义数组</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> array[] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};  <span class="comment">// 定义数组</span></span><br><span class="line">    <span class="keyword">auto</span> t1 = array;            <span class="comment">// ok, t1被推导为 int* 类型</span></span><br><span class="line">    <span class="keyword">auto</span> t2[] = array;          <span class="comment">// error, auto无法定义数组</span></span><br><span class="line">    <span class="keyword">auto</span> t3[] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};;   <span class="comment">// error, auto无法定义数组</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>无法使用 auto 推导出模板参数</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Test&lt;<span class="type">double</span>&gt; t;</span><br><span class="line">    Test&lt;<span class="keyword">auto</span>&gt; t1 = t;           <span class="comment">// error, 无法推导出模板类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="auto的应用"><a href="#auto的应用" class="headerlink" title="auto的应用"></a>auto的应用</h4><p>了解了 <font color="orange"><code>auto</code></font> 的限制之后，我们就可以避开这些场景快乐的编程了，下面列举几个比较常用的场景：</p><ul><li><p><font color="red"><code>用于STL的容器遍历</code></font></p><p>在 C++11 之前，定义了一个stl 容器之后，遍历的时候常常会写出这样的代码：</p></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; person;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt;::iterator it = person.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (; it != person.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到在定义迭代器变量 it 的时候代码是很长的，写起来就很麻烦，使用了 auto 之后，就变得清爽了不少：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; person;</span><br><span class="line">    <span class="comment">// 代码简化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = person.<span class="built_in">begin</span>(); it != person.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><font color="red"><code>用于泛型编程</code></font>，在使用模板的时候，很多情况下我们不知道变量应该定义为什么类型，比如下面的代码：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> string <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello, world"</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">auto</span> val = A::<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"val: "</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">func</span>&lt;T1&gt;();</span><br><span class="line">    <span class="built_in">func</span>&lt;T2&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个例子中定义了泛型函数 <font color="orange"><code>func</code></font>，在函数中调用了类 A 的静态方法 <font color="orange"><code>get ()</code></font> ，这个函数的返回值是不能确定的，如果不使用<font color="orange"> <code>auto</code></font>，就需要再定义一个模板参数，并且在外部调用时手动指定 <font color="orange"><code>get ()</code></font> 的返回值类型，具体代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> string <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello, world"</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">A</span>, <span class="keyword">typename</span> B&gt;        <span class="comment">// 添加了模板参数 B</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    B val = A::<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"val: "</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">func</span>&lt;T1, <span class="type">int</span>&gt;();                  <span class="comment">// 手动指定返回值类型 -&gt; int</span></span><br><span class="line">    <span class="built_in">func</span>&lt;T2, string&gt;();               <span class="comment">// 手动指定返回值类型 -&gt; string</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>在某些情况下，<font color="cornflowerblue">不需要或者不能定义变量，但是希望得到某种类型</font>，这时候就可以使用 C++11 提供的 <font color="orange"><code>decltype</code></font> 关键字了，<font color="red"><code>它的作用是在编译器编译的时候推导出一个表达式的类型</code></font>，语法格式如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span> (表达式)</span><br></pre></td></tr></tbody></table></figure><p> <font color="orange"><code>decltype</code></font>  是 “declare type” 的缩写，意思是 “声明类型”。 <font color="orange"><code>decltype</code></font> 的推导是在编译期完成的，它只是用于表达式类型的推导，并不会计算表达式的值。来看一组简单的例子:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">99</span>;                 <span class="comment">// b -&gt; int</span></span><br><span class="line"><span class="keyword">decltype</span>(a+<span class="number">3.14</span>) c = <span class="number">52.13</span>;         <span class="comment">// c -&gt; double</span></span><br><span class="line"><span class="keyword">decltype</span>(a+b*c) d = <span class="number">520.1314</span>;       <span class="comment">// d -&gt; double</span></span><br><span class="line"><span class="keyword">decltype</span>(a+b*c) e; <span class="comment">//e -&gt; double</span></span><br><span class="line">e = <span class="number">520.1314</span>;</span><br></pre></td></tr></tbody></table></figure><p>可以看到 <font color="orange"><code>decltype</code></font>  推导的表达式可简单可复杂，在这一点上 <font color="orange"><code>auto</code> </font>是做不到的，<font color="orange"><code>auto</code> </font>只能推导已初始化的变量类型。</p><h4 id="推导规则-1"><a href="#推导规则-1" class="headerlink" title="推导规则"></a>推导规则</h4><ol><li><font color="red">表达式为普通变量或者普通表达式或者类表达式，在这种情况下，使用 decltype 推导出的类型和表达式的类型是一致的。</font></li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string text;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">110</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> x = <span class="number">99</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;y = x;</span><br><span class="line">    <span class="keyword">decltype</span>(x) a = x;</span><br><span class="line">    <span class="keyword">decltype</span>(y) b = x;</span><br><span class="line">    <span class="keyword">decltype</span>(Test::value) c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Test t;</span><br><span class="line">    <span class="keyword">decltype</span>(t.text) d = <span class="string">"hello, world"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>变量 <font color="orange"><code>a</code></font>  被推导为 int 类型</li><li>变量 <font color="orange"><code>b</code></font> 被推导为 <font color="orange"><code>const int &amp;</code></font> 类型</li><li>变量 <font color="orange"><code>c</code></font>  被推导为 <font color="orange"><code>const int </code></font> 类型</li><li>变量 <font color="orange"><code>d</code></font>  被推导为 <font color="orange"><code>string</code></font>  类型</li></ul><ol start="2"><li><font color="red">表达式是函数调用，使用 decltype 推导出的类型和函数返回值一致。</font></li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>{...};</span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func_int</span><span class="params">()</span></span>;                 <span class="comment">// 返回值为 int</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">func_int_r</span><span class="params">()</span></span>;              <span class="comment">// 返回值为 int&amp;</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">func_int_rr</span><span class="params">()</span></span>;            <span class="comment">// 返回值为 int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">func_cint</span><span class="params">()</span></span>;          <span class="comment">// 返回值为 const int</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">func_cint_r</span><span class="params">()</span></span>;       <span class="comment">// 返回值为 const int&amp;</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp;&amp; <span class="title">func_cint_rr</span><span class="params">()</span></span>;     <span class="comment">// 返回值为 const int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Test <span class="title">func_ctest</span><span class="params">()</span></span>;        <span class="comment">// 返回值为 const Test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//decltype类型推导</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int</span>()) a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_r</span>()) b = n;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_rr</span>()) c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint</span>())  d = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint_r</span>())  e = n;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint_rr</span>()) f = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_ctest</span>()) g = <span class="built_in">Test</span>();</span><br></pre></td></tr></tbody></table></figure><ul><li>变量 <font color="orange"><code>a</code></font>  被推导为 <font color="orange"><code>int</code></font>  类型</li><li>变量 <font color="orange"><code>b</code></font>  被推导为 <font color="orange"><code>int&nbsp;&amp;</code></font>   类型</li><li>变量 <font color="orange"><code>c</code></font>  被推导为 <font color="orange"><code>int&nbsp;&amp;&amp;</code></font>   类型</li><li>变量 <font color="orange"><code>d</code></font>  被推导为 <font color="orange"><code>int</code></font>  类型</li><li>变量 <font color="orange"><code>e</code></font>  被推导为 <font color="orange"><code>const int&nbsp;&amp;</code></font>   类型</li><li>变量 <font color="orange"><code>f</code></font>  被推导为 <font color="orange"><code>const int &amp;&amp;</code></font>   类型</li><li>变量 <font color="orange"><code>g</code></font>  被推导为 <font color="orange"><code>const Test</code></font>   类型</li></ul><p>函数 <font color="orange">func_cint ()</font> 返回的是一个纯右值（在表达式执行结束后不再存在的数据，也就是临时性的数据），<font color="orange">对于纯右值而言，只有类类型可以携带const、volatile限定符，除此之外需要忽略掉这两个限定符</font>，因此推导出的变量 d 的类型为 <font color="orange">int</font> 而不是 <font color="orange">const int</font>。</p><ol start="3"><li><font color="red">表达式是一个左值，或者被括号 ( ) 包围，使用 decltype 推导出的是表达式类型的引用（如果有 const、volatile 限定符不能忽略）。</font></li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">const</span> Test obj; <span class="comment">//const修饰的类对象其成员也别const修饰</span></span><br><span class="line">    <span class="comment">//带有括号的表达式</span></span><br><span class="line">    <span class="keyword">decltype</span>(obj.num) a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>((obj.num)) b = a;</span><br><span class="line">    <span class="comment">//加法表达式</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(n + m) c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(n = n + m) d = n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><font color="orange">obj.num</font> 为类的成员访问表达式，符合场景 1，因此 <font color="orange">a</font> 的类型为 <font color="orange">int</font><br><font color="orange">obj.num</font> 带有括号，符合场景 3，因此 <font color="orange">b</font> 的类型为 <font color="orange">const int&amp;</font>。<br><font color="orange">n+m</font> 得到一个右值，符合场景 1，因此 c 的类型为 <font color="orange">int</font><br><font color="orange">n=n+m</font> 得到一个左值 <font color="orange">n</font>，符合场景 3，因此 <font color="orange">d </font>的类型为 <font color="orange">int&amp;</font></p><hr><h4 id="decltype的应用"><a href="#decltype的应用" class="headerlink" title="decltype的应用"></a>decltype的应用</h4><p>关于 <font color="orange">decltype </font>的应用多出现在泛型编程中。比如我们编写一个类模板，在里边添加遍历容器的函数，操作如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; c)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">for</span> (m_it = c.<span class="built_in">begin</span>(); m_it != c.<span class="built_in">end</span>(); ++m_it)</span><br><span class="line">        {</span><br><span class="line">            cout &lt;&lt; *m_it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ??? m_it;  <span class="comment">// 这里不能确定迭代器类型</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> list&lt;<span class="type">int</span>&gt; lst;</span><br><span class="line">    Container&lt;<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&gt; obj;</span><br><span class="line">    obj.<span class="built_in">func</span>(lst);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在程序的第 17 行出了问题，关于迭代器变量一共有两种类型：<font color="orange">只读（T::const_iterator）</font>和<font color="orange">读写（T::iterator）</font>，有了 <font color="orange">decltype </font>就可以完美的解决这个问题了，当 <font color="orange">T</font> 是一个 非 <font color="orange">const </font>容器得到一个<font color="orange"> T::iterator</font>，当 <font color="orange">T </font>是一个 <font color="orange">const </font>容器时就会得到一个 <font color="orange">T::const_iterator</font>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; c)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">for</span> (m_it = c.<span class="built_in">begin</span>(); m_it != c.<span class="built_in">end</span>(); ++m_it)</span><br><span class="line">        {</span><br><span class="line">            cout &lt;&lt; *m_it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">T</span>().<span class="built_in">begin</span>()) m_it;  <span class="comment">// 这里不能确定迭代器类型</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> list&lt;<span class="type">int</span>&gt; lst{ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> };</span><br><span class="line">    Container&lt;<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&gt; obj;</span><br><span class="line">    obj.<span class="built_in">func</span>(lst);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><font color="orange">decltype(T().begin()) </font>这种写法在 vs2017/vs2019 下测试可用完美运行。</p><h4 id="返回类型后置"><a href="#返回类型后置" class="headerlink" title="返回类型后置"></a>返回类型后置</h4><p>在泛型编程中，可能需要通过参数的运算来得到返回值的类型，比如下面这个场景：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// R-&gt;返回值类型, T-&gt;参数1类型, U-&gt;参数2类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T t, U u)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> x = <span class="number">520</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">13.14</span>;</span><br><span class="line">    <span class="comment">// auto z = add&lt;decltype(x + y), int, double&gt;(x, y);</span></span><br><span class="line">    <span class="keyword">auto</span> z = <span class="built_in">add</span>&lt;<span class="keyword">decltype</span>(x + y)&gt;(x, y);<span class="comment">// 简化之后的写法</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"z: "</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>关于返回值，从上面的代码可以推断出和表达式 <font color="orange">t+u </font>的结果类型是一样的，因此可以通过通过 <font color="orange">decltype </font>进行推导，关于模板函数的参数<font color="orange"> t</font> 和 <font color="orange">u</font> 可以通过实参自动推导出来，因此在程序中就也可以不写。虽然通过上述方式问题被解决了，但是解决方案有点过于理想化，因为对于调用者来说，是不知道函数内部执行了什么样的处理动作的。</p><p>因此如果要想解决这个问题就得直接在 <font color="orange">add </font>函数身上做文章，先来看第一种写法：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>(t+u) <span class="built_in">add</span>(T t, U u)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当我们在编译器中将这几行代码改出来后就直接报错了，因此 <font color="orange">decltype</font> 中的 <font color="orange">t </font>和 <font color="orange">u </font>都是函数参数，直接这样写相当于变量还没有定义就直接用上了，这时候变量还不存在，有点心急了。</p><hr><p><font color="orange">在C++11中增加了返回类型后置语法，说明白一点就是将decltype和auto结合起来完成返回类型的推导</font>。其语法格式如下:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 符号 -&gt; 后边跟随的是函数返回值的类型</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(参数<span class="number">1</span>, 参数<span class="number">2</span>, ...)</span> -&gt; <span class="title">decltype</span><span class="params">(参数表达式)</span></span></span><br></pre></td></tr></tbody></table></figure><p>通过对上述返回类型后置语法代码的分析，得到结论：<font color="orange">auto 会追踪 decltype() 推导出的类型</font>，因此上边的 <font color="orange">add() </font>函数可以做如下的修改：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="comment">// 返回类型后置语法</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t+u)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> x = <span class="number">520</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">13.14</span>;</span><br><span class="line">    <span class="comment">// auto z = add&lt;int, double&gt;(x, y);</span></span><br><span class="line">    <span class="keyword">auto</span> z = <span class="built_in">add</span>(x, y);<span class="comment">// 简化之后的写法</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"z: "</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了进一步说明这个语法，我们再看一个例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test</span><span class="params">(<span class="type">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">test</span><span class="params">(<span class="type">double</span> &amp;d)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    d = d + <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 返回类型后置语法</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">myFunc</span><span class="params">(T&amp; t)</span> -&gt; <span class="title">decltype</span><span class="params">(test(t))</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">test</span>(t);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> x = <span class="number">520</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">13.14</span>;</span><br><span class="line">    <span class="comment">// auto z = myFunc&lt;int&gt;(x);</span></span><br><span class="line">    <span class="keyword">auto</span> z = <span class="built_in">myFunc</span>(x);             <span class="comment">// 简化之后的写法</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"z: "</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// auto z = myFunc&lt;double&gt;(y);</span></span><br><span class="line">    <span class="keyword">auto</span> z1 = <span class="built_in">myFunc</span>(y);            <span class="comment">// 简化之后的写法</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"z1: "</span> &lt;&lt; z1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，通过 <font color="orange">decltype </font>结合返回值后置语法很容易推导出来 <font color="orange">test(t) </font>函数可能出现的返回值类型，并将其作用到了函数 <font color="orange">myFunc() </font>上。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">z: <span class="number">520</span></span><br><span class="line">z1: <span class="number">113.14</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++11新特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11新特性--constexpr</title>
      <link href="/2022/04/20/%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/04/20/%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="修饰常量表达式–constexpr"><a href="#修饰常量表达式–constexpr" class="headerlink" title="修饰常量表达式–constexpr"></a>修饰常量表达式–constexpr</h2><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>在 C++11 之前只有 <font color="red"><code>const</code></font> 关键字，从功能上来说这个关键字有双重语义：<font color="red">变量只读，修饰常量</font>，举一个简单的例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> count = <span class="number">24</span>;</span><br><span class="line">    <span class="type">int</span> array[num];            <span class="comment">// error，num是一个只读变量，不是常量</span></span><br><span class="line">    <span class="type">int</span> array1[count];         <span class="comment">// ok，count是一个常量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a1 = <span class="number">520</span>;</span><br><span class="line">    <span class="type">int</span> a2 = <span class="number">250</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; b = a1;</span><br><span class="line">    b = a2;                         <span class="comment">// error</span></span><br><span class="line">    a1 = <span class="number">1314</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"b: "</span> &lt;&lt; b &lt;&lt; endl;     <span class="comment">// 输出结果为1314</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>函数 <font color="orange">void func(const int num)</font> 的参数 <font color="orange">num </font>表示这个变量是只读的，但不是常量（<font color="orange"><code>num根据实参传入改变而改变</code></font>），因此使用 <font color="orange">int array[num];</font> 这种方式定义一个数组，<font color="red">编译器是会报错的</font>，提示 <font color="orange">num</font>  不可用作为常量来使用。</li><li><font color="orange">const int count = 24;</font> 中的 <font color="orange">count </font>却是一个常量，因此可以使用这个常量来定义一个静态数组。</li></ul><p>另外，<font color="orange">变量只读并不等价于常量</font>，二者是两个概念不能混为一谈，分析一下这句测试代码 <font color="orange">const int&amp; b = a1;</font>：</p><ul><li><p><font color="orange">b</font> 是一个常量的引用，所以 b 引用的变量是不能被修改的，也就是说<font color="orange"> b = a2;</font> 这句代码语法是错误的。</p></li><li><p>在<font color="orange"> const</font> 对于变量<font color="orange"> a1</font> 是没有任何约束的，<font color="orange">a1</font> 的值变了 <font color="orange">b</font> 的值也就变了</p></li><li><p>引用 <font color="orange">b</font> 是只读的，但是并不能保证它的值是不可改变的，也就是说它不是常量。</p></li></ul><hr><h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>在 C++11 中添加了一个新的关键字 <font color="orange">constexpr</font>，这个关键字是用来修饰常量表达式的。<font color="orange">所谓常量表达式，指的就是由多个（≥1）常量（值不会改变）组成并且在编译过程中就得到计算结果的表达式。</font></p><p>在介绍<font color="orac"> gcc/g++ 工作流程</font>的时候说过，C++ 程序从编写完毕到执行分为四个阶段：<font color="orange">预处理</font>、<font color="orange"> 编译</font>、<font color="orange">汇编</font>和<font color="orange">链接 </font>4 个阶段，得到可执行程序之后就可以运行了。需要额外强调的是，<font color="orange">常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果，但是常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率</font>，因为<font color="red">表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间</font>。</p><p>那么问题来了，编译器如何识别表达式是不是常量表达式呢？在 C++11 中添加了 <font color="orange">constexpr</font> 关键字之后就可以在程序中使用它来修改常量表达式，用来提高程序的执行效率。在使用中建议将 <font color="orange">const</font> 和 <font color="orange">constexpr</font> 的功能区分开，即凡是表达“只读”语义的场景都使用 const，表达“常量”语义的场景都使用 <font color="orange">constexpr</font>。</p><p>在定义常量时，<font color="orange">const</font> 和 <font color="orange">constexpr </font>是等价的，都可以在程序的编译阶段计算出结果，例如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> m = <span class="built_in">f</span>();  <span class="comment">// 不是常量表达式，m的值只有在运行时才会获取。</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i=<span class="number">520</span>;    <span class="comment">// 是一个常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j=i+<span class="number">1</span>;    <span class="comment">// 是一个常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i=<span class="number">520</span>;    <span class="comment">// 是一个常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> j=i+<span class="number">1</span>;    <span class="comment">// 是一个常量表达式</span></span><br></pre></td></tr></tbody></table></figure><p>对于 C++ 内置类型的数据，可以直接用<font color="orange"> constexpr</font> 修饰，但如果是自定义的数据类型（用 <font color="orange">struct </font>或者<font color="orange"> class</font> 实现），直接用 <font color="orange">constexpr</font> 修饰是不行的，只能修饰自定义数据类型的<font color="cornflowerblue">实例对象</font>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处的constexpr修饰是无效的</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>如果要定义一个结构体 / 类常量对象，可以这样写：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">constexpr</span> Test t{ <span class="number">1</span>, <span class="number">2</span> };</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> id = t.id;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> num = t.num;</span><br><span class="line">    <span class="comment">// error，不能修改常量</span></span><br><span class="line">    t.num += <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"id: "</span> &lt;&lt; id &lt;&lt; <span class="string">", num: "</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在第 13行的代码中 <font color="orange">t.num += 100;</font> 的操作是错误的，对象 t 是一个常量，因此它的成员也是常量，常量是不能被修改的。</p><h2 id="常量表达式函数"><a href="#常量表达式函数" class="headerlink" title="常量表达式函数"></a>常量表达式函数</h2><p>为了提高 C++ 程序的执行效率，我们可以将程序中值不需要发生变化的变量定义为常量，也可以使用<font color="orange"> constexpr </font>修饰函数的返回值，这种函数被称作<font color="orange">常量表达式函数</font>，这些函数主要包括以下几种：<font color="red">普通函数/类成员函数、类的构造函数、模板函数</font>。</p><h3 id="修饰普通函数-x2F-类成员函数"><a href="#修饰普通函数-x2F-类成员函数" class="headerlink" title="修饰普通函数/类成员函数"></a>修饰普通函数/类成员函数</h3><p><font color="orange">constexpr </font>并不能修改任意函数的返回值，使这些函数成为常量表达式函数，必须要满足以下几个条件：</p><ol><li><font color="red">函数必须要有返回值，并且 return 返回的表达式必须是常量表达式。</font></li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error，不是常量表达式函数</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"a: "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// error，不是常量表达式函数</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>函数 <font color="orange">func1()</font> 没有返回值，不满足常量表达式函数要求</li><li>函数 <font color="orange">func2()</font> 返回值不是常量表达式，不满足常量表达式函数要求</li></ul><ol start="2"><li><font color="red">函数在使用之前，必须有对应的定义语句</font>。</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> num = <span class="built_in">func1</span>();<span class="comment">// error 函数在使用之前，必须有对应的定义语句</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>在测试程序<font color="orange">&nbsp;<code>constexpr int num = func1()</code>;</font> 中，还没有定义 <font color="orange"><code>func1(</code>)</font> 就直接调用了，应该将 <font color="orange"><code>func1()</code> </font>函数的定义放到 <font color="orange"><code>main()</code> </font>函数的上边。</li></ul><ol start="3"><li><font color="red">整个函数的函数体中，不能出现非常量表达式之外的语句）</font><font color="orange">（using 指令、typedef 语句以及 static_assert 断言、return 语句除外)</font>。</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b; ++i)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"i: "</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">using</span> mytype = <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> mytype a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> mytype b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> mytype c = a * b;</span><br><span class="line">    <span class="keyword">return</span> c - (a + b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>因为 <font color="orange"><code>func1()</code></font> 是一个常量表达式函数，在函数体内部是不允许出现非常量表达式以外的操作，因此函数体内部的 <font color="orange"><code>for</code></font> 循环是一个非法操作。</li></ul><blockquote><p>以上三条规则不仅对应普通函数适用，对应类的成员函数也是适用的：</p></blockquote><h3 id="修饰模板函数"><a href="#修饰模板函数" class="headerlink" title="修饰模板函数"></a>修饰模板函数</h3><p>C++11 语法中，<font color="orange"><code>constexpr</code></font> 可以修饰函数模板，但由于模板中类型的不确定性，因此函数模板实例化后的模板函数是否符合常量表达式函数的要求也是不确定的(<font color="orange"><code>主要看，模板函数调用时传递的实参是否是常量</code></font>)。<font color="red">如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。</font></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">dispaly</span><span class="params">(T t)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> p { <span class="string">"luffy"</span>, <span class="number">19</span> };</span><br><span class="line">    <span class="comment">//普通函数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> ret = <span class="built_in">dispaly</span>(p);</span><br><span class="line">    cout &lt;&lt; <span class="string">"luffy's name: "</span> &lt;&lt; ret.name &lt;&lt; <span class="string">", age: "</span> &lt;&lt; ret.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//常量表达式函数</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> ret1 = <span class="built_in">dispaly</span>(<span class="number">250</span>);</span><br><span class="line">    cout &lt;&lt; ret1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Person</span> p1 { <span class="string">"luffy"</span>, <span class="number">19</span> };</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Person</span> p2 = <span class="built_in">dispaly</span>(p1);</span><br><span class="line">    cout &lt;&lt; <span class="string">"luffy's name: "</span> &lt;&lt; p2.name &lt;&lt; <span class="string">", age: "</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上面示例程序中定义了一个函数模板 <font color="orange"><code>display()</code></font>，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求：</p><ul><li><font color="orange"><code>struct Person ret = dispaly(p);</code> </font>由于参数 p 是变量，所以实例化后的函数不是常量表达式函数，此时 <font color="orange"><code>constexpr</code></font> 是无效的</li><li><font color="orange"><code>constexpr int ret1 = dispaly(250);</code></font>;参数是常量，符合常量表达式函数的要求，此时 <font color="orange"><code>constexpr</code></font> 是有效的</li><li><font color="orange"><code>constexpr struct Person p2 = dispaly(p1);</code></font> 参数是常量，符合常量表达式函数的要求，此时 <font color="orange"><code>constexpr</code></font> 是有效的</li></ul><h3 id="修饰构造函数"><a href="#修饰构造函数" class="headerlink" title="修饰构造函数"></a>修饰构造函数</h3><p>如果想用<font color="orange"><code>直接得到一个常量对象</code></font>，也可以使用 constexpr 修饰一个构造函数，这样就可以得到一个常量构造函数了。常量构造函数有一个要求：<font color="red"><code>构造函数的函数体必须为空，并且必须采用初始化列表的方式为各个成员赋值。</code></font></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Person</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p, <span class="type">int</span> age)</span> :name(p), age(age)</span></span><br><span class="line"><span class="function">    {</span></span><br><span class="line">    }</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Person</span> <span class="built_in">p1</span>(<span class="string">"luffy"</span>, <span class="number">19</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"luffy's name: "</span> &lt;&lt; p1.name &lt;&lt; <span class="string">", age: "</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++11新特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11新特性--nullPtr</title>
      <link href="/2022/04/20/%E7%A9%BA%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/04/20/%E7%A9%BA%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="空指针类型–nullptr"><a href="#空指针类型–nullptr" class="headerlink" title="空指针类型–nullptr"></a>空指针类型–nullptr</h2><p>在 C++ 程序开发中，为了提高程序的健壮性，一般会在定义指针的同时完成初始化操作，或者在指针的指向尚未明确的情况下，都会给指针初始化为<span style="color:red;background:背景颜色;font-size:文字大小;font-family:字体;">NULL</span> ，避免产生<span style="color:red;background:背景颜色;font-size:文字大小;font-family:字体;">野指针（没有明确指向的指针，操作也这种指针极可能导致程序发生异常）</span>。C++98/03 标准中，将一个指针初始化为空指针的方式有 2 种</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *ptr = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *ptr = <span class="literal">NULL</span>;</span><br></pre></td></tr></tbody></table></figure><p>在底层源码中 NULL 这个宏是这样定义的:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NULL</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>也就是说如果源码是 C++ 程序 <span style="color:red;background:背景颜色;font-size:文字大小;font-family:字体;">NULL</span> 就是<span style="color:red;background:背景颜色;font-size:文字大小;font-family:字体;">0</span> ，如果是 C 程序  <span style="color:red;background:背景颜色;font-size:文字大小;font-family:字体;">NULL</span>  表示  <span style="color:red;background:背景颜色;font-size:文字大小;font-family:字体;">(void*)0</span> 。那么为什么要这样做呢？ 是由于 C++ 中，<span style="color:red;background:背景颜色;font-size:文字大小;font-family:字体;">void *&nbsp;</span>  类型无法隐式转换为其他类型的指针，此时使用 <span style="color:red;background:背景颜色;font-size:文字大小;font-family:字体;">0</span>  代替 <span style="color:red;background:背景颜色;font-size:文字大小;font-family:字体;">((void *)0)</span> ，用于解决空指针的问题。这个 0（0x0000 0000）表示的就是虚拟地址空间中的 0 地址，这块地址是只读的。</p><hr><p>C++ 中将 NULL 定义为字面常量 0，并不能保证在所有场景下都能很好的工作，比如，函数重载时，NULL 和 0 无法区分：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void func(char *p)</span><br><span class="line">{</span><br><span class="line">    cout &lt;&lt; "void func(char *p)" &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void func(int p)</span><br><span class="line">{</span><br><span class="line">    cout &lt;&lt; "void func(int p)" &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    func(NULL);   // 想要调用重载函数 void func(char *p)，但实际调用的是fun(0)</span><br><span class="line">    func(250);    // 想要调用重载函数 void func(int p)</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试代码打印的结果为：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span></span></span><br></pre></td></tr></tbody></table></figure><p>通过打印的结果可以看到，虽然调用 <font color="red">func(NULL)</font>; 最终链接到的还是 <font color="red">void func(int p)</font> 和预期是不一样的，其实这个原因前边已经说的很明白了，在 C++ 中 <font color="red">NULL</font> 和 <font color="red">0</font> 是等价的。</p><hr><p>出于兼容性的考虑，C++11 标准并没有对 NULL 的宏定义做任何修改，而是另其炉灶，引入了一个新的关键字 <font color="orange">nullptr</font>。<font color="orange">nullptr专用于初始化空类型指针，不同类型的指针变量都可以使用 nullptr 来初始化 </font>：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>*    ptr1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">char</span>*   ptr2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">double</span>* ptr3 = <span class="literal">nullptr</span>;</span><br></pre></td></tr></tbody></table></figure><p>对应上面的代码编译器会分别将 <font color="red">nullptr</font> 隐式转换成<font color="red">int*</font>、<font color="red">char*</font>、以及 <font color="red">double*</font> 指针类型。</p><p>使用 <font color="red">nullptr </font>可以很完美的解决上边提到的函数重载问题:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"void func(char *p)"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"void func(int p)"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">250</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试代码输出的结果:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span> *p)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span></span></span><br></pre></td></tr></tbody></table></figure><p>通过输出的结果可以看出，<font color="red">nullptr 无法隐式转换为整形，但是可以隐式匹配指针类型。在 C++11 标准下，相比 NULL 和 0，使用 nullptr 初始化空指针可以令我们编写的程序更加健壮。</font></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++11新特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11新特性--原始字面量</title>
      <link href="/2022/04/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%9F%E5%A7%8B%E5%AD%97%E9%9D%A2%E9%87%8F/"/>
      <url>/2022/04/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%9F%E5%A7%8B%E5%AD%97%E9%9D%A2%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串原始字面量–R”-”"><a href="#字符串原始字面量–R”-”" class="headerlink" title="字符串原始字面量–R”()”"></a>字符串原始字面量–R”()”</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在 C++11 中添加了定义原始字符串的字面量，定义方式为：<span style="color:red;background:背景颜色;font-size:文字大小;font-family:字体;">R “xxx(原始字符串)xxx” 其中（）两边的字符串可以省略</span>。原始字面量 R 可以直接表示字符串的实际含义，而不需要额外对字符串做转义或连接等操作。</p><p>比如：编程过程中，使用的字符串中常带有一些特殊字符，对于这些字符往往要做专门的处理，使用了原始字面量就可以轻松的解决这个问题了，比如打印路径：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string str = <span class="string">"D:\hello\world\test.text"</span>;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    string str1 = <span class="string">"D:\\hello\\world\\test.text"</span>;</span><br><span class="line">    <span class="comment">//通过第一个'\'来转义第二个'\'</span></span><br><span class="line">    cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    string str2 = <span class="string">R"(D:\hello\world\test.text)"</span>;</span><br><span class="line">    cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果为：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:helloworld    est.text</span><br><span class="line">D:\hello\world\test.text</span><br><span class="line">D:\hello\world\test.text</span><br></pre></td></tr></tbody></table></figure><ul><li>在 D:\hello\world\test.text 中 \h 和 \w 转义失败，对应的字符会原样输出</li><li>在 D:\hello\world\test.text 中路径的间隔符为 \ 但是这个字符又是转义字符，因此需要使用转义字符将其转义，最终才能得到一个没有特殊含义的普通字符 \</li><li>在 R”(D:\hello\world\test.text)” 使用了原始字面量 R（）中的内容就是描述路径的原始字符串，无需做任何处理</li></ul><p>在 R”(D:\hello\world\test.text)” 使用了原始字面量 R（）中的内容就是描述路径的原始字符串，无需做任何处理</p><hr><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>在 C++11 之前如果一个字符串分别写到了不同的行里边，需要加连接符，这种方式不仅繁琐，还破坏了表达式的原始含义，如果使用原始字面量就变得简单很多，很强直观，可读性强。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string str = <span class="string">"\</span></span><br><span class="line"><span class="string">我是路飞!!!\ </span></span><br><span class="line"><span class="string">        我是要成为海贼王的男人!!!\</span></span><br><span class="line"><span class="string">        "</span>;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string str = <span class="string">R"(</span></span><br><span class="line"><span class="string">        我是路飞!!!</span></span><br><span class="line"><span class="string">        我是要成为海贼王的男人!!!</span></span><br><span class="line"><span class="string">        )"</span>;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p>最后强调一个细节：<span style="color:red;background:背景颜色;font-size:文字大小;font-family:字体;">在R “xxx(raw string)xxx” 中，原始字符串必须用括号（）括起来，括号的前后可以加其他字符串，所加的字符串会被忽略，并且加的字符串必须在括号两边同时出现</span>。</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">'color:文字颜色;background:背景颜色;font-size:文字大小;font-family:字体;'</span>&gt;</span></span>文字<span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string str1 = <span class="string">R"(D:\hello\world\test.text)"</span>;</span><br><span class="line">    cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    string str2 = <span class="string">R"luffy(D:\hello\world\test.text)luffy"</span>;</span><br><span class="line">    cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">// 语法错误，编译不通过</span></span><br><span class="line">    string str3 = <span class="string">R"luffy(D:\hello\world\test.text)robin";</span></span><br><span class="line"><span class="string">    cout &lt;&lt; str3 &lt;&lt; endl;</span></span><br><span class="line"><span class="string">#endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><p>测试代码输出的结果为：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\hello\world\test.text</span><br><span class="line">D:\hello\world\test.text</span><br></pre></td></tr></tbody></table></figure><p>通过输出的信息可以得到如下结论：<span style="color:red;background:背景颜色;font-size:文字大小;font-family:字体;">使用原始字面量 R “xxx (raw string) xxx”，（）两边的字符串在解析的时候是会被忽略的，因此一般不用指定。如果在（）前后指定了字符串，那么前后的字符串必须相同，否则会出现语法错误</span>。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++11新特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown基础</title>
      <link href="/2022/04/15/MarkDown%E6%95%99%E7%A8%8B/"/>
      <url>/2022/04/15/MarkDown%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="MarkDown基础"><a href="#MarkDown基础" class="headerlink" title="MarkDown基础"></a>MarkDown基础</h1><p><a href="https://www.bilibili.com/video/av87982836#reply2366896129">基础篇视频讲解链接</a><br><a href="https://www.bilibili.com/video/av88551739/">画图篇视频讲解链接</a></p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 标题名字（井号的个数代表标题的级数）</span></span><br></pre></td></tr></tbody></table></figure><h1 id="一级标题使用1个"><a href="#一级标题使用1个" class="headerlink" title="一级标题使用1个#"></a>一级标题使用1个#</h1><h2 id="二级标题使用2个"><a href="#二级标题使用2个" class="headerlink" title="二级标题使用2个#"></a>二级标题使用2个#</h2><h3 id="三级标题使用3个"><a href="#三级标题使用3个" class="headerlink" title="三级标题使用3个#"></a>三级标题使用3个#</h3><h4 id="四级标题使4用个"><a href="#四级标题使4用个" class="headerlink" title="四级标题使4用个#"></a>四级标题使4用个#</h4><h5 id="五级标题使用5个"><a href="#五级标题使用5个" class="headerlink" title="五级标题使用5个#"></a>五级标题使用5个#</h5><h6 id="六级标题使用6个"><a href="#六级标题使用6个" class="headerlink" title="六级标题使用6个#"></a>六级标题使用6个#</h6><p>####### 最多支持六级标题#</p><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这就是 ~~删除线~~ (使用波浪号)</span><br></pre></td></tr></tbody></table></figure><p>这就是 <del>删除线</del> (使用波浪号)</p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是用来 <span class="emphasis">*斜体*</span> 的 <span class="emphasis">_文本_</span></span><br></pre></td></tr></tbody></table></figure><p>这是用来 <em>斜体</em> 的 <em>文本</em></p><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是用来 <span class="strong">**加粗**</span> 的 <span class="strong">__文本__</span></span><br></pre></td></tr></tbody></table></figure><p>这是用来 <strong>加粗</strong> 的 <strong>文本</strong></p><h3 id="斜体-加粗"><a href="#斜体-加粗" class="headerlink" title="斜体+加粗"></a>斜体+加粗</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是用来 <span class="strong">**<span class="emphasis">*斜体+加粗*</span>**</span> 的 <span class="strong">__<span class="emphasis">_文本_</span>__</span></span><br></pre></td></tr></tbody></table></figure><p>这是用来 <em><strong>斜体+加粗</strong></em> 的 <em><strong>文本</strong></em></p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>下划线是HTML语法</p><p><code>下划线</code> <u>下划线(快捷键<code>command</code>+<code>u</code>，视频中所有的快捷键都是针对Mac系统，其他系统可自行查找，Windows下的为ctrl + u)</u></p><h3 id="高亮（需勾选扩展语法）"><a href="#高亮（需勾选扩展语法）" class="headerlink" title="高亮（需勾选扩展语法）"></a>高亮（需勾选扩展语法）</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是用来 ==斜体+加粗== 的文本</span><br></pre></td></tr></tbody></table></figure><p>这是用来 ==斜体+加粗== 的文本</p><h3 id="下标（需勾选扩展语法）"><a href="#下标（需勾选扩展语法）" class="headerlink" title="下标（需勾选扩展语法）"></a>下标（需勾选扩展语法）</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">水 H~2~O </span><br><span class="line">双氧水 H~2~O~2~ </span><br></pre></td></tr></tbody></table></figure><p>水 H<del>2</del>O </p><p>双氧水 H<del>2</del>O<del>2</del></p><h3 id="上标（需勾选扩展语法）"><a href="#上标（需勾选扩展语法）" class="headerlink" title="上标（需勾选扩展语法）"></a>上标（需勾选扩展语法）</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">面积 m^2^ </span><br><span class="line">体积 m^3^</span><br></pre></td></tr></tbody></table></figure><p>面积 m^2^<br>体积 m^3^</p><h3 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h3><p> Emoji 支持表情符号，你可以用系统默认的 Emoji 符号（ Windows 用户不一定支持，自己试下~）。 也可以用图片的表情，输入 <code>:</code> 将会出现智能提示。  </p><h4 id="一些表情例子"><a href="#一些表情例子" class="headerlink" title="一些表情例子"></a>一些表情例子</h4><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:smile: :laughing: :dizzy<span class="emphasis">_face: :sob: :cold_</span>sweat: :sweat<span class="emphasis">_smile:  :cry: :triumph: :heart_</span>eyes: :relaxed: :sunglasses: :weary:</span><br><span class="line"></span><br><span class="line">:+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat<span class="emphasis">_drops: :hankey: :exclamation: :anger:</span></span><br><span class="line"><span class="emphasis"></span></span><br></pre></td></tr></tbody></table></figure><p><span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😵</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f635.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😰</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>  <span class="github-emoji"><span>😢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😤</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f624.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>☺</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😎</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f629.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> :+1: :-1: <span class="github-emoji"><span>💯</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4af.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>👏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f44f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>🔔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f514.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>🎁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f381.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>💣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>❤</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2764.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>☕</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2615.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>🌀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f300.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>🙇</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f647.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>💋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f48b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>🙏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f64f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>💦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a6.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>💩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a9.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>❗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>💢</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a2.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>(  Mac: <code>control</code>+<code>command</code>+<code>space</code>点选)</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行：</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name | price</span><br><span class="line">--- | ---</span><br><span class="line">fried chicken | 19</span><br><span class="line">cola|5</span><br></pre></td></tr></tbody></table></figure><blockquote><p>为了使 Markdown 更清晰，<code>|</code> 和 <code>-</code> 两侧需要至少有一个空格（最左侧和最右侧的 <code>|</code> 外就不需要了）。</p></blockquote><table><thead><tr><th>name</th><th>price</th></tr></thead><tbody><tr><td>fried chicken</td><td>19</td></tr><tr><td>cola</td><td>5</td></tr></tbody></table><p>为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 <code>|</code> 来标记单元格边界，在表头下方的分隔线标记中加入 <code>:</code>，即可标记下方单元格内容的对齐方式：</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|    name       | price |</span><br><span class="line">| :------------ | :---: |</span><br><span class="line">| fried chicken | 19    |</span><br><span class="line">| cola          |  32   |</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th align="left">name</th><th align="center">price</th></tr></thead><tbody><tr><td align="left">fried chicken</td><td align="center">19</td></tr><tr><td align="left">cola</td><td align="center">32</td></tr></tbody></table><p>使用快捷键<code>command</code>+<code>opt</code>+<code>T</code>更方便(段落→表格→插入表格，即可查看快捷键)</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;“后悔创业”</span><br></pre></td></tr></tbody></table></figure><blockquote><p>“后悔创业”</p></blockquote><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;也可以在引用中</span><br><span class="line">&gt;&gt;使用嵌套的引用</span><br></pre></td></tr></tbody></table></figure><blockquote><p>也可以在引用中</p><blockquote><p>使用嵌套的引用</p></blockquote></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表–符号-空格"><a href="#无序列表–符号-空格" class="headerlink" title="无序列表–符号 空格"></a>无序列表–符号 空格</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> 可以使用 <span class="code">`*`</span> 作为标记</span><br><span class="line"><span class="bullet">+</span> 也可以使用 <span class="code">`+`</span></span><br><span class="line"><span class="bullet">-</span> 或者 <span class="code">`-`</span></span><br><span class="line">使用两个回车键退出无序列表或者使用快捷键Ctrl+[</span><br></pre></td></tr></tbody></table></figure><ul><li>可以使用 <code>*</code> 作为标记</li></ul><ul><li>也可以使用 <code>+</code></li></ul><ul><li>或者 <code>-</code></li></ul><h3 id="有序列表–数字-空格"><a href="#有序列表–数字-空格" class="headerlink" title="有序列表–数字 . 空格"></a>有序列表–数字 <code>.</code> 空格</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 有序列表以数字和 <span class="code">`.`</span> 开始；</span><br><span class="line"><span class="bullet">3.</span> 数字的序列并不会影响生成的列表序列；</span><br><span class="line"><span class="bullet">4.</span> 但仍然推荐按照自然顺序（1.2.3...）编写。</span><br><span class="line">使用两个回车键退出无序列表或者使用快捷键Ctrl+shift+[</span><br></pre></td></tr></tbody></table></figure><ol><li><p>有序列表以数字和 <code>.</code> 开始；</p></li><li><p>数字的序列并不会影响生成的列表序列；</p></li><li><p>但仍然推荐按照自然顺序（1.2.3…）编写。</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以使用：数字\. 来取消显示为列表（用反斜杠进行转义）</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```语言名称</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">也可以通过 <span class="code">``，插入行内代码（`</span> 是 <span class="code">`Tab`</span> 键上边、数字 <span class="code">`1`</span> 键左侧的那个按键）：</span><br><span class="line"></span><br><span class="line">例如 <span class="code">`Markdown`</span></span><br></pre></td></tr></tbody></table></figure><p><code>Markdown</code></p><h3 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h3><p>代码块中的文本（包括 Markdown 语法）都会显示为原始内容</p><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>可以在一行中使用三个或更多的 <code>*</code>、<code>-</code> 或 <code>_</code> 来添加分隔线（``）：</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"><span class="strong">**<span class="emphasis">*</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="section">------</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="section">___</span></span></span></span><br></pre></td></tr></tbody></table></figure><hr><hr><hr><h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><h3 id="外部跳转–超链接"><a href="#外部跳转–超链接" class="headerlink" title="外部跳转–超链接"></a>外部跳转–超链接</h3><p>格式为 <code>[link text](link)</code>。</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">帮助文档</span>](<span class="link">https://support.typora.io/Links/#faq</span>)</span><br></pre></td></tr></tbody></table></figure><p><a href="https://support.typora.io/Links/#faq">帮助文档</a></p><h3 id="内部跳转–本文件内跳（Typora支持）"><a href="#内部跳转–本文件内跳（Typora支持）" class="headerlink" title="内部跳转–本文件内跳（Typora支持）"></a>内部跳转–本文件内跳（Typora支持）</h3><p>格式为 <code>[link text](#要去的目的地--标题）</code>。</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">我想跳转</span>](<span class="link">#饼图（Pie）</span>)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Open Links in Typora</p><p>You can use <code>command+click</code> (macOS), or <code>ctrl+click</code> (Linux/Windows) on links in Typora to jump to target headings, or open them in Typora, or open in related apps.</p></blockquote><p><a href="#%E9%A5%BC%E5%9B%BE%EF%BC%88Pie%EF%BC%89">我想跳转</a></p><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>使用 <code>&lt;&gt;</code> 包括的 URL 或邮箱地址会被自动转换为超链接：</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">&lt;https://www.baidu.com&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;123@email.com&gt;</span><br></pre></td></tr></tbody></table></figure><p><a href="https://www.baidu.com/">https://www.baidu.com</a></p><p><a href="mailto:123@email.com">123@email.com</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">自己起的图片名字</span>](<span class="link">图片地址或者图片本地存储的路径</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="网上的图片"><a href="#网上的图片" class="headerlink" title="网上的图片"></a>网上的图片</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">friedChicken</span>](<span class="link">https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1580814517&amp;di=2630beac440e5dab0e44c7286a3b2b61&amp;src=http://imgsrc.baidu.com/forum/w=580/sign=12c730c4ff03738dde4a0c2a831ab073/9497794f9258d1091818e6d6d858ccbf6d814d1b.jpg</span>)</span><br></pre></td></tr></tbody></table></figure><p><img src="https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1580814517&amp;di=2630beac440e5dab0e44c7286a3b2b61&amp;src=http://imgsrc.baidu.com/forum/w=580/sign=12c730c4ff03738dde4a0c2a831ab073/9497794f9258d1091818e6d6d858ccbf6d814d1b.jpg" alt="炸鸡"></p><h3 id="本地图片"><a href="#本地图片" class="headerlink" title="本地图片"></a>本地图片</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">friedChicken</span>](<span class="link">friedChicken.jpg</span>)</span><br><span class="line">在同一个文件夹里（用相对路径）</span><br><span class="line">或者直接拷贝</span><br></pre></td></tr></tbody></table></figure><p><img src="/friedChicken.jpg" alt="friedChicken"></p><p><img src="/../cola.jpg" alt="cola"></p><h2 id="利用Markdown画图（需勾选扩展语法）"><a href="#利用Markdown画图（需勾选扩展语法）" class="headerlink" title="利用Markdown画图（需勾选扩展语法）"></a>利用Markdown画图（需勾选扩展语法）</h2><p><img src="/image-20200211211500416.png" alt="image-20200211211500416"></p><p>markdown画图也是轻量级的，功能并不全。</p><p>Mermaid 是一个用于画流程图、状态图、时序图、甘特图的库，使用 JS 进行本地渲染，广泛集成于许多 Markdown 编辑器中。Mermaid 作为一个使用 JS 渲染的库，生成的不是一个“图片”，而是一段 HTML 代码。</p><p>（不同的编辑器渲染的可能不一样）</p><h3 id="流程图-graph"><a href="#流程图-graph" class="headerlink" title="流程图(graph)"></a>流程图(graph)</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph 方向描述</span><br><span class="line"><span class="code">    图表中的其他语句...</span></span><br></pre></td></tr></tbody></table></figure><p>关键字graph表示一个流程图的开始，同时需要指定该图的方向。</p><p>其中“方向描述”为：</p><table><thead><tr><th align="left">用词</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">TB</td><td align="left">从上到下</td></tr><tr><td align="left">BT</td><td align="left">从下到上</td></tr><tr><td align="left">RL</td><td align="left">从右到左</td></tr><tr><td align="left">LR</td><td align="left">从左到右</td></tr></tbody></table><blockquote><p>T = TOP，B = BOTTOM，L = LEFT，R = RIGHT，D = DOWN</p></blockquote><p>最常用的布局方向是TB、LR。</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TB;</span><br><span class="line">  A--&gt;B</span><br><span class="line">  B--&gt;C</span><br><span class="line">  C--&gt;A</span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TB;</span><br><span class="line">  A--&gt;B</span><br><span class="line">  B--&gt;C</span><br><span class="line">  C--&gt;A</span><br></pre></td></tr></tbody></table></figure><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">  A--&gt;B</span><br><span class="line">  B--&gt;C</span><br><span class="line">  C--&gt;A</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">  A--&gt;B</span><br><span class="line">  B--&gt;C</span><br><span class="line">  C--&gt;A</span><br></pre></td></tr></tbody></table></figure><h4 id="流程图常用符号及含义"><a href="#流程图常用符号及含义" class="headerlink" title="流程图常用符号及含义"></a>流程图常用符号及含义</h4><h5 id="节点形状"><a href="#节点形状" class="headerlink" title="节点形状"></a>节点形状</h5><table><thead><tr><th align="left">表述</th><th align="left">说明</th><th>含义</th></tr></thead><tbody><tr><td align="left">id[文字]</td><td align="left">矩形节点</td><td>表示过程，也就是整个流程中的一个环节</td></tr><tr><td align="left">id(文字)</td><td align="left">圆角矩形节点</td><td>表示开始和结束</td></tr><tr><td align="left">id((文字))</td><td align="left">圆形节点</td><td>表示连接。为避免流程过长或有交叉，可将流程切开。成对</td></tr><tr><td align="left">id{文字}</td><td align="left">菱形节点</td><td>表示判断、决策</td></tr><tr><td align="left">id&gt;文字]</td><td align="left">右向旗帜状节点</td><td></td></tr></tbody></table><p><strong>单向箭头线段</strong>：表示流程进行方向</p><blockquote><p>id即为节点的唯一标识，A~F 是当前节点名字，类似于变量名，画图时便于引用</p><p>括号内是节点中要显示的文字，默认节点的名字和显示的文字都为A</p></blockquote><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">  A</span><br><span class="line">  B(圆角矩形节点)</span><br><span class="line">  C[矩形节点]</span><br><span class="line">  D((圆形节点))</span><br><span class="line">  E{菱形节点}</span><br><span class="line">  F&gt;右向旗帜状节点] </span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">  A</span><br><span class="line">  B(圆角矩形节点)</span><br><span class="line">  C[矩形节点]</span><br><span class="line">  D((圆形节点))</span><br><span class="line">  E{菱形节点}</span><br><span class="line">  F&gt;右向旗帜状节点]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"><span class="code">    begin(出门)--&gt; buy[买炸鸡]</span></span><br><span class="line"><span class="code">    buy --&gt; IsRemaining{"还有没有炸鸡？"}</span></span><br><span class="line"><span class="code">    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack(回家)</span></span><br><span class="line"><span class="code">    IsRemaining --没有--&gt; sad["伤心"]--&gt; goBack</span></span><br><span class="line"><span class="code">    </span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    begin(出门)--&gt; buy[买炸鸡]</span><br><span class="line">    buy --&gt; IsRemaining{"还有没有炸鸡？"}</span><br><span class="line">    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack(回家)</span><br><span class="line">    IsRemaining --没有--&gt; sad["伤心"]--&gt; goBack</span><br><span class="line">    </span><br></pre></td></tr></tbody></table></figure><h5 id="连线"><a href="#连线" class="headerlink" title="连线"></a>连线</h5><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">  A1--&gt;B1</span><br><span class="line">  A2---B2</span><br><span class="line">  A3--text---B3</span><br><span class="line">  A4--text--&gt;B4</span><br><span class="line">  A5-.-B5</span><br><span class="line">  A6-.-&gt;B6</span><br><span class="line">  A7-.text.-B7</span><br><span class="line">  A8-.text.-&gt;B8</span><br><span class="line">  A9===B9</span><br><span class="line">  A10==&gt;B10</span><br><span class="line">  A11==text===B11</span><br><span class="line">  A12==text==&gt;B12</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">  A1--&gt;B1</span><br><span class="line">  A2---B2</span><br><span class="line">  A3--text---B3</span><br><span class="line">  A4--text--&gt;B4</span><br><span class="line">  A5-.-B5</span><br><span class="line">  A6-.-&gt;B6</span><br><span class="line">  A7-.text.-B7</span><br><span class="line">  A8-.text.-&gt;B8</span><br><span class="line">  A9===B9</span><br><span class="line">  A10==&gt;B10</span><br><span class="line">  A11==text===B11</span><br><span class="line">  A12==text==&gt;B12</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"> A ---B</span><br></pre></td></tr></tbody></table></figure><h5 id="子图表"><a href="#子图表" class="headerlink" title="子图表"></a>子图表</h5><p>使用以下语法添加子图表</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subgraph 子图表名称</span><br><span class="line"><span class="code">    子图表中的描述语句...</span></span><br><span class="line"><span class="code">end</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"><span class="code">  subgraph 买炸鸡前</span></span><br><span class="line"><span class="code">    begin(出门)--&gt; buy[出门买炸鸡]</span></span><br><span class="line"><span class="code">    end</span></span><br><span class="line"><span class="code">    buy --&gt; IsRemaining{"还有没有炸鸡？"}</span></span><br><span class="line"><span class="code">    IsRemaining --没有--&gt; sad["伤心"]--&gt; goBack(回家)</span></span><br><span class="line"><span class="code">    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">  subgraph 买炸鸡前</span><br><span class="line">    begin(出门)--&gt; buy[出门买炸鸡]</span><br><span class="line">    end</span><br><span class="line">    buy --&gt; IsRemaining{"还有没有炸鸡？"}</span><br><span class="line">    IsRemaining --没有--&gt; sad["伤心"]--&gt; goBack(回家)</span><br><span class="line">    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack</span><br></pre></td></tr></tbody></table></figure><h3 id="序列图-sequence-diagram"><a href="#序列图-sequence-diagram" class="headerlink" title="序列图(sequence diagram)"></a>序列图(sequence diagram)</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line"><span class="code">[参与者1][消息线][参与者2]:消息体</span></span><br><span class="line"><span class="code">    ...</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>sequenceDiagram</code> 为每幅时序图的固定开头</p></blockquote><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line"><span class="code">Title: 买炸鸡</span></span><br><span class="line"><span class="code">    救救-&gt;&gt;炸鸡店小哥: 还有炸鸡吗？</span></span><br><span class="line"><span class="code">    炸鸡店小哥--&gt;&gt;救救: 没有，要现炸</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">Title: 买炸鸡</span><br><span class="line">    救救-&gt;&gt;炸鸡店小哥: 还有炸鸡吗？</span><br><span class="line">    炸鸡店小哥--&gt;&gt;救救: 没有，要现炸</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="参与者（participant）"><a href="#参与者（participant）" class="headerlink" title="参与者（participant）"></a>参与者（participant）</h4><p>传统时序图概念中参与者有角色和类对象之分，但这里我们不做此区分，用参与者表示一切参与交互的事物，可以是人、类对象、系统等形式。中间竖直的线段从上至下表示时间的流逝。</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line"><span class="code">    participant 参与者 1</span></span><br><span class="line"><span class="code">    participant 参与者 2</span></span><br><span class="line"><span class="code">    ...</span></span><br><span class="line"><span class="code">    participant 简称 as 参与者 3 #该语法可以在接下来的描述中使用简称来代替参与者 3</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>participant &lt;参与者名称&gt;</code> 声明参与者，语句次序即为参与者横向排列次序。</p></blockquote><h4 id="消息线"><a href="#消息线" class="headerlink" title="消息线"></a>消息线</h4><table><thead><tr><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-&gt;</td><td align="left">无箭头的实线</td></tr><tr><td align="left">–&gt;</td><td align="left">无箭头的虚线</td></tr><tr><td align="left">-&gt;&gt;</td><td align="left">有箭头的实线（主动发出消息）</td></tr><tr><td align="left">–-&gt;&gt;</td><td align="left">有箭头的虚线（响应）</td></tr><tr><td align="left">-x</td><td align="left">末端为叉的实线（表示异步）</td></tr><tr><td align="left">–x</td><td align="left">末端为叉的虚线（表示异步）</td></tr></tbody></table><h4 id="处理中-激活框"><a href="#处理中-激活框" class="headerlink" title="处理中-激活框"></a>处理中-激活框</h4><p>从消息接收方的时间线上标记一小段时间，表示对消息进行处理的时间间隔。</p><p>在消息线末尾增加 <code>+</code> ，则消息接收者进入当前消息的“处理中”状态；<br>在消息线末尾增加 <code>-</code> ，则消息接收者离开当前消息的“处理中”状态。</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line"><span class="code">    participant 99 as 救救</span></span><br><span class="line"><span class="code">    participant seller as 炸鸡店小哥</span></span><br><span class="line"><span class="code">    99 -&gt;&gt; seller: 还有炸鸡吗？</span></span><br><span class="line"><span class="code">    seller --&gt;&gt; 99: 没有，要现炸。</span></span><br><span class="line"><span class="code">    99 -x +seller:给我炸！</span></span><br><span class="line"><span class="code">    seller --&gt;&gt; -99: 您的炸鸡好了！</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant 99 as 救救</span><br><span class="line">    participant seller as 炸鸡店小哥</span><br><span class="line">    99 -&gt;&gt; seller: 还有炸鸡吗？</span><br><span class="line">    seller --&gt;&gt; 99: 没有，要现炸。</span><br><span class="line">    99 -x +seller:给我炸！</span><br><span class="line">    seller --&gt;&gt; -99: 您的炸鸡好了！</span><br><span class="line">    </span><br></pre></td></tr></tbody></table></figure><h4 id="注解（note）"><a href="#注解（note）" class="headerlink" title="注解（note）"></a>注解（note）</h4><p>语法如下</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Note 位置表述 参与者: 标注文字</span><br></pre></td></tr></tbody></table></figure><p>其中位置表述可以为</p><table><thead><tr><th align="left">表述</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">right of</td><td align="left">右侧</td></tr><tr><td align="left">left of</td><td align="left">左侧</td></tr><tr><td align="left">over</td><td align="left">在当中，可以横跨多个参与者</td></tr></tbody></table><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line"><span class="code">    participant 99 as 救救</span></span><br><span class="line"><span class="code">    participant seller as 炸鸡店小哥</span></span><br><span class="line"><span class="code">    Note over 99,seller : 热爱炸鸡</span></span><br><span class="line"><span class="code">    Note left of 99 : 女</span></span><br><span class="line"><span class="code">    Note right of seller : 男</span></span><br><span class="line"><span class="code">    99 -&gt;&gt; seller: 还有炸鸡吗？</span></span><br><span class="line"><span class="code">    seller --&gt;&gt; 99: 没有，要现炸。</span></span><br><span class="line"><span class="code">    99 -x +seller : 给我炸！</span></span><br><span class="line"><span class="code">    seller --&gt;&gt; -99: 您的炸鸡好了！</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant 99 as 救救</span><br><span class="line">    participant seller as 炸鸡店小哥</span><br><span class="line">    Note over 99,seller : 热爱炸鸡</span><br><span class="line">    Note left of 99 : 女</span><br><span class="line">    Note right of seller : 男</span><br><span class="line">    99 -&gt;&gt; seller: 还有炸鸡吗？</span><br><span class="line">    seller --&gt;&gt; 99: 没有，要现炸。</span><br><span class="line">    99 -x +seller : 给我炸！</span><br><span class="line">    seller --&gt;&gt; -99: 您的炸鸡好了！</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="循环（loop）"><a href="#循环（loop）" class="headerlink" title="循环（loop）"></a>循环（loop）</h4><p>在条件满足时，重复发出消息序列。（相当于编程语言中的 while 语句。）</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line"><span class="code">    participant 99 as 救救</span></span><br><span class="line"><span class="code">    participant seller as 炸鸡店小哥</span></span><br><span class="line"><span class="code">   </span></span><br><span class="line"><span class="code">    99 -&gt;&gt; seller: 还有炸鸡吗？</span></span><br><span class="line"><span class="code">    seller --&gt;&gt; 99: 没有，要现炸。</span></span><br><span class="line"><span class="code">    99 -&gt;&gt; +seller:给我炸！</span></span><br><span class="line"><span class="code">    loop 三分钟一次</span></span><br><span class="line"><span class="code">        99 -&gt;&gt; seller : 我的炸鸡好了吗？</span></span><br><span class="line"><span class="code">        seller --&gt;&gt; 99 : 正在炸</span></span><br><span class="line"><span class="code">    end</span></span><br><span class="line"><span class="code">    seller --&gt;&gt; -99: 您的炸鸡好了！</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant 99 as 救救</span><br><span class="line">    participant seller as 炸鸡店小哥</span><br><span class="line">   </span><br><span class="line">    99 -&gt;&gt; seller: 还有炸鸡吗？</span><br><span class="line">    seller --&gt;&gt; 99: 没有，要现炸。</span><br><span class="line">    99 -&gt;&gt; +seller:给我炸！</span><br><span class="line">    loop 三分钟一次</span><br><span class="line">        99 -&gt;&gt; seller : 我的炸鸡好了吗？</span><br><span class="line">        seller --&gt;&gt; 99 : 正在炸</span><br><span class="line">    end</span><br><span class="line">    seller --&gt;&gt; -99: 您的炸鸡好了！</span><br></pre></td></tr></tbody></table></figure><h4 id="选择（alt）"><a href="#选择（alt）" class="headerlink" title="选择（alt）"></a>选择（alt）</h4><p>在多个条件中作出判断，每个条件将对应不同的消息序列。（相当于 if 及 else if 语句。）</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram    </span><br><span class="line"><span class="code">    participant 99 as 救救</span></span><br><span class="line"><span class="code">    participant seller as 炸鸡店小哥</span></span><br><span class="line"><span class="code">    99 -&gt;&gt; seller : 现在就多少只炸好的炸鸡？</span></span><br><span class="line"><span class="code">    seller --&gt;&gt; 99 : 可卖的炸鸡数</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    alt 可卖的炸鸡数 &gt; 3</span></span><br><span class="line"><span class="code">        99 -&gt;&gt; seller : 买三只！</span></span><br><span class="line"><span class="code">    else 1 &lt; 可卖的炸鸡数 &lt; 3</span></span><br><span class="line"><span class="code">        99 -&gt;&gt; seller : 有多少买多少</span></span><br><span class="line"><span class="code">    else 可卖的炸鸡数 &lt; 1</span></span><br><span class="line"><span class="code">        99 -&gt;&gt; seller : 那我明天再来</span></span><br><span class="line"><span class="code">    end</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    seller --&gt;&gt; 99 : 欢迎下次光临</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram    </span><br><span class="line">    participant 99 as 救救</span><br><span class="line">    participant seller as 炸鸡店小哥</span><br><span class="line">    99 -&gt;&gt; seller : 现在就多少只炸好的炸鸡？</span><br><span class="line">    seller --&gt;&gt; 99 : 可卖的炸鸡数</span><br><span class="line">    </span><br><span class="line">    alt 可卖的炸鸡数 &gt; 3</span><br><span class="line">        99 -&gt;&gt; seller : 买三只！</span><br><span class="line">    else 1 &lt; 可卖的炸鸡数 &lt; 3</span><br><span class="line">        99 -&gt;&gt; seller : 有多少买多少</span><br><span class="line">    else 可卖的炸鸡数 &lt; 1</span><br><span class="line">        99 -&gt;&gt; seller : 那我明天再来</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    seller --&gt;&gt; 99 : 欢迎下次光临</span><br></pre></td></tr></tbody></table></figure><h4 id="可选（opt）"><a href="#可选（opt）" class="headerlink" title="可选（opt）"></a>可选（opt）</h4><p>在某条件满足时执行消息序列，否则不执行。相当于单个分支的 if 语句。</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line"><span class="code">    participant 99 as 救救</span></span><br><span class="line"><span class="code">    participant seller as 炸鸡店小哥</span></span><br><span class="line"><span class="code">    99 -&gt;&gt; seller : 买炸鸡</span></span><br><span class="line"><span class="code">    opt 全都卖完了</span></span><br><span class="line"><span class="code">        seller --&gt;&gt; 99 : 下次再来</span></span><br><span class="line"><span class="code">    end</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant 99 as 救救</span><br><span class="line">    participant seller as 炸鸡店小哥</span><br><span class="line">    99 -&gt;&gt; seller : 买炸鸡</span><br><span class="line">    opt 全都卖完了</span><br><span class="line">        seller --&gt;&gt; 99 : 下次再来</span><br><span class="line">    end</span><br></pre></td></tr></tbody></table></figure><h4 id="并行（Par）"><a href="#并行（Par）" class="headerlink" title="并行（Par）"></a>并行（Par）</h4><p>将消息序列分成多个片段，这些片段并行执行。</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">   participant 99 as 救救</span><br><span class="line">   participant seller as 炸鸡店小哥</span><br><span class="line">   </span><br><span class="line"><span class="code">    99 -&gt;&gt; seller : 一个炸鸡，一杯可乐！</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    par 并行执行</span></span><br><span class="line"><span class="code">        seller -&gt;&gt; seller : 装可乐</span></span><br><span class="line"><span class="code">    and</span></span><br><span class="line"><span class="code">        seller -&gt;&gt; seller : 炸炸鸡</span></span><br><span class="line"><span class="code">    end</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    seller --&gt;&gt; 99 : 您的炸鸡好了！</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">   participant 99 as 救救</span><br><span class="line">   participant seller as 炸鸡店小哥</span><br><span class="line">   </span><br><span class="line">    99 -&gt;&gt; seller : 一个炸鸡，一杯可乐！</span><br><span class="line"></span><br><span class="line">    par 并行执行</span><br><span class="line">        seller -&gt;&gt; seller : 装可乐</span><br><span class="line">    and</span><br><span class="line">        seller -&gt;&gt; seller : 炸炸鸡</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    seller --&gt;&gt; 99 : 您的炸鸡好了！</span><br></pre></td></tr></tbody></table></figure><h3 id="饼图（Pie）"><a href="#饼图（Pie）" class="headerlink" title="饼图（Pie）"></a>饼图（Pie）</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pie</span><br><span class="line"><span class="code">    title Pie Chart</span></span><br><span class="line"><span class="code">    "Dogs" : 386</span></span><br><span class="line"><span class="code">    "Cats" : 85</span></span><br><span class="line"><span class="code">    "Rats" : 150 </span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pie</span><br><span class="line">    title Pie Chart</span><br><span class="line">    "Dogs" : 386</span><br><span class="line">    "Cats" : 85</span><br><span class="line">    "Rats" : 150 </span><br><span class="line">    "panda" : 200</span><br></pre></td></tr></tbody></table></figure><blockquote><p><a href="http://support.typora.io/Draw-Diagrams-With-Markdown/">Typora支持mermaid的官方链接</a></p></blockquote><h3 id="甘特图（gantt）"><a href="#甘特图（gantt）" class="headerlink" title="甘特图（gantt）"></a>甘特图（gantt）</h3><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> title 标题</span><br><span class="line">dateFormat 日期格式</span><br><span class="line">section 部分名</span><br><span class="line">任务名:参数一, 参数二, 参数三, 参数四，参数五</span><br><span class="line"></span><br><span class="line"> //参数一：crit（是否重要，红框框） 或者 不填</span><br><span class="line"> //参数二：done（已完成）、active（正在进行） 或者 不填(表示为待完成状态)</span><br><span class="line"> //参数三：取小名 或者 不填</span><br><span class="line"> //参数四：任务开始时间</span><br><span class="line"> //参数五：任务结束时间</span><br></pre></td></tr></tbody></table></figure><blockquote><p><a href="https://mermaid-js.github.io/mermaid/#/gantt">官方教程</a></p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">       dateFormat  YYYY-MM-DD</span><br><span class="line">       title Adding GANTT diagram functionality to mermaid</span><br><span class="line"></span><br><span class="line">       section A section</span><br><span class="line">       Completed task            :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">       Active task               :active,  des2, 2014-01-09, 3d</span><br><span class="line">       Future task               :         des3, after des2, 5d</span><br><span class="line">       Future task2              :         des4, after des3, 5d</span><br><span class="line"></span><br><span class="line">       section Critical tasks</span><br><span class="line">       Completed task in the critical line :crit, done, 2014-01-06,24h</span><br><span class="line">       Implement parser and jison          :crit, done, after des1, 2d</span><br><span class="line">       Create tests for parser             :crit, active, 3d</span><br><span class="line">       Future task in critical line        :crit, 5d</span><br><span class="line">       Create tests for renderer           :2d</span><br><span class="line">       Add to mermaid                      :1d</span><br><span class="line"></span><br><span class="line">       section Documentation</span><br><span class="line">       Describe gantt syntax               :active, a1, after des1, 3d</span><br><span class="line">       Add gantt diagram to demo page      :after a1  , 20h</span><br><span class="line">       Add another diagram to demo page    :doc1, after a1  , 48h</span><br><span class="line"></span><br><span class="line">       section Last section</span><br><span class="line">       Describe gantt syntax               :after doc1, 3d</span><br><span class="line">       Add gantt diagram to demo page      :20h</span><br><span class="line">       Add another diagram to demo page    :48h</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">       dateFormat  YYYY-MM-DD</span><br><span class="line">       title Adding GANTT diagram functionality to mermaid</span><br><span class="line"></span><br><span class="line">       section A section</span><br><span class="line">       Completed task            :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">       Active task               :active,  des2, 2014-01-09, 3d</span><br><span class="line">       Future task               :         des3, after des2, 5d</span><br><span class="line">       Future task2              :         des4, after des3, 5d</span><br><span class="line"></span><br><span class="line">       section Critical tasks</span><br><span class="line">       Completed task in the critical line :crit, done, 2014-01-06,24h</span><br><span class="line">       Implement parser and jison          :crit, done, after des1, 2d</span><br><span class="line">       Create tests for parser             :crit, active, 3d</span><br><span class="line">       Future task in critical line        :crit, 5d</span><br><span class="line">       Create tests for renderer           :2d</span><br><span class="line">       Add to mermaid                      :1d</span><br><span class="line"></span><br><span class="line">       section Documentation</span><br><span class="line">       Describe gantt syntax               :active, a1, after des1, 3d</span><br><span class="line">       Add gantt diagram to demo page      :after a1  , 20h</span><br><span class="line">       Add another diagram to demo page    :doc1, after a1  , 48h</span><br><span class="line"></span><br><span class="line">       section Last section</span><br><span class="line">       Describe gantt syntax               :after doc1, 3d</span><br><span class="line">       Add gantt diagram to demo page      :20h</span><br><span class="line">       Add another diagram to demo page    :48h</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="Typora快捷方式（系统默认）"><a href="#Typora快捷方式（系统默认）" class="headerlink" title="Typora快捷方式（系统默认）"></a>Typora快捷方式（系统默认）</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><table><thead><tr><th align="left">功能</th><th align="left">热键 (Windows/Linux)</th><th>热键 (macOS)</th></tr></thead><tbody><tr><td align="left">新建</td><td align="left">Ctrl + N</td><td>Command  + N</td></tr><tr><td align="left">新窗口</td><td align="left">Ctrl + Shift + N</td><td>Command  +Shift + N</td></tr><tr><td align="left">新标签</td><td align="left"><em>（不支持）</em></td><td>Command  + T</td></tr><tr><td align="left">打开</td><td align="left">Ctrl + O</td><td>Command  + O</td></tr><tr><td align="left">快速打开</td><td align="left">Ctrl + P</td><td>Command  + Shift + O</td></tr><tr><td align="left">重新打开关闭的文件</td><td align="left">Ctrl + Shift + T</td><td>Command  + Shift + T</td></tr><tr><td align="left">保存</td><td align="left">Ctrl + S</td><td>Command  + S</td></tr><tr><td align="left">另存为/复制</td><td align="left">Ctrl + Shift + S</td><td>Command + Shift + S</td></tr><tr><td align="left">关闭</td><td align="left">Ctrl + W</td><td>Command  + W</td></tr></tbody></table><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><table><thead><tr><th align="left">功能</th><th align="left">热键 (Windows/Linux)</th><th>热键 (macOS)</th></tr></thead><tbody><tr><td align="left">新段落</td><td align="left">Enter</td><td>Enter</td></tr><tr><td align="left">新行</td><td align="left">Shift + Enter</td><td>Shift + Enter</td></tr><tr><td align="left">剪切</td><td align="left">Ctrl + X</td><td>Command  + X</td></tr><tr><td align="left">复制</td><td align="left">Ctrl + C</td><td>Command  + C</td></tr><tr><td align="left">粘贴</td><td align="left">Ctrl + V</td><td>Command  + V</td></tr><tr><td align="left">复制为 Markdown</td><td align="left">Ctrl + Shift + C</td><td>Command + Shift + C</td></tr><tr><td align="left">粘贴为纯文本</td><td align="left">Ctrl + Shift + V</td><td>Command + Shift + V</td></tr><tr><td align="left">全选</td><td align="left">Ctrl + A</td><td>Command + A</td></tr><tr><td align="left">选择行/句子 选择行（在表格中）</td><td align="left">Ctrl + L</td><td>Command + L</td></tr><tr><td align="left">删除行（在表中）</td><td align="left">Ctrl + Shift + Backspace</td><td>Command + Shift + Backspace</td></tr><tr><td align="left">选择样式范围 选择单元格（在表格中）</td><td align="left">Ctrl + E</td><td>Command + E</td></tr><tr><td align="left">选择单词</td><td align="left">Ctrl + D</td><td>Command + D</td></tr><tr><td align="left">删除单词</td><td align="left">Ctrl + Shift + D</td><td>Command + Shift + D</td></tr><tr><td align="left">跳到顶部</td><td align="left">Ctrl + home</td><td>Command + ↑</td></tr><tr><td align="left">跳转到选择</td><td align="left">Ctrl + J</td><td>Command + J</td></tr><tr><td align="left">跳到底部</td><td align="left">Ctrl + end</td><td>Command + ↓</td></tr><tr><td align="left">寻找</td><td align="left">Ctrl + F</td><td>Command + F</td></tr><tr><td align="left">找下一个</td><td align="left">F3 / Enter</td><td>Command + G / Enter</td></tr><tr><td align="left">查找上一个</td><td align="left">Shift + F3 / Shift + Enter</td><td>Command + Shift + G / Shift + Enter</td></tr><tr><td align="left">代替</td><td align="left">Ctrl + H</td><td>Command + H</td></tr></tbody></table><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><table><thead><tr><th align="left">功能</th><th align="left">热键 (Windows/Linux)</th><th>热键 (macOS)</th></tr></thead><tbody><tr><td align="left">标题 1 至 6</td><td align="left">Ctrl + 1/2/3/4/5/6</td><td>Command + 1/2/3/4/5/6</td></tr><tr><td align="left">增加标题级别</td><td align="left">Ctrl + =</td><td>Command + =</td></tr><tr><td align="left">降低标题级别</td><td align="left">Ctrl + -</td><td>Command  + -</td></tr><tr><td align="left">桌子</td><td align="left">Ctrl + T</td><td>Command + Option + T</td></tr><tr><td align="left">代码围栏</td><td align="left">Ctrl + Shift + K</td><td>Command  + Option + C</td></tr><tr><td align="left">数学块</td><td align="left">Ctrl + Shift + M</td><td>Command + Option + B</td></tr><tr><td align="left">引用</td><td align="left">Ctrl + Shift + Q</td><td>Command  + Option + Q</td></tr><tr><td align="left">有序列表</td><td align="left">Ctrl + Shift + [</td><td>Command + Option + O</td></tr><tr><td align="left">无序列表</td><td align="left">Ctrl + Shift + ]</td><td>Command + Option + U</td></tr><tr><td align="left">缩进一个制表符</td><td align="left">Ctrl + [ / Tab</td><td>Command + [ / Tab</td></tr><tr><td align="left">前进一个制表符</td><td align="left">Ctrl + ] / Shift + Tab</td><td>Command + ] / Shift + Tab</td></tr></tbody></table><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><table><thead><tr><th align="left">功能</th><th align="left">热键 (Windows/Linux)</th><th>热键 (macOS)</th></tr></thead><tbody><tr><td align="left">字体加粗</td><td align="left">Ctrl + B</td><td>Command + B</td></tr><tr><td align="left">斜体</td><td align="left">Ctrl + I</td><td>Command +I</td></tr><tr><td align="left">下划线</td><td align="left">Ctrl + U</td><td>Command + U</td></tr><tr><td align="left">代码</td><td align="left">Ctrl + Shift + `</td><td>Command + Shift + `</td></tr><tr><td align="left">删除线</td><td align="left">Alt + Shift + 5</td><td>Control+ Shift + `</td></tr><tr><td align="left">超链接</td><td align="left">Ctrl + K</td><td>Command  + K</td></tr><tr><td align="left">图片</td><td align="left">Ctrl + Shift + I</td><td>Command +Control+I</td></tr><tr><td align="left">清除格式</td><td align="left">Ctrl + \</td><td>Command + \</td></tr></tbody></table><h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><table><thead><tr><th align="left">功能</th><th align="left">热键 (Windows/Linux)</th><th>热键 (macOS)</th></tr></thead><tbody><tr><td align="left">切换侧边栏</td><td align="left">Ctrl + Shift + L</td><td>Command + Shift + L</td></tr><tr><td align="left">显示大纲</td><td align="left">Ctrl + Shift + 1</td><td>Command + 控制 + 1</td></tr><tr><td align="left">显示文件</td><td align="left">Ctrl + Shift + 2</td><td>Command + 控制 + 2</td></tr><tr><td align="left">显示文件树</td><td align="left">Ctrl + Shift + 3</td><td>Command + 控制 + 3</td></tr><tr><td align="left">源代码模式(再次取消)</td><td align="left">Ctrl + /</td><td>Command + /</td></tr><tr><td align="left">对焦模式</td><td align="left">F8</td><td>F8</td></tr><tr><td align="left">打字机模式</td><td align="left">F9</td><td>F9</td></tr><tr><td align="left">切换全屏</td><td align="left">F11</td><td>Command + Option + F</td></tr><tr><td align="left">真实大小</td><td align="left">Ctrl + Shift + 0</td><td><em>（不支持）</em></td></tr><tr><td align="left">放大</td><td align="left">Ctrl + Shift + =</td><td><em>（不支持）</em></td></tr><tr><td align="left">缩小</td><td align="left">Ctrl + Shift + -</td><td><em>（不支持）</em></td></tr><tr><td align="left">在打开的文档之间切换</td><td align="left">Ctrl + Tab</td><td>命令 + `</td></tr></tbody></table><h2 id="Typora自定义快捷方式"><a href="#Typora自定义快捷方式" class="headerlink" title="Typora自定义快捷方式"></a>Typora自定义快捷方式</h2><p>Typora有些功能是没有快捷键的，需要使用者自定义。这里以给<code>内联公式</code>设置快捷键为例，讲解如何自定义快捷键。</p><h3 id="给内联公式设置自定义快捷方式"><a href="#给内联公式设置自定义快捷方式" class="headerlink" title="给内联公式设置自定义快捷方式"></a>给内联公式设置自定义快捷方式</h3><ol><li>在进行设置前，推荐将软件的语言设置称英语，理由后面再说。具体操作:<br>文 件 ⟹ 偏 好 设 置 ⟹ 通 用 ⟹ 语 言 ， 选 择 ‘ English ’ ， 重 新 启 动 。</li><li>重新启动完成后，查看二级菜单中<code>内联公式</code>的英文名称是<code>Inline Math</code>，记下该拼写。<img src="https://img-blog.csdnimg.cn/20210626224751567.png#pic_center" alt="img"></li><li>再次打开<code>偏好设置</code>（快捷键<code>Ctrl+,</code>），在<code>通用</code>中找到<code>高级设置</code>，具体操作：File ⟹ Preferences ⟹ General ⟹ Open Advanced Setting</li></ol><p><img src="https://img-blog.csdnimg.cn/20210626225203912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1FDU1lTWlE=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ol start="4"><li><p>之后会显示一个文件夹，有两个配置文件，选择<code>conf.user.json</code>（在另一个文件中设置无效），打开之后找到<code>keyBinding</code>，在下面添加<code>"Inline Math":"Ctrl+M"</code>（这里的快捷键我设置成了<code>Ctrl +M</code>，在保证快捷键不冲突的条件下，可以随意设置），如图所示</p><p><img src="https://img-blog.csdnimg.cn/20210626225840503.png#pic_center" alt="在这里插入图片描述"></p></li></ol><p>保存配置文件，重启Typora，可以发现在选项<code>Inline Math</code>旁边显示了快捷键<code>Ctrl +M</code>，经过测试快捷键能正常使用。</p><h3 id="为什么不在中文环境下配置？"><a href="#为什么不在中文环境下配置？" class="headerlink" title="为什么不在中文环境下配置？"></a>为什么不在中文环境下配置？</h3><p>在中文环境下，也可以进行设置，在配置文件中添加<code>"内联公式":"Ctrl+M"</code>，也可以换成<code>"Inline Math":"Ctrl+M"</code>，在不知道菜单选项的英文名称时可以直接写上对应的中文名称（所以推荐在开始设置前将Typora设置成英文环境，便于查看菜单项的英文名称），如</p><p><img src="https://img-blog.csdnimg.cn/20210626231115945.png#pic_center" alt="在这里插入图片描述"></p><p>重启Typora</p><p><img src="https://img-blog.csdnimg.cn/20210626231529681.png#pic_center" alt="在这里插入图片描述"></p><p>中文菜单<code>内联公式</code>旁出现了设置的快捷键，表示快捷键设置成功。<br>但是我如果心血来潮，想切换成英文环境，再查看菜单项的快捷键时发现快捷键没有了</p><p><img src="https://img-blog.csdnimg.cn/20210626231943998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1FDU1lTWlE=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>如果当初我在配置文件中使用<code>"Inline Math":"Ctrl+M"</code>，不使用中文的名称，无论我将Typora的语言环境设置成何种语言，都不会影响自定义快捷键的使用。</p>]]></content>
      
      
      <categories>
          
          <category> MarkDown性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
