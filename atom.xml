<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>相遇之初</title>
  
  <subtitle>ouyang</subtitle>
  <link href="https://ouyujia.github.io/atom.xml" rel="self"/>
  
  <link href="https://ouyujia.github.io/"/>
  <updated>2023-04-28T09:12:14.974Z</updated>
  <id>https://ouyujia.github.io/</id>
  
  <author>
    <name>欧阳</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>QT串口通讯错误码解析</title>
    <link href="https://ouyujia.github.io/2023/05/01/QT%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF%E9%94%99%E8%AF%AF%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://ouyujia.github.io/2023/05/01/QT%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF%E9%94%99%E8%AF%AF%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2023-05-01T08:43:26.000Z</published>
    <updated>2023-04-28T09:12:14.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>项目使用qt串口接口QSerialPort进行串口通讯，生产反馈产品提示串口通讯异常，查看log发现有3个错误码</p><p>分别是PermissionError(2)、WriteError(7)、UnknownError(11)。后面分析日志、了解生产情况找到了问题点。</p><blockquote><ul><li>PermissionError原因：串口占用，生产电脑上面先跑了串口调试工具导致串口打开失败</li><li>WriteError及UnknownError原因：（这连个错误是同时出现的额，先报WriteError后面紧跟UnknownError）通过对比日志发现是Windows自动睡眠后再次唤醒出现的。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682670665137.png" alt="1682670665137"></p></blockquote><h3 id="QT串口通讯错误码及机翻"><a href="#QT串口通讯错误码及机翻" class="headerlink" title="QT串口通讯错误码及机翻"></a>QT串口通讯错误码及机翻</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SerialPortError</span> {</span><br><span class="line">        NoError, <span class="comment">// 没有错误</span></span><br><span class="line">    </span><br><span class="line">        DeviceNotFoundError,<span class="comment">// 试图打开不存在的设备时发生错误。</span></span><br><span class="line">    </span><br><span class="line">        PermissionError,<span class="comment">// 1、试图打开另一个进程已打开的设备时</span></span><br><span class="line">    <span class="comment">// 2、用户没有足够的权限和凭据打开时发生错误。</span></span><br><span class="line">    </span><br><span class="line">        OpenError,<span class="comment">// 试图打开本进程中已打开的设备时发生错误。</span></span><br><span class="line">    </span><br><span class="line">        ParityError,<span class="comment">// 读取数据时，硬件检测到奇偶校验错误。</span></span><br><span class="line">    <span class="comment">// 这个值已经过时了。我们强烈建议不要在新代码中使用它。</span></span><br><span class="line">    </span><br><span class="line">        FramingError,<span class="comment">// 读取数据时硬件检测到帧错误。</span></span><br><span class="line">    <span class="comment">// 这个值已经过时了。我们强烈建议不要在新代码中使用它。</span></span><br><span class="line">    </span><br><span class="line">        BreakConditionError,<span class="comment">// 硬件在输入线上检测到断路情况。</span></span><br><span class="line">    <span class="comment">// 这个值已经过时了。我们强烈建议不要在新代码中使用它。</span></span><br><span class="line">    </span><br><span class="line">        WriteError,<span class="comment">// 写入数据时发生I/O错误。</span></span><br><span class="line">    </span><br><span class="line">        ReadError,<span class="comment">// 读取数据时发生I/O错误。</span></span><br><span class="line">    </span><br><span class="line">        ResourceError,<span class="comment">// 当资源不可用时发生I/O错误，例如当设备意外地从系统中移除时。</span></span><br><span class="line">    </span><br><span class="line">        UnsupportedOperationError, <span class="comment">//当前操作系统不支持或不禁止所请求的设备操作。</span></span><br><span class="line">    </span><br><span class="line">        UnknownError,<span class="comment">// 发生了一个无法识别的错误。</span></span><br><span class="line">    </span><br><span class="line">        TimeoutError,<span class="comment">// 发生超时错误。这个值是在QtSerialPort 5.2中引入的。</span></span><br><span class="line">    </span><br><span class="line">        NotOpenError<span class="comment">// 当执行的操作只有在设备打开的情况下才能成功执行时，会发生此错误。</span></span><br><span class="line">            <span class="comment">// 这个值是在QtSerialPort 5.2中引入的。</span></span><br><span class="line">    };</span><br></pre></td></tr></tbody></table></figure><h3 id="串口错误码处理"><a href="#串口错误码处理" class="headerlink" title="串口错误码处理"></a>串口错误码处理</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">m_uart = <span class="keyword">new</span> <span class="built_in">QSerialPort</span>();  <span class="comment">//不能指定父对象</span></span><br><span class="line"><span class="comment">//! 连接串口通信错误信号</span></span><br><span class="line"><span class="built_in">connect</span>(m_uart, <span class="built_in">SIGNAL</span>(<span class="built_in">errorOccurred</span>(QSerialPort::SerialPortError)), <span class="keyword">this</span>,</span><br><span class="line">        <span class="built_in">SLOT</span>(<span class="built_in">errorFunc</span>(QSerialPort::SerialPortError)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//! 串口通信错误吗处理接口 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UartPortThread::errorFunc</span><span class="params">(QSerialPort::SerialPortError error)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (error != QSerialPort::NoError &amp;&amp; error != QSerialPort::TimeoutError</span><br><span class="line">            &amp;&amp; error != QSerialPort::NotOpenError &amp;&amp; error !=      QSerialPort::DeviceNotFoundError)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; Q_FUNC_INFO &lt;&lt; QString::<span class="built_in">number</span>(error) &lt;&lt; <span class="string">"error...."</span>;</span><br><span class="line">        m_needReconnect = <span class="literal">true</span>;</span><br><span class="line">        <span class="function">emit <span class="title">uartConnectState</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">setPortName</span>(<span class="string">""</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;项目使用qt串口接口QSerialPort进行串口通讯，生产反馈产品提示串口通讯异常，查看log发现有3个错误码&lt;/p&gt;
&lt;p&gt;分别是Per</summary>
      
    
    
    
    <category term="QT" scheme="https://ouyujia.github.io/categories/QT/"/>
    
    
    <category term="QT" scheme="https://ouyujia.github.io/tags/QT/"/>
    
    <category term="串口" scheme="https://ouyujia.github.io/tags/%E4%B8%B2%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>QT使用MingW编译器添加Dump调试功能</title>
    <link href="https://ouyujia.github.io/2023/04/28/QTMingW%E6%B7%BBDump%E5%8A%9F%E8%83%BD/"/>
    <id>https://ouyujia.github.io/2023/04/28/QTMingW%E6%B7%BBDump%E5%8A%9F%E8%83%BD/</id>
    <published>2023-04-28T08:43:26.000Z</published>
    <updated>2023-04-28T09:00:30.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>最近因为维护的项目出现崩溃，客户现场的log无法定位，因此需要使用dump文件调试于是查找资料添加了一个崩溃生成dump文件功能</p></blockquote><hr><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><blockquote><p>Qt5.12.9-MingW版本/Qt5.5.1-MingW版本，Visual Studio 2017/Visual Studio 2013，Windows系统</p></blockquote><hr><h2 id="配置pro文件，在exe文件加入调试信息"><a href="#配置pro文件，在exe文件加入调试信息" class="headerlink" title="配置pro文件，在exe文件加入调试信息"></a>配置pro文件，在exe文件加入调试信息</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QMAKE_CFLAGS_RELEASE += -g</span><br><span class="line">QMAKE_CXXFLAGS_RELEASE += -g</span><br><span class="line">#禁止优化</span><br><span class="line">QMAKE_CFLAGS_RELEASE -= -O2</span><br><span class="line">QMAKE_CXXFLAGS_RELEASE -= -O2</span><br><span class="line">QMAKE_LFLAGS_RELEASE = -mthreads -W</span><br><span class="line">#生成dump文件需要</span><br><span class="line">LIBS += -lDbgHelp</span><br><span class="line">#加上下面两行，否则用vs调试时，提示“未找到xxx.exe<span class="string">"</span></span><br><span class="line"><span class="string">QMAKE_CXXFLAGS += -g</span></span><br><span class="line"><span class="string">QMAKE_CFLAGS += -g</span></span><br></pre></td></tr></tbody></table></figure><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDir&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;qdebug.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDateTime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;qglobal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMap&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_WIN</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dbghelp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_WIN</span></span><br><span class="line"><span class="comment">//! 异常处理回调（崩溃时自动调用）</span></span><br><span class="line"><span class="function"><span class="type">static</span> LONG WINAPI <span class="title">exceptionCallback</span><span class="params">(<span class="keyword">struct</span> _EXCEPTION_POINTERS* exceptionInfo)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QCoreApplication *app = QApplication::<span class="built_in">instance</span>();</span><br><span class="line"></span><br><span class="line">    QString savePath = app-&gt;<span class="built_in">applicationDirPath</span>() + <span class="string">"dump/"</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"save path :"</span>&lt;&lt;savePath;</span><br><span class="line">    <span class="function">QDir <span class="title">dir</span><span class="params">(savePath)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!dir.<span class="built_in">exists</span>() &amp;&amp; !dir.<span class="built_in">mkpath</span>(savePath)) {</span><br><span class="line">        app-&gt;<span class="built_in">exit</span>(E_UNEXPECTED);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_EXECUTE_HANDLER;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    savePath.<span class="built_in">append</span>(<span class="string">"assit_"</span>);</span><br><span class="line">    savePath.<span class="built_in">append</span>(QDateTime::<span class="built_in">currentDateTime</span>().<span class="built_in">toString</span>(<span class="string">"yyyyMMddhhmmsszzz"</span>));</span><br><span class="line">    savePath.<span class="built_in">append</span>(<span class="string">".dmp"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建dump文件</span></span><br><span class="line">    HANDLE dump = <span class="built_in">CreateFileW</span>(savePath.<span class="built_in">toStdWString</span>().<span class="built_in">c_str</span>(), GENERIC_WRITE,</span><br><span class="line">        <span class="number">0</span>, <span class="literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (INVALID_HANDLE_VALUE == dump) {</span><br><span class="line">        app-&gt;<span class="built_in">exit</span>(E_UNEXPECTED);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_EXECUTE_HANDLER;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    MINIDUMP_EXCEPTION_INFORMATION miniDumpExceptionInfo;</span><br><span class="line">    miniDumpExceptionInfo.ExceptionPointers = exceptionInfo;</span><br><span class="line">    miniDumpExceptionInfo.ThreadId = <span class="built_in">GetCurrentThreadId</span>();</span><br><span class="line">    miniDumpExceptionInfo.ClientPointers = TRUE;</span><br><span class="line">    DWORD idProcess = <span class="built_in">GetCurrentProcessId</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将崩溃信息写入dump文件中</span></span><br><span class="line">    <span class="built_in">MiniDumpWriteDump</span>(<span class="built_in">GetCurrentProcess</span>(), idProcess, dump,</span><br><span class="line">        MiniDumpNormal, &amp;miniDumpExceptionInfo, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(dump);</span><br><span class="line"></span><br><span class="line">    app-&gt;<span class="built_in">exit</span>(E_UNEXPECTED);</span><br><span class="line">    <span class="keyword">return</span> EXCEPTION_EXECUTE_HANDLER;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//! 空指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">crashNullPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//空指针测试</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span>* p_a = (<span class="type">int</span>*)(<span class="literal">NULL</span>); *p_a = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//! 悬浮指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">crashFloatPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span>* p_a = &amp;a;</span><br><span class="line">    <span class="keyword">delete</span> p_a;</span><br><span class="line">    *p_a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"*p_a :"</span>&lt;&lt; *p_a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//! 野指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">crashWildPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span>* p_a;</span><br><span class="line">    *p_a = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"*p_a :"</span>&lt;&lt; *p_a;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//! array越界</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ArrayExceed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">2</span>] = {<span class="number">0</span>, <span class="number">1</span>};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        arr[i] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"arr[i]"</span>&lt;&lt; arr[i];</span><br><span class="line">    }</span><br><span class="line">    arr[<span class="number">1000</span>] = <span class="number">11111</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"arr[10000]"</span>&lt;&lt; arr[<span class="number">10000</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Vector越界</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VectorExceed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; vec = {<span class="number">0</span>, <span class="number">1</span>};</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        value = vec.<span class="built_in">at</span>(i);</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"arr.at(i)"</span>&lt;&lt; value;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"arr[10000]"</span>&lt;&lt; vec.<span class="built_in">at</span>(<span class="number">10000</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Vector越界</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VectorExceed2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; vec = {<span class="number">0</span>, <span class="number">1</span>};</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        vec[i] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"arr[i]"</span>&lt;&lt; vec[i];</span><br><span class="line">    }</span><br><span class="line">    vec[<span class="number">1000</span>] = <span class="number">11111</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"arr[10000]"</span>&lt;&lt; vec[<span class="number">10000</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//! list越界</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListExceed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QList&lt;<span class="type">int</span>&gt; list = {<span class="number">0</span>, <span class="number">1</span>};</span><br><span class="line">    list[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Map</span></span><br><span class="line"><span class="comment">//void MapExceed()</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//    QMap&lt;int, QString&gt; map;</span></span><br><span class="line"><span class="comment">//    map.insert(0, "frist");</span></span><br><span class="line"><span class="comment">//    map.insert(1, "second");</span></span><br><span class="line"><span class="comment">//    map.remove(3);</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_WIN</span></span><br><span class="line">    <span class="comment">//! 注册异常奔溃回调</span></span><br><span class="line">    <span class="built_in">SetUnhandledExceptionFilter</span>(exceptionCallback);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//测试接口</span></span><br><span class="line"><span class="comment">//    crashNullPtr();</span></span><br><span class="line"><span class="comment">//    crashFloatPtr();</span></span><br><span class="line"><span class="comment">//    crashWildPtr();</span></span><br><span class="line"><span class="comment">//    ArrayExceed();</span></span><br><span class="line">    <span class="built_in">VectorExceed</span>();</span><br><span class="line"><span class="comment">//    VectorExceed2();</span></span><br><span class="line"><span class="comment">//    ListExceed();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="生成pdb文件"><a href="#生成pdb文件" class="headerlink" title="生成pdb文件"></a>生成pdb文件</h2><blockquote><p>注：WingW编译器并不会像MSVC一样自动生成pdb文件需要使用第三方工具生成。这里使用github开源工具<strong>cv2pdb.exe</strong>生成。</p></blockquote><h3 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h3><p><a href="https://github.com/rainers/cv2pdb">下载链接</a></p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682242797578.png" alt="1682242797578"></p><p>下载下来使用vs2017编译源码的到cv2pdb.exe文件。</p><h3 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h3><blockquote><p>使用命令行(cmd)</p><ol><li>打开命令行，cd到cv2pdb.exe文件路径下</li><li>执行指令 “cv2pdb.exe  xxx.exe”即可在xxx.exe同级路径下生成xxx.pdb文件</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682243028125.png" alt="1682243028125"></p><h3 id="出现错误："><a href="#出现错误：" class="headerlink" title="出现错误："></a>出现错误：</h3><blockquote><p><strong>qBreakpadTest.pdb: cannot load PDB helper DLL</strong></p></blockquote><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p><strong>错误原因：电脑没有安装Visual Studio环境</strong></p><blockquote><p>安装Visual Studio即可解决</p></blockquote><hr><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><hr><h3 id="使用Visual-Studio-IDE调试（推荐）"><a href="#使用Visual-Studio-IDE调试（推荐）" class="headerlink" title="使用Visual Studio IDE调试（推荐）"></a>使用Visual Studio IDE调试（推荐）</h3><h4 id="加载pdb文件"><a href="#加载pdb文件" class="headerlink" title="加载pdb文件"></a>加载pdb文件</h4><blockquote><p>使用Visual Studio打开需要调试的pdb文件(将exe文件和pdb放到同一目录下，然后设置符合路径)</p></blockquote><hr><h4 id="设置调试pdb目录位置"><a href="#设置调试pdb目录位置" class="headerlink" title="设置调试pdb目录位置"></a>设置调试pdb目录位置</h4><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682243563126.png" alt="1682243563126"></p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682243641185.png" alt="1682243641185"></p><hr><h4 id="设置源码目录"><a href="#设置源码目录" class="headerlink" title="设置源码目录"></a>设置源码目录</h4><p>在解决方案-属性，打开弹窗设置</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682243771250.png" alt="1682243771250"></p><h4 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h4><blockquote><p>点击 “使用 仅限本机 进行调试”</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682243822104.png" alt="1682243822104"></p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/kk_image.jpg" alt="img"></p><hr><h3 id="使用Windows调试器windbg-exe调试"><a href="#使用Windows调试器windbg-exe调试" class="headerlink" title="使用Windows调试器windbg.exe调试"></a>使用Windows调试器windbg.exe调试</h3><blockquote><p><a href="https://developer.microsoft.com/zh-cn/windows/downloads/windows-sdk/">下载链接</a></p><p>此链接是下载Windows SDK安装包的，Windows SDK安装包含windbg.exe。</p></blockquote><h4 id="调试步骤"><a href="#调试步骤" class="headerlink" title="调试步骤"></a>调试步骤</h4><blockquote><ol><li>双击打开windbg.exe，选择相应版本</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682405908877.png" alt="1682405865975"></p><ol start="2"><li>依次完成如下配置<br>打开File 需要完成 Symbol File Path 、Source File Path、Image File Path 的配置</li><li>Symbol File Path ：这里就是加載pdb文件的路徑</li><li>Source File Path: 加载程序代码 存放的路径（注意切回發佈版本的代碼）</li><li>Image File Path: 加載exe 存放的路徑</li><li>選擇Open Crash Dump 導入生成的dmp文件</li><li>输入命令 !analyze -v ，等待几秒后会打印出错误信息</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682407236891.png" alt="1682407236891"></p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682407088643.png" alt="1682407088643"></p></blockquote><p>1、Symbol File Path ：這裏就是加載pdb文件的路徑，我們直接使用</p><p>D:/Project/DumTools/<br>1<br>2、 Source File Path: 加载程序代码 存放的路径（注意切回發佈版本的代碼）</p><p>D:/Project/Demo/<br>1<br>3、Image File Path: 加載exe 存放的路徑</p><p>D:/Project/DumTools/<br>1<br>4、選擇Open Crash Dump 導入生成的dmp文件</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><blockquote><ul><li>用于崩溃调试的dump、pdb、源码需要是同一个版本，一般为发布版本（即客户版本）</li><li>用于崩溃调试的dump、pdb、源码需要区分debug和release否则无法调试</li></ul></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ol><li><a href="https://blog.csdn.net/LiHong333/article/details/129798322?spm=1001.2014.3001.5502">Qt-mingw 生成dump文件并使用vs调试定位错误代码_qt生成dump文件</a></li><li><a href="https://libaineu2004.blog.csdn.net/article/details/108310384?spm=1001.2014.3001.5502">Qt如何在Release编译下怎么调试？怎么生成pdb文件</a></li><li><a href="https://blog.csdn.net/HeroGuo_JP/article/details/105383752"> Window端Qt Create dmp的生成与解析</a></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;最近因为维护的项目出现崩溃，客户现场的log无法定位，因此需要使用dump文件调试于是查找资料添加了一个崩溃生成d</summary>
      
    
    
    
    <category term="Qt" scheme="https://ouyujia.github.io/categories/Qt/"/>
    
    
    <category term="QT" scheme="https://ouyujia.github.io/tags/QT/"/>
    
    <category term="MingW" scheme="https://ouyujia.github.io/tags/MingW/"/>
    
    <category term="Dump" scheme="https://ouyujia.github.io/tags/Dump/"/>
    
  </entry>
  
  <entry>
    <title>QT数据库</title>
    <link href="https://ouyujia.github.io/2022/05/28/QT%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://ouyujia.github.io/2022/05/28/QT%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2022-05-28T11:54:44.000Z</published>
    <updated>2023-04-28T05:56:04.358Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>QT模型/视图</title>
    <link href="https://ouyujia.github.io/2022/05/28/QT%E6%A8%A1%E5%9E%8B-%E8%A7%86%E5%9B%BE/"/>
    <id>https://ouyujia.github.io/2022/05/28/QT%E6%A8%A1%E5%9E%8B-%E8%A7%86%E5%9B%BE/</id>
    <published>2022-05-28T11:54:22.000Z</published>
    <updated>2023-04-28T05:56:04.359Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>QT样式基类</title>
    <link href="https://ouyujia.github.io/2022/05/28/QT%E6%A0%B7%E5%BC%8F%E5%9F%BA%E7%B1%BB/"/>
    <id>https://ouyujia.github.io/2022/05/28/QT%E6%A0%B7%E5%BC%8F%E5%9F%BA%E7%B1%BB/</id>
    <published>2022-05-28T11:53:44.000Z</published>
    <updated>2023-04-28T05:56:04.359Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>QT自定义部件</title>
    <link href="https://ouyujia.github.io/2022/05/28/QT%E8%87%AA%E5%AE%9A%E4%B9%89%E9%83%A8%E4%BB%B6/"/>
    <id>https://ouyujia.github.io/2022/05/28/QT%E8%87%AA%E5%AE%9A%E4%B9%89%E9%83%A8%E4%BB%B6/</id>
    <published>2022-05-28T11:53:20.000Z</published>
    <updated>2023-04-28T05:56:04.360Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>QT绘图</title>
    <link href="https://ouyujia.github.io/2022/05/28/QT%E7%BB%98%E5%9B%BE/"/>
    <id>https://ouyujia.github.io/2022/05/28/QT%E7%BB%98%E5%9B%BE/</id>
    <published>2022-05-28T11:52:52.000Z</published>
    <updated>2023-04-28T05:56:04.359Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>QT串口通讯</title>
    <link href="https://ouyujia.github.io/2022/05/28/QT%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF/"/>
    <id>https://ouyujia.github.io/2022/05/28/QT%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF/</id>
    <published>2022-05-28T11:52:29.000Z</published>
    <updated>2023-04-28T05:56:04.357Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>QT网络通讯</title>
    <link href="https://ouyujia.github.io/2022/05/28/QT%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/"/>
    <id>https://ouyujia.github.io/2022/05/28/QT%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/</id>
    <published>2022-05-28T11:52:10.000Z</published>
    <updated>2023-04-28T05:56:04.360Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>QT线程</title>
    <link href="https://ouyujia.github.io/2022/05/28/QT%E7%BA%BF%E7%A8%8B/"/>
    <id>https://ouyujia.github.io/2022/05/28/QT%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-05-28T11:51:49.000Z</published>
    <updated>2023-04-28T05:56:04.359Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>QT部件基类</title>
    <link href="https://ouyujia.github.io/2022/05/28/QT%E9%83%A8%E4%BB%B6%E5%9F%BA%E7%B1%BB/"/>
    <id>https://ouyujia.github.io/2022/05/28/QT%E9%83%A8%E4%BB%B6%E5%9F%BA%E7%B1%BB/</id>
    <published>2022-05-28T11:51:29.000Z</published>
    <updated>2023-04-28T05:56:04.360Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>QT对象基类</title>
    <link href="https://ouyujia.github.io/2022/05/28/QT%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%B1%BB/"/>
    <id>https://ouyujia.github.io/2022/05/28/QT%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%B1%BB/</id>
    <published>2022-05-28T11:50:59.000Z</published>
    <updated>2023-04-28T05:56:04.358Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>QT事件</title>
    <link href="https://ouyujia.github.io/2022/05/28/QT%E4%BA%8B%E4%BB%B6/"/>
    <id>https://ouyujia.github.io/2022/05/28/QT%E4%BA%8B%E4%BB%B6/</id>
    <published>2022-05-28T11:50:04.000Z</published>
    <updated>2023-04-28T05:56:04.358Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>空悬指针和野指针</title>
    <link href="https://ouyujia.github.io/2022/05/09/%E7%A9%BA%E6%82%AC%E6%8C%87%E9%92%88%E5%92%8C%E9%87%8E%E6%8C%87%E9%92%88/"/>
    <id>https://ouyujia.github.io/2022/05/09/%E7%A9%BA%E6%82%AC%E6%8C%87%E9%92%88%E5%92%8C%E9%87%8E%E6%8C%87%E9%92%88/</id>
    <published>2022-05-09T11:03:39.000Z</published>
    <updated>2023-04-28T05:56:04.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="空悬指针"><a href="#空悬指针" class="headerlink" title="空悬指针"></a>空悬指针</h2><p>简单地说，空悬指针是对象的指针的生存周期比对象更长所导致的，也就是说，<font color="orange"><code>对象销毁、删除了，不存在了，指针仍然存在，这时这个指针就成了空悬指针。</code></font><br>当对象被析构、删除时，如果指向它的指针没有被同时修改，那么指针仍然会指向那块内存（但是那块内存已经没有东西了）。系统此时可能会重新分配这块已经free掉的内存。<font color="red"><code>如果程序再通过这个指针读这块内存，就可能会有不可预见的事情发生，因为这块内存可能被分配了完全不同的内容。</code></font>如果程序此时要写这块内存，就可能会造成数据污染，进而可能带来超级难被发现的bug。<font color="red"><code>如果内存已经被其它进程重新分配，此时再去访问指针指向的内容，就可能会发生片段错误(UNIX,Linux)或者一般性保护错误(Windows).如果程序有足够的权限去重写内核内存分配器的内容，还可能造成系统的不稳定。</code></font>在有垃圾回收机制的面向对象语言中，阻止空悬引用的方法是销毁所有访问不到的对象，也就是说他们也就没有所谓的指针了，这是由追踪或引用计数而确保的。然而finalizer可能会创建新的对象的引用，这就要求对象要再生来防止空悬引用。</p><p>以下举例说明空悬指针：</p><p>例1</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">   <span class="type">char</span> *dp = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="comment">/* ... */</span></span><br><span class="line">   {</span><br><span class="line">       <span class="type">char</span> c; <span class="comment">//出了作用域系统自动销毁局部变量</span></span><br><span class="line">       dp = &amp;c;</span><br><span class="line">   }  </span><br><span class="line"><span class="comment">//到这里，c已经被销毁了，dp就变成了空悬指针(dp没有修改其指向正确的地址，它依然指向c的指针，但c的地址已不属于本程序)</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>例2</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">test_array</span><span class="params">(<span class="type">int</span> *a)</span></span>{</span><br><span class="line"><span class="type">int</span> length = <span class="built_in">sizeof</span>(a)/<span class="built_in">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"><span class="type">int</span> *b = <span class="keyword">new</span> <span class="type">int</span> [length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">{</span><br><span class="line">*b++=a[i];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="type">int</span> a [<span class="number">5</span>] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line"><span class="type">int</span> *b = <span class="built_in">test_array</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">{</span><br><span class="line">cout&lt;&lt;b[i]&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">51</span></span><br></pre></td></tr></tbody></table></figure><p>就像这样，因为虽然返回了一个指针，但是这个指针指向的对象在函数返回时已经销毁了，因此返回的值是不确定的。如果接下来还想用，那么得用引用的方法传参。</p><p>消除空悬指针的方式</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span> *dp = <span class="built_in">malloc</span>(A_CONST);</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="built_in">free</span>(dp);         <span class="comment">/* dp 现在是空悬指针 */</span></span><br><span class="line">    dp = <span class="literal">NULL</span>;        <span class="comment">/* dp 不再是空悬指针*/</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>注意：</p><blockquote><p>悬浮指针所指向的内存不属于当前程序，但是因为知道内存的指针，当前程序还是可以追寻到这块地址并修改它的值，如果操作系统没有将这块内存分配给其他程序，当前系统对该内存的操作不会出现问题（严禁这么做，因为你不知道什么时候操作系统会将这块内存分配给其他程序），如果操作系统已经将这块内存分配给其他程序，此时当前程序通过指针对这块内存进行操作就可能会发生片段错误(UNIX,Linux)或者一般性保护错误(Windows)。</p></blockquote><p>下面是一段简单的测试代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//悬浮指针， 野指针的一种，使用后结果不可控，非常危险</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* int_pointer = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"赋值前地址:"</span> &lt;&lt; int_pointer;</span><br><span class="line">    *int_pointer = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"赋值后地址:"</span> &lt;&lt; int_pointer;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"delete前值:"</span> &lt;&lt; *int_pointer;</span><br><span class="line">    <span class="keyword">delete</span> int_pointer;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"delete后值:"</span> &lt;&lt; *int_pointer;</span><br><span class="line"><span class="comment">//    int * int_pointer_second = int_pointer;</span></span><br><span class="line">    <span class="type">double</span> * double_pointer = (<span class="type">double</span>*) int_pointer;</span><br><span class="line">    *double_pointer = <span class="number">8.4</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"delete后地址:"</span> &lt;&lt; int_pointer;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"double delete后地址:"</span> &lt;&lt; double_pointer;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"int delete后值1:"</span> &lt;&lt; *int_pointer; <span class="comment">//此时变量被double值占用，输出为垃圾值（-858993459）</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"double delete后值1:"</span> &lt;&lt; *double_pointer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    *int_pointer = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"double delete后值2:"</span> &lt;&lt; *double_pointer;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"delete后赋值2:"</span> &lt;&lt; *int_pointer;</span><br><span class="line">    int_pointer = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"nullptr后地址:"</span> &lt;&lt; int_pointer;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"nullptr后地址double:"</span> &lt;&lt; double_pointer;</span><br><span class="line"><span class="comment">//    qDebug() &lt;&lt; "nullptr后值:" &lt;&lt; *int_pointer; //报错 无法操作空指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">赋值前地址: <span class="number">0x35dc900</span></span><br><span class="line">赋值后地址: <span class="number">0x35dc900</span></span><br><span class="line"><span class="keyword">delete</span>前值: <span class="number">5</span></span><br><span class="line"><span class="keyword">delete</span>后值: <span class="number">5</span></span><br><span class="line"><span class="keyword">delete</span>后地址: <span class="number">0x35dc900</span></span><br><span class="line"><span class="type">double</span> <span class="keyword">delete</span>后地址: <span class="number">0x35dc900</span></span><br><span class="line"><span class="type">int</span> <span class="keyword">delete</span>后值<span class="number">1</span>: <span class="number">-858993459</span></span><br><span class="line"><span class="type">double</span> <span class="keyword">delete</span>后值<span class="number">1</span>: <span class="number">8.4</span></span><br><span class="line"><span class="type">double</span> <span class="keyword">delete</span>后值<span class="number">2</span>: <span class="number">8.39999</span></span><br><span class="line"><span class="keyword">delete</span>后赋值<span class="number">2</span>: <span class="number">9</span></span><br><span class="line"><span class="literal">nullptr</span>后地址: <span class="number">0x0</span></span><br><span class="line"><span class="literal">nullptr</span>后地址<span class="type">double</span>: <span class="number">0x35dc900</span></span><br></pre></td></tr></tbody></table></figure><h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><p><font color="orange"><code>野指针作为一个指针，甚至都没有被初始化，也就是说虽然它的类型是一个指针，但它根本没有值。</code></font>它跟NULL指针还有差别，NULL是指向了0地址，而野指针是没有地址。也就相当于，int a=0;和int a;的区别。野指针非常危险，往往会引起程序奔溃。</p><p>举例说明：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span> *dp;<span class="comment">//野指针，没有初始化</span></span><br><span class="line">    <span class="comment">//定义一个测试类testClass，包含一个成员函数void show();</span></span><br><span class="line">    testClass * test; <span class="comment">//野指针，没有初始化</span></span><br><span class="line">    test.<span class="built_in">show</span>(); <span class="comment">//系统将奔溃</span></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> *sdp; <span class="comment">//非野指针，因为静态变量会默认初始化为0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">C++空悬指针和野指针浅谈</summary>
    
    
    
    <category term="C++" scheme="https://ouyujia.github.io/categories/C/"/>
    
    <category term="指针" scheme="https://ouyujia.github.io/categories/C/%E6%8C%87%E9%92%88/"/>
    
    
    <category term="C++" scheme="https://ouyujia.github.io/tags/C/"/>
    
    <category term="指针" scheme="https://ouyujia.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>可调用对象包装器、绑定器</title>
    <link href="https://ouyujia.github.io/2022/05/09/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8%E3%80%81%E7%BB%91%E5%AE%9A%E5%99%A8/"/>
    <id>https://ouyujia.github.io/2022/05/09/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8%E3%80%81%E7%BB%91%E5%AE%9A%E5%99%A8/</id>
    <published>2022-05-09T07:07:51.000Z</published>
    <updated>2023-04-28T05:56:04.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h2><p>在 C++ 中存在 “可调用对象” 这么一个概念。准确来说，可调用对象有如下几种定义：</p><ul><li><font color="orange"><code>是一个函数指针</code></font></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 定义函数指针</span></span><br><span class="line"><span class="built_in">int</span> (*func)(<span class="type">int</span>, <span class="type">double</span>) = &amp;print</span><br></pre></td></tr></tbody></table></figure><ul><li><font color="orange"><code>是一个具有operator()成员函数的类对象（仿函数，即重载()运算符）</code></font></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// ()操作符重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string msg)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"msg: "</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="built_in">t</span>(<span class="string">"我是要成为海贼王的男人!!!"</span>);<span class="comment">// 仿函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><font color="orange"><code>是一个可被转换为函数指针的类对象</code></font></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>, string);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, string b)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"name: "</span> &lt;&lt; b &lt;&lt; <span class="string">", age: "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将类对象转换为函数指针</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">func_ptr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> print; <span class="comment">//只能是类的静态成员函数，因为类的静态成员函数类定义时就存在，而类的普通成员函数只有函数实例对象后才存在.</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="comment">// 对象转换为函数指针, 并调用</span></span><br><span class="line">    <span class="built_in">t</span>(<span class="number">19</span>, <span class="string">"Monkey D. Luffy"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><font color="orange"><code>是一个类成员函数指针或者类成员指针</code></font></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, string b)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"name: "</span> &lt;&lt; b &lt;&lt; <span class="string">", age: "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 定义类成员函数指针指向类成员函数</span></span><br><span class="line">    <span class="built_in">void</span> (Test::*func_ptr)(<span class="type">int</span>, string) = &amp;Test::print;</span><br><span class="line">    <span class="comment">// 类成员指针指向类成员变量</span></span><br><span class="line">    <span class="type">int</span> Test::*obj_ptr = &amp;Test::m_num;</span><br><span class="line"></span><br><span class="line">    Test t;</span><br><span class="line">    <span class="comment">// 通过类成员函数指针调用类成员函数</span></span><br><span class="line">    (t.*func_ptr)(<span class="number">19</span>, <span class="string">"Monkey D. Luffy"</span>);</span><br><span class="line">    <span class="comment">// 通过类成员指针初始化类成员变量</span></span><br><span class="line">    t.*obj_ptr = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"number is: "</span> &lt;&lt; t.m_num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上面的例子中满足条件的这些可调用对象对应的类型被统称为<font color="red"><code>可调用类型</code></font>。C++ 中的可调用类型虽然具有比较统一的操作形式，但定义方式五花八门，这样在我们试图使用统一的方式保存，或者传递一个可调用对象时会十分繁琐。现在，<font color="orange"><code>C++11通过提供std::function 和 std::bind统一了可调用对象的各种操作。</code></font></p><h2 id="可调用对象包装器"><a href="#可调用对象包装器" class="headerlink" title="可调用对象包装器"></a>可调用对象包装器</h2><p><font color="orange"><code>std::function是可调用对象的包装器。它是一个类模板，可以容纳除了类成员（函数）指针之外的所有可调用对象。通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们。</code></font></p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>std::function 必须要包含一个叫做 <font color="orange"><code>functional</code> </font>的头文件，可调用对象包装器使用语法如下:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line">std::function&lt;返回值类型(参数类型列表)&gt; diy_name = 可调用对象;</span><br></pre></td></tr></tbody></table></figure><p>下面的实例代码中演示了可调用对象包装器的基本使用方法：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">" + "</span> &lt;&lt; b &lt;&lt; <span class="string">" = "</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">" - "</span> &lt;&lt; b &lt;&lt; <span class="string">" = "</span> &lt;&lt; a - b &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">" * "</span> &lt;&lt; b &lt;&lt; <span class="string">" = "</span> &lt;&lt; a * b &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 绑定一个普通函数</span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f1 = add;</span><br><span class="line">    <span class="comment">// 绑定以静态类成员函数</span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f2 = T1::sub;</span><br><span class="line">    <span class="comment">// 绑定一个仿函数</span></span><br><span class="line">    T2 t;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f3 = t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">f2</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">f3</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输入结果如下:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> + <span class="number">3</span> = <span class="number">12</span></span><br><span class="line"><span class="number">9</span> - <span class="number">3</span> = <span class="number">6</span></span><br><span class="line"><span class="number">9</span> * <span class="number">3</span> = <span class="number">27</span></span><br></pre></td></tr></tbody></table></figure><p><font color="red"><code>通过测试代码可以得到结论：std::function 可以将可调用对象进行包装，得到一个统一的格式，包装完成得到的对象相当于一个函数指针，和函数指针的使用方式相同，通过包装器对象就可以完成对包装的函数的调用了。</code></font></p><h3 id="作为回调函数使用"><a href="#作为回调函数使用" class="headerlink" title="作为回调函数使用"></a>作为回调函数使用</h3><p>因为回调函数本身就是通过函数指针实现的，<font color="orange"><code>使用对象包装器可以取代函数指针的作用</code></font>，来看一下下面的例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数参数是一个包装器对象</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> function&lt;<span class="built_in">void</span>()&gt;&amp; f) : <span class="built_in">callback</span>(f)</span><br><span class="line">    {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">callback</span>(); <span class="comment">// 调用通过构造函数得到的函数指针</span></span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    function&lt;<span class="type">void</span>()&gt; callback;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"我是要成为海贼王的男人!!!"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    B b;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(b)</span></span>; <span class="comment">// 仿函数通过包装器对象进行包装</span></span><br><span class="line">    a.<span class="built_in">notify</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过上面的例子可以看出，使用对象包装器 std::function 可以非常方便的将仿函数转换为一个函数指针，通过进行函数指针的传递，在其他函数的合适的位置就可以调用这个包装好的仿函数了。</p><p>另外，使用 std::function 作为函数的传入参数，可以将定义方式不相同的可调用对象进行统一的传递，这样大大增加了程序的灵活性。</p><h2 id="绑定器"><a href="#绑定器" class="headerlink" title="绑定器"></a>绑定器</h2><p><font color="orange"><code>std::bind用来将可调用对象与其参数一起进行绑定。绑定后的结果可以使用std::function进行保存，并延迟调用到任何我们需要的时候。</code></font>通俗来讲，它主要有两大作用：</p><ol><li><font color="orange"><code>将可调用对象与其参数一起绑定成一个仿函数。</code></font></li><li><font color="orange"><code>将多元（参数个数为n，n&gt;1）可调用对象转换为一元或者（n-1）元可调用对象，即只绑定部分参数。</code></font></li></ol><p>绑定器函数使用语法格式如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定非类成员函数/变量</span></span><br><span class="line"><span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(可调用对象地址, 绑定的参数/占位符);</span><br><span class="line"><span class="comment">// 绑定类成员函/变量</span></span><br><span class="line"><span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(类函数/成员地址, 类实例对象地址, 绑定的参数/占位符);</span><br></pre></td></tr></tbody></table></figure><p>下面来看一个关于绑定器的实际使用的例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callFunc</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;&amp; f)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">f</span>(x);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_add</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; x + <span class="number">10</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 使用绑定器绑定可调用对象和参数</span></span><br><span class="line">    <span class="keyword">auto</span> f1 = <span class="built_in">bind</span>(output, placeholders::_1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">callFunc</span>(i, f1);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f2 = <span class="built_in">bind</span>(output_add, placeholders::_1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">callFunc</span>(i, f2);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试代码输出的结果:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="number">10</span> <span class="number">12</span> <span class="number">14</span> <span class="number">16</span> <span class="number">18</span></span><br></pre></td></tr></tbody></table></figure><p>在上面的程序中，使用了 std::bind 绑定器，在函数外部通过绑定不同的函数，控制了最后执行的结果。<font color="orange"><code>std::bind绑定器返回的是一个仿函数类型，得到的返回值可以直接赋值给一个std::function，在使用的时候我们并不需要关心绑定器的返回值类型，使用auto进行自动类型推导就可以了。</code></font></p><p><font color="orange">placeholders::_1</font> 是一个占位符，代表这个位置将在函数调用时被传入的第一个参数所替代。同样还有其他的占位符 <font color="orange">placeholders::_2</font> 、<font color="orange">placeholders::_3</font> 、<font color="orange">placeholders::_4</font> 、<font color="orange">placeholders::_5</font>  等……</p><p>有了占位符的概念之后，使得 std::bind 的使用变得非常灵活:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 使用绑定器绑定可调用对象和参数, 并调用得到的仿函数</span></span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">1</span>, <span class="number">2</span>)();</span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_1, <span class="number">2</span>)(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">2</span>, placeholders::_1)(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// error, 调用时没有第二个参数</span></span><br><span class="line">    <span class="comment">// bind(output, 2, placeholders::_2)(10);</span></span><br><span class="line">    <span class="comment">// 调用时第一个参数10被吞掉了，没有被使用</span></span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">2</span>, placeholders::_2)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_1, placeholders::_2)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_2, placeholders::_1)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>示例代码执行的结果:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="number">2</span><span class="comment">// bind(output, 1, 2)();</span></span><br><span class="line"><span class="number">10</span> <span class="number">2</span><span class="comment">// bind(output, placeholders::_1, 2)(10);</span></span><br><span class="line"><span class="number">2</span> <span class="number">10</span><span class="comment">// bind(output, 2, placeholders::_1)(10);</span></span><br><span class="line"><span class="number">2</span> <span class="number">20</span><span class="comment">// bind(output, 2, placeholders::_2)(10, 20);</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span><span class="comment">// bind(output, placeholders::_1, placeholders::_2)(10, 20);</span></span><br><span class="line"><span class="number">20</span> <span class="number">10</span><span class="comment">// bind(output, placeholders::_2, placeholders::_1)(10, 20);</span></span><br></pre></td></tr></tbody></table></figure><p>通过测试可以看到，std::bind 可以直接绑定函数的所有参数，也可以仅绑定部分参数。在绑定部分参数的时候，通过使用 std::placeholders 来决定空位参数将会属于调用发生时的第几个参数。</p><p>可调用对象包装器 std::function 是不能实现对类成员函数指针或者类成员指针的包装的，但是通过绑定器 std::bind 的配合之后，就可以完美的解决这个问题了，再来看一个例子，然后再解释里边的细节：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"x: "</span> &lt;&lt; x &lt;&lt; <span class="string">", y: "</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> m_number = <span class="number">100</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="comment">// 绑定类成员函数</span></span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f1 = </span><br><span class="line">        <span class="built_in">bind</span>(&amp;Test::output, &amp;t, placeholders::_1, placeholders::_2);</span><br><span class="line">    <span class="comment">// 绑定类成员变量(公共)</span></span><br><span class="line">    function&lt;<span class="type">int</span>&amp;(<span class="type">void</span>)&gt; f2 = <span class="built_in">bind</span>(&amp;Test::m_number, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用</span></span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">520</span>, <span class="number">1314</span>);</span><br><span class="line">    <span class="built_in">f2</span>() = <span class="number">2333</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"t.m_number: "</span> &lt;&lt; t.m_number &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>示例代码输出的结果:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x: <span class="number">520</span>, y: <span class="number">1314</span></span><br><span class="line">t.m_number: <span class="number">2333</span></span><br></pre></td></tr></tbody></table></figure><p>在用绑定器绑定类成员函数或者成员变量的时候需要将它们所属的实例对象一并传递到绑定器函数内部。<font color="orange"><code>f1的类型是function&lt;void(int, int)&gt;，通过使用std::bind将Test的成员函数output的地址和对象t绑定，并转化为一个仿函数并存储到对象f1中。</code></font></p><p><font color="orange"><code>使用绑定器绑定的类成员变量m_number得到的仿函数被存储到了类型为function&lt;int&amp;(void)&gt;的包装器对象f2中，并且可以在需要的时候修改这个成员。其中int是绑定的类成员的类型，并且允许修改绑定的变量，因此需要指定为变量的引用，由于没有参数因此参数列表指定为void。</code></font></p><p>示例程序中是使用 function 包装器保存了 bind 返回的仿函数，如果不知道包装器的模板类型如何指定，可以直接使用 auto 进行类型的自动推导，这样使用起来会更容易一些。</p>]]></content>
    
    
    <summary type="html">C++11新特性</summary>
    
    
    
    <category term="C++" scheme="https://ouyujia.github.io/categories/C/"/>
    
    <category term="C++11" scheme="https://ouyujia.github.io/categories/C/C-11/"/>
    
    
    <category term="C++11新特性" scheme="https://ouyujia.github.io/tags/C-11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    <category term="指针" scheme="https://ouyujia.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
    <category term="可调用对象" scheme="https://ouyujia.github.io/tags/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>QSS入门</title>
    <link href="https://ouyujia.github.io/2022/05/07/QSS%E5%85%A5%E9%97%A8/"/>
    <id>https://ouyujia.github.io/2022/05/07/QSS%E5%85%A5%E9%97%A8/</id>
    <published>2022-05-07T03:26:07.000Z</published>
    <updated>2023-04-28T05:56:04.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>为了书写方便, 文中一律使用 Qss 代替 Qt style sheet。</p><p>首先来看 Qt 的官方介绍: 除了子类化 QStyle 以外, Qss 是一个非常强大的用于自定义控件外观的机制. 它的概念,术语以及语法都是受到了 HTML CSS 的启发(实际上就是 CSS 的语法), 但可以适应全局窗口部件(这一句我没明白是什么意思)。</p><p>就是说, Qss 是用来设置界面样式的, 设置的方法就是类似于 CSS,通过以一定规则组织的字符串来给界面设置样式, 而不用我们调用控件对象的接口或子类化 QStyle 去设置样式. 这种组织字符串的规则就是它的语法, 下的总结也是主要讲一些 Qss 的语法, 包含少量的经验以及官方文档中没有说明的内容.</p><p>个人认为使用 Qss 的好处:</p><p>(1) 可读性高并且非常直观,便于设置界面样式;</p><p>(2) 在每个平台上都有相同的显示效果. </p><p>(3) 可以在界面代码中省去与显示效果相关的大量代码,将界面逻辑独立出来. </p><p>(4) 在界面风格(配色, 字体等)改变的情况下, 可以不用修改 c++源码就可以实现.</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>样式表由一系列的样式规则组成。一条样式规则由一个<font color="orange"><code>选择器</code></font>和一个<font color="orange"><code>声明语句</code></font>组成，<font color="orange"><code>选择器指明了哪个（或者说是哪种）控件将会受规则影响，而声明语句则指明了哪些属性会设置到这个（这些）控件</code></font>. </p><p>语法如下:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selector { attribute: value; } </span><br></pre></td></tr></tbody></table></figure><blockquote><p>在上面这条语句中, selector 代表选择器, 指明了哪个(或者说是哪种)控件将会受到规则影响.</p><p>{attribute: value;}代表声明语句, 其中 attribute 表示属性, value 表示该属性的值, 属性与它的值之间必须以冒号( : )隔开, 属性值后面必须以分号( ; )结束,表示这条属性已经设置完成. 整条语句加起来的意思是, 在整个应用程序中, 被 selector匹配的控件, 它们控件的 attribute 属性的值应该被设置为 value.</p></blockquote><p>例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPushButton{ <span class="attribute">color</span>: red;}</span><br></pre></td></tr></tbody></table></figure><p>表示将我们的应用程序中所有的 QPushbutton 对象以及它的子类对象应该使用 red 作为它们的前景色(即字体的颜色);由此看来, 我们要学会如何使用 qss 来控制我们的界面样式, 只需要学会两个方面的内容, 即选择器和属性, 下面将用专门的章节来讲解这两部分的内容.</p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="通用选择器"><a href="#通用选择器" class="headerlink" title="通用选择器"></a>通用选择器</h4><p>又叫通配符选择器</p><h5 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* { 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>通用选择器用( * )来表示, 它表示匹配程序中所有的 widget.</p><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><blockquote><p><font color="cornflowerblue">由于通用选择器会匹配程序中所有的 widgets, 效率较低, 因此应该尽量减少或者不使用</font></p></blockquote><h5 id="一般用法"><a href="#一般用法" class="headerlink" title="一般用法"></a>一般用法</h5><p>通用选择器一般用来给应用程序设置统一的字体,例如</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*{<span class="attribute">font</span>: normal <span class="number">20px</span> “微软雅黑”;}</span><br></pre></td></tr></tbody></table></figure><p>这条语句表示将程序中所有 widget 的字体大小都设置为 20px 大小, 字体采用微软雅黑.</p><h4 id="类型选择器"><a href="#类型选择器" class="headerlink" title="类型选择器"></a>类型选择器</h4><h5 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 { 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>类名即 Widget 类名, 由 QObject :: metaObject() :: className()获取, 类型选择器匹配所有该类以及该类的派生类的对象.</p><p>例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QPushButton{ </span><br><span class="line"><span class="attribute">color</span>: blue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这条语句表示, 程序中<font color="orange"><code>所有的 QPushButton 类和它的派生类的对象, 它们的前景色(即文字颜色)被设置为蓝色.</code></font></p><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><p>Qt 样式表使用 widget 的 <font color="orange"><code>QObject::className()</code></font>来决定何时应用<font color="orange"><code>类型选择器</code></font>。当<font color="red"><code>自定义控件在命名空间之中</code></font>(或它是一个嵌套类)，<font color="red">QObject::className()会返回( :: )</font>, 这与后面介绍的子控件选择器相冲突. 为了解决这个问题，当为命名空间中 widget 使用类型选择器时, 我们必须将<font color="orange"><code>” :: ”</code></font>替换成<font color="orange"><code>” -- ”</code></font>, 下面即将介绍的类选择器也是一样. </p><p>例子如下:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ns {</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">MyPushButton</span> : <span class="keyword">public</span> QPushButton {</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> } </span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">qApp-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">"ns--MyPushButton { background: yellow; }"</span>);</span><br></pre></td></tr></tbody></table></figure><h5 id="一般用法-1"><a href="#一般用法-1" class="headerlink" title="一般用法"></a><strong>一般用法</strong></h5><p>类型选择器会匹配<font color="orange"><code>所有该类以及该类的派生类的对象</code></font>, 所以我们在程序中, 有时为了统一具有相似性的控件的样式, 可以使用类型选择器, 如, 我们想要为 <font color="orange">QSpinBox</font>,<font color="orange">QDoubleSpinBox</font>, <font color="orange">QDateTimeEdit</font>, <font color="orange">QTimeEdit</font>, <font color="orange">QDateEdit</font> 等这些编辑框的控件设置一些相同的样式, 因为它们都是 <font color="orange">QAbstractSpinBox 类的派生类</font>, 因此可以如下写:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QAbstractSpinBox{</span><br><span class="line"><span class="attribute">min-height</span>: <span class="number">30px</span>;</span><br><span class="line"><span class="attribute">max-height</span>: <span class="number">30px</span>;</span><br><span class="line"><span class="attribute">border-width</span>: <span class="number">1px</span>;</span><br><span class="line">rder-style: solid;</span><br><span class="line"><span class="attribute">order</span>-<span class="attribute">color</span>: gray; </span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0px</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a><strong>类选择器</strong></h4><h5 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.类名 { 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>这里的类名与类型选择器中的类名一样, 不同的是, 类选择器的类名前面有一个( . ), 这种选择器<font color="red"><code>只会匹配该类的所有对象, 而不会匹配其派生类的对象.</code></font> </p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.QPushButton</span>{ </span><br><span class="line"><span class="attribute">color</span>: blue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="一般用法-2"><a href="#一般用法-2" class="headerlink" title="一般用法"></a><strong>一般用法</strong></h5><p>类选择器提供了一种<font color="orange"><code>匹配所有该类的对象但不会匹配派生类的方法</code></font>, 通常用来特例化拥有派生类的类对象, 但不仅限于此.例如在在我的应用程序中, 我用 QFrame 来作为容器 widget,此时我想对它设置一些样式, 但又不想影响它的子类对象(QLabel, QAbstractScrollArea 等等),那么我可以使用类选择器给所有的 QFrame 设置相同的样式 . </p><p>例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.QFrame</span>{</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">25px</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="ID-选择器"><a href="#ID-选择器" class="headerlink" title="ID 选择器"></a><strong>ID</strong> <strong>选择器</strong></h4><h5 id="格式-3"><a href="#格式-3" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#id</span>{ 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>这里的 id 指的是 objectName, 每个 QObject 类及其派生类都有的一个属性, “#” + objectName构成了我们的 ID 选择器, <font color="orange"><code>它匹配所有 objectName 为 ID 选择器所指定的名称的对象</code></font>, 为其设置样式. </p><p>例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#button_1</span>{</span><br><span class="line"> <span class="attribute">color</span>: red; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a><strong>注意点</strong></h5><ol><li><p>objectName 是大小写敏感的.</p></li><li><p>“#”与 ID 之间不可以有空格</p></li><li><p>由于 objectName 是所有 QObject 类对象的一个属性, 在运行过程中可以改变, 所以一般情况下, 要使用 ID 选择器时,<font color="orange"> <code>保证 objectName 不要在运行时被改变, 否则重新加载stylesheet 文件时, 对应的 ID 选择器将不会匹配到原来的控件.</code></font></p></li><li><p>由于 objectName 允许字符串中含有空格, 但是 ID 选择器中,<font color="orange"> <code>ID 是从紧跟#后的第一个字符开始直到遇到空格或“{”之间的字符串, 因此, 如果是为了使用 ID 选择器而设置objectName, 则 objectName 中不能含有空格</code></font></p></li><li><p><font color="orange"><code>由于任何对象的 objectName 都可以出现重复, 因此在设置 objectName 时, 尽量保持其唯一性</code></font></p></li><li><p>Qt 官方给出的 ID 选择器的格式为:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名<span class="selector-id">#id</span>{ 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>但实际上不加类名也是可以的(加了类名的 ID 选择器在 CSS 中被称为交集选择器),在正式开发中, 还是<font color="orange"><code>建议加上类名, 因为这样可以看出这个 id 选择器所匹配的对象的类型,有利于提高阅读性.</code></font>基于以上特点, 我们在设置 objectName 时, 一般使用下划线”_”连接的多个单词表明此对象的功能.</p></li></ol><h5 id="一般用法-3"><a href="#一般用法-3" class="headerlink" title="一般用法"></a><strong>一般用法</strong></h5><p>ID 选择器一般用于为比较特殊的控件设置样式, 例如在我的某个页面中, 需要突出一个重要的按钮, 那么此时我可以给这个按钮设置一个独特的样式用以提醒用户, 如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-id">#settings_popup_fileDialog_button</span>{</span><br><span class="line"></span><br><span class="line"> <span class="attribute">min-height</span>: <span class="number">31px</span>;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">min-width</span>: <span class="number">70px</span>;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">color</span>: <span class="number">#F0F0F0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">min-height</span>: <span class="number">10px</span>;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">border-radius</span>:<span class="number">3px</span>;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">background</span>: <span class="built_in">qlineargradient</span>(spread:pad, x1:<span class="number">0</span>, y1:<span class="number">0</span>, x2:<span class="number">0</span>, y2:<span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">stop:<span class="number">0</span> <span class="number">#454648</span>, stop:<span class="number">1</span> <span class="number">#7A7A7A</span>); </span><br><span class="line"></span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h4 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a><strong>后代选择器</strong></h4><h5 id="格式-4"><a href="#格式-4" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器<span class="number">1</span> 选择器<span class="number">2</span>{ 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>这个选择器表示: <font color="orange"><code>在选择器 1 匹配的所有对象中, 找到选择器 2 所匹配的所有后代对象, 并给它们设置样式.</code></font></p><h5 id="注意点-3"><a href="#注意点-3" class="headerlink" title="注意点"></a><strong>注意点</strong></h5><ol><li>后代选择器必须用空格隔开每个选择器</li><li><font color="orange"><code>后代选择器可以通过空格一直延续下去</code></font>, 例如:选择器 1 选择器 2 选择器 3 … 选择器 N{ 属性: 值; }</li><li><font color="red"><code>顾名思义, 后代选择器不仅包含”儿子”, 还包含”孙子”, “重孙子”等, 一般来说, 只要 B 控件显示在 A 控件上, 那么 B 控件就是 A 控件的后代.</code></font></li><li>后代选择器不仅可以使用类型选择器, 还可以使用类选择器, id 选择器以及后面提及的属性选择器等.</li><li>Qt 中, 各控件的父子关系:通过简单的验证, 各控件的父子关系并非我们在创建对象时所指定的那样, <font color="orange"><code>实际父子关系取决于如何布局.</code> </font></li></ol><h5 id="一般用法-4"><a href="#一般用法-4" class="headerlink" title="一般用法"></a><strong>一般用法</strong></h5><p>后代选择器一般用于指定特定类的后代的样式, 例如在我的应用程序中, 有很多个相似的对话框, 它们中包含一些样式相同的按钮, 那么我可以使用后代选择器为他们指定样式, 例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BaseDialog QPushButton{</span><br><span class="line"><span class="attribute">min-width</span>: <span class="number">120px</span>;</span><br><span class="line"><span class="attribute">min-height</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">max-width</span>: <span class="number">120px</span>;</span><br><span class="line"><span class="attribute">max-height</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0px</span>; </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h4 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a><strong>子元素选择器</strong></h4><h5 id="格式-5"><a href="#格式-5" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器<span class="number">1</span> &gt;选择器<span class="number">2</span> { 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>子元素选择器表示找到指定选择器所匹配的对象中的所有特定直接子元素然后设置属性, </p><p>即找到选择器 1 匹配到的对象中的被选择器 2 匹配盗的直接子元素然后设置属性</p><p><strong>注意点</strong></p><ol><li><p>子元素选择器必须用”&gt;”连接, “&gt;”两边有没有空格都可以, 但是不建议写空格, 因为会与后代选择器的连接符混淆.</p></li><li><p><font color="orange"><code>子元素选择器只会查找”儿子”, 不会查找其他后代.</code></font></p></li><li><p>子元素选择器不仅可以使用类型选择器, 还可以使用类选择器,id 等选择器</p></li><li><p><font color="red"><code>子元素选择器不能通过”&gt;”一直延续下去, 只能有一个”&gt;”</code></font></p></li><li><p>由于 Qt 中有继承关系的 Widgets 较多, 在使用子元素选择器时, 请特别注意继承关系,比如我只想选中 QGroupBox 中的 QPushButton, 那么我即可以写成</p></li></ol>   <figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QWidget&gt;QPushButton{<span class="attribute">color</span>: red;} </span><br><span class="line"><span class="comment">/*也可以写成*/</span></span><br><span class="line">QGroupBox&gt;QPushButton{<span class="attribute">color</span>: red;} </span><br></pre></td></tr></tbody></table></figure><p>   这是因为 QGroupBox 是 QWidget 的派生类, 类型选择器 QWidget 会选中所有它的派生类对象,这些对象中包括 QGroupBox, 因此写法.1 会将所有的 QPushButton 的前景色设置为红色.鉴于此种情况, 我推荐在使用子元素选择器时, 使用类选择器替代类型选择器.</p><h5 id="一般用法-5"><a href="#一般用法-5" class="headerlink" title="一般用法"></a><strong>一般用法</strong></h5><p>子元素选择器一般用于一些特定布局条件中的控件, 例如我想给直接布局在 QGroupBox 的QCheckBox 设置一些特定属性, 那么可以这样做: </p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.QGroupBox</span> &gt; <span class="selector-class">.QCheckBox</span>{</span><br><span class="line"><span class="attribute">color</span>: blue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a><strong>属性选择器</strong></h4><h5 id="格式-6"><a href="#格式-6" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[attribute=value]</span>{ 属性: 值; }</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[attribute|=value]</span>{ 属性:值; }</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[attribute~=value]</span>{ 属性:值; }</span><br></pre></td></tr></tbody></table></figure><blockquote><p><font color="orange"><code>attribute=value 表示匹配有特定属性 attribute, 并且值为 value 的所有控件, 然后设置样式;</code></font></p><p><font color="orange"><code>attribute|=value 表示匹配有特定属性 attribute, 并且值以 value 开头的所有控件, 然后设置样式;</code></font></p><p><font color="orange"><code>attribute~=value 表示匹配有特定属性 attribute, 并且值包含 value 的所有控件, 然后设置样 式;</code></font></p></blockquote><h5 id="注意点-4"><a href="#注意点-4" class="headerlink" title="注意点"></a><strong>注意点</strong></h5><p><font color="red"><code>attribute|=value 表示 attribute 属性的值以 value 开头, 无论 value 后面还有没有值, 或者value 后面是什么, 均能匹配到</code></font>, 例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[objectName|=<span class="string">"button"</span>]</span>{</span><br><span class="line"><span class="attribute">color</span>: red; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这表示将 objectName 属性以 button 开头的所有控件的前景色设置为红色.</p><p><font color="red"><code>attribute~=value 表示 attribute 属性的值中包含 value, 这里要注意的是:value 必须是独立的单词, 也就是包含 value 并且 value 是被空格隔开的</code></font>, 例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[objectName~=<span class="string">"button"</span>]</span>{</span><br><span class="line"><span class="attribute">color</span>: red; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>而我在代码中, 设置的 objectName 的语句为:</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081327869.png"></p><p>结果是只匹配到了 pBtn2 所指的对象</p><h5 id="官方文档的解释"><a href="#官方文档的解释" class="headerlink" title="官方文档的解释:"></a>官方文档的解释:</h5><p>通常情况下, 这里的属性指的是, 使用 <font color="blue"><code>Q_PROPERTY</code> </font>宏所声明的属性, 并且属性类型要受 <font color="orange"><code>QVariant::toString()</code></font>支持.</p><p>这个选择器类型也可以用来判断动态属性，要了解更多使用自定义动态属性的细节，请参考使用自定义动态属性 </p><p><font color="orange"><code>除了使用=，你还可以使用~=来判断一个 QStringList 中是否包含给定的 QString</code></font>。警告：如果在设置了样式表后，相应的属性值发生了改变(如：flat 变成了”true”)，则有必要重新加载样式表，一个有效的方法是，取消样式表，再重新设置一次,下面的代码是其中一种方式：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">style()-&gt;unpolish(this);</span><br><span class="line"></span><br><span class="line">style()-&gt;polish(this);</span><br></pre></td></tr></tbody></table></figure><h5 id="一般用法-6"><a href="#一般用法-6" class="headerlink" title="一般用法"></a><strong>一般用法</strong></h5><p>属性选择器一般不常用, 如果要用, 请参照官方文档的方法使用</p><h4 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a><strong>并集选择器</strong></h4><h5 id="格式-7"><a href="#格式-7" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器<span class="number">1</span>,选择器<span class="number">2</span>,选择器<span class="number">3</span>{ 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>并集选择器表示, 将每个单独选择器匹配到的控件放在同一个结果集中, 并给结果集中的每个控件都设置声明语句中的样式.</p><h5 id="注意点-5"><a href="#注意点-5" class="headerlink" title="注意点"></a><strong>注意点</strong></h5><ol><li>并集选择器必须使用”,”来连接不同的选择器</li><li>并集选择器可以使用类选择器, 类型选择器, id 选择器, 属性选择器等.</li></ol><p><strong>一般用法</strong></p><p>主要用于给具有相同属性并且外观相似的的控件设置样式, 例如: </p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.QLineEdit</span>, <span class="selector-class">.QComboBox</span>{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid gray;</span><br><span class="line"><span class="attribute">background-color</span>:white; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="两个特殊的选择器"><a href="#两个特殊的选择器" class="headerlink" title="两个特殊的选择器"></a><strong>两个特殊的选择器</strong></h4><h5 id="子控件选择器"><a href="#子控件选择器" class="headerlink" title="子控件选择器"></a><strong>子控件选择器</strong></h5><h5 id="格式-8"><a href="#格式-8" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型选择器::子控{ 属性: 值; }</span><br><span class="line"></span><br><span class="line">类选择器::子控件{ 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>表示对类型选择器或类选择器指定的所有控件的<font color="orange"><code>子控件</code></font>设置样式;</p><p><strong>Qt</strong> <strong>官方说明</strong> </p><p>为了样式化你的复杂 widget，很有必要使用 widget 的 subcontrol，比如 QComboBox 的 drop-down 部分或者是 QSpinBox 的上和下箭头。选择器也许会包含 subcontrols 用于限制 widget的 subcontrols, 举个例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QComboBox::down-arrow{</span><br><span class="line">image: <span class="built_in">url</span>(<span class="string">:/res/arrowdown.png</span>); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述规则样式化所有 QComboBox 的 drop-down 部分，虽然双冒号(::)让人联想到 CSS3 的伪元素语法，但是 Qt 的 Sub-Controls 跟它是不一样的。</p><p> Sub-Controls 始终相对于另一个元素来定位–一个参考元素。这个参考元素可以是一个Widget 又或者是另一个 Sub-Control。举个例子，QComboBox 的::drop-down 默认被放置于QComboBox 的 Padding rectangle(盒子模型)的右上角。::drop-down 默认会被放置于另一个::drop-down Sub-Control 的中心。查看可样式化的 Widget 列表以了解更多使用 Sub-Control来样式化 Widget 和初始化其位置的内容。源 rectangle 可以使用 subcontrol-origin 来改变。</p><p>举个例子，如果我们想要把 drop-down 放置于 QComboBox 的 margin rectangle 而不是默认的 Padding rectangle，我们可以像下面这样指</p><p>定：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QComboBox {</span><br><span class="line"><span class="attribute">margin-right</span>: <span class="number">20px</span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">QComboBox::drop-down {</span><br><span class="line">    subcontrol-origin: margin; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>drop-down 在 Margin rectangle 内的排列方式可以由 subcontrol-position 来改变. </p><p>width 和 height 属性可以用来控制 Sub-control 的 size.需要注意的是，设置了 image 就隐式的设置了 Sub-control 的 size 了。</p><ol><li>相对定位方案（position:relative）,允许 Sub-Control 的位置从它的初始化位置作出偏移。</li></ol><p>举个例子，当 QComboBox 的 drop-down 按钮被 pressed 时，我们也许想要那个箭头作出位移以显示一种“pressed”的效果，为了达到目标，我们可以像下面那样指定</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QComboBox::down-arrow {</span><br><span class="line"> image*: <span class="built_in">url</span>(<span class="string">down_arrow.png</span>); </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">QComboBox::down-arrow:pressed {</span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">1px</span>; <span class="attribute">left</span>: <span class="number">1px</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>绝对定位方(position : absolute)，使得 Sub-control 的 position 和 size 基于其参考元素而改</li></ol><p>变。一旦定位，它们将会与 widget 同等对待并且可以使用盒子模型来样式化。查看 Sub-Control 列表以了解那些 sub-control 是被支持的，并且可以查看自定义QPushButton 的菜单指示器 Sub-Control 来了解一个实际的使用例子。注意：像 QComboBox 和 QScrollBar 这样的复杂部件，如果 sub-control 的一项属性是自定义的，那么其他所有的属性跟 sub-control 也都应该自定义。</p><h5 id="子控件表（参考）"><a href="#子控件表（参考）" class="headerlink" title="子控件表（参考）"></a>子控件表（参考）</h5><table><thead><tr><th>子部件</th><th>描述</th></tr></thead><tbody><tr><td>::down-arrow</td><td>combo box或spin box的下拉箭头</td></tr><tr><td>::down-button</td><td>spin box的向下按钮</td></tr><tr><td>::drop-down</td><td>combo box的下拉箭头</td></tr><tr><td>::indicato</td><td>checkbox、radio button或可选择group box的指示器</td></tr><tr><td>::item</td><td>menu、menu bar或status bar的子项目</td></tr><tr><td>::menu-indicator</td><td>push button的菜单指示器</td></tr><tr><td>::title</td><td>group box的标题</td></tr><tr><td>::up-arrow</td><td>spin box的向上箭头</td></tr><tr><td>::up-button</td><td>spin box的向上按钮</td></tr></tbody></table><h5 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a><strong>伪类选择器</strong></h5><h5 id="格式-9"><a href="#格式-9" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型选择器:状态{ 属性: 值; }</span><br><span class="line"></span><br><span class="line">类选择器:状态{ 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>表示对类型选择器或类选择器指定的所有控件设置它在指定状态时的样式.</p><p><strong>Qt</strong> <strong>官方说明</strong> </p><p>选择器也许会包含基于 widget 的 state 的程序限制规则的伪状态。<font color="orange"><code>伪状态以冒号(:)作为分隔紧跟着选择器</code></font>。举个例子，下面的规则在鼠标悬浮在 QPushButton 的上方时生效：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:hover</span> { <span class="attribute">color</span>: white }</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>伪状态可以使用感叹号进行取反</code></font>，下面一条规则在鼠标没有悬浮在 QRadioButton 上方时生效：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QRadioButton:!hover { <span class="attribute">color</span>: red }</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>伪状态可以链接，在这样的情况下，隐式地包含了逻辑与</code></font>。举个例子，下面一条规则在鼠标悬浮到一个已 check 的 QCheckBox 上时生效：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QCheckBox<span class="selector-pseudo">:hover</span><span class="selector-pseudo">:checked</span> { <span class="attribute">color</span>: white }</span><br></pre></td></tr></tbody></table></figure><p>伪状态的取反也可以出现在伪状态链中，举个例子，下面的规则在鼠标悬浮到一个没有被press 的 QPushButton 上时生效：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:hover</span>:!pressed { <span class="attribute">color</span>: blue; }</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>如果有需要，可以使用逗号来表示逻辑或, 即并集选择器</code></font></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QCheckBox<span class="selector-pseudo">:hover</span>, QCheckBox<span class="selector-pseudo">:checked</span> { <span class="attribute">color</span>: white }</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>伪状态可以与 subcontrol 组合使用</code></font>，举个例子：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QComboBox::drop-down:hover { *image*: <span class="built_in">url</span>(<span class="string">dropdown_bright.png</span>) }</span><br></pre></td></tr></tbody></table></figure><h5 id="伪状态表（参考）"><a href="#伪状态表（参考）" class="headerlink" title="伪状态表（参考）"></a>伪状态表（参考）</h5><table><thead><tr><th>伪状态</th><th>描述</th></tr></thead><tbody><tr><td>:unchecked</td><td>button部件未被选中</td></tr><tr><td>:checked</td><td>button部件被选中</td></tr><tr><td>:disabled</td><td>部件被禁用</td></tr><tr><td>:enabled</td><td>部件被启用</td></tr><tr><td>:focus</td><td>部件获得焦点</td></tr><tr><td>:hover</td><td>鼠标位于部件上</td></tr><tr><td>:indeterminate</td><td>checkbox或radiobutton被部分选中</td></tr><tr><td>:off</td><td>部件可以切换，且处于off状态</td></tr><tr><td>:on</td><td>部件可以切换，且处于on状态</td></tr><tr><td>:pressed</td><td>部件被鼠标按下</td></tr></tbody></table><h4 id="没有选择器的情况"><a href="#没有选择器的情况" class="headerlink" title="没有选择器的情况"></a><strong>没有选择器的情况</strong></h4><p>如果在 c++的代码中直接调用控件对象的 setStyleSheet 函数来设置样式,但样式中没有任何选择器, 例如下面这样</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pBtn1-&gt;setStyleSheet("<span class="attribute">color</span>: green;");</span><br></pre></td></tr></tbody></table></figure><p>即使这种写法可以生效, 但它不符合语法规则, 因此不推荐使用.经过测试, <font color="red"><code>这样的语句被忽略的选择器相当于通用选择器</code></font>或下面例子中的选择器, 假如 pBtn1 是一个 QPushButton 对象的指针, 那么这条语句等价于</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pBtn1-&gt;setStyleSheet("QPushButton, QPushButton *{<span class="attribute">color</span>: green;}");</span><br></pre></td></tr></tbody></table></figure><h4 id="选择器的匹配规则"><a href="#选择器的匹配规则" class="headerlink" title="选择器的匹配规则"></a><strong>选择器的匹配规则</strong></h4><p>之所以要把这个问题单独作为一个小节来写, 是因为在日常开发过程中, 经常会犯这方面的错误.</p><p>下面看一个例子:假如需要完成一个界面, 如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081409652.png"></p><p>这里用户名输入框是一个 QComboBox 对象, 密码输入框是一个 QLineEdit 对象, 它们的父控件是一个 QDialog, 有这样一个需求:给这两个输入框设置相同的边框属性: 1 个像素宽的蓝色实线框, 为了方便更改风格, 我有一个 css 文件, 将所有样式都写在了这个文件里, 这时, 观察发现, 这两个控件都是QDialog的子控件,于是可以用后代选择器或者子元素选择器, 如下:</p><p>第一种:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QDialog QComboBox,QLineEdit{</span><br><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid blue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第二种:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QDialog&gt;QComboBox,QLineEdit{</span><br><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid blue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当我写完并运行程序后, 发现无论采用哪种写法 QComboBox 是正常的, 但是我的程序界面中, <font color="orange"><code>其他所有的 QLineEdit 的边框都变成了 1 个像素款的蓝色实线框</code></font>, 而这并不是我想要的效果.</p><p>因此对于上面的现象, 我们很容易得出结论: <font color="red"><code>多个选择器组合(并集选择器)使用时, 它们的结合方向是自右向左, 而不是我们认为的自左向右</code></font>.也就是说, 这两个选择器分别被理解为<font color="orange"><code>(QDialogQComboBox), QLineEdit</code></font> 和<font color="orange"><code>(QDialog&gt;QComboBox),QLineEdit</code>.</font></p><p>其实, 这应该与 CSS 的选择器匹配规则是一样的, 是为了提高效率的一种做法, 具体原因这 里不细谈.</p><p>正确的写法应该是</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QDialog QComboBox, QDialog QLineEdit{</span><br><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid blue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>或</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QDialog&gt;QComboBox, QDialog&gt;QLineEdit{</span><br><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid blue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Qss-的特性"><a href="#Qss-的特性" class="headerlink" title="Qss 的特性"></a><strong>Qss</strong> <strong>的特性</strong></h2><h3 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a><strong>层叠性</strong></h3><p>qss 的语法来源于 css, 而 css 的全称是 Cascading StyleSheet, 翻译过来叫做层叠样式表,</p><p>也叫级联样式表, 本文中一律使用层叠样式表.</p><p>层叠性是 css 处理冲突的一种能力.</p><p>只有在多个选择器匹配到同一个控件时才会发生层叠性, 如下面的例子:</p> <figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pBtn1-&gt;setStyleSheet("QPushButton{<span class="attribute">color</span>: blue;}");</span><br><span class="line"></span><br><span class="line"> pBtn1-&gt;setStyleSheet("<span class="selector-class">.QPushButton</span>{<span class="attribute">color</span>: green;}");</span><br></pre></td></tr></tbody></table></figure><p>这两个选择器匹配到了同一个按钮, (<font color="orange"><code>选择器优先级相同的情况下</code></font>)结果是后面的样式覆盖掉了前面的, 这就是层叠现象.</p><h3 id="继承性-Qt-Version-gt-x3D-5-7"><a href="#继承性-Qt-Version-gt-x3D-5-7" class="headerlink" title="继承性(Qt-Version >= 5.7)"></a><strong>继承性</strong><strong>(Qt-Version &gt;= 5.7)</strong></h3><p>在典型的 CSS 中，如果一个标签的字体和颜色没有显式设置，它会自动从其父亲获得。当使</p><p>用 Qt 样式表时，控件**<font color="orange">不会</font>**从其<font color="orange"><strong>父亲(不是父类)</strong></font>继承字体和颜色的设置(请注意，父亲和父类、孩子和子类都是不同的概念，不要搞混)</p><p>举个例子，考虑一个 QGroupBox 内有一个 QPushButton：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qApp-&gt;setStyleSheet("QGroupBox{ <span class="attribute">color</span>: red; }");</span><br></pre></td></tr></tbody></table></figure><p>QPushButton 没有任何显式的 color 设置。因此，<font color="orange"><code>它会获得系统的颜色而不是从父亲继承 color的值</code></font>。如果我们要设置 QGroupBox 及其所有孩子的 color，我们可以这样写：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qApp-&gt;setStyleSheet("QGroupBox,QGroupBox * { <span class="attribute">color</span>: red; }");</span><br></pre></td></tr></tbody></table></figure><p>注意 QGroupBox 和*之间的空格。与此相反，使用 QWidget::setFont()可以设置字体包括孩子的字体，使用 <font color="orange"><code>QWidget::setPalette()</code></font>可以设置调色板包括孩子的调色板。如果想要字体和调 色板被孩子继承 , 可以给 QApplication 设 置<font color="orange"><code>Qt::AA_UseStyleSheetPropagationInWidgetStyles</code></font>(Qt5.7 加入)属性, 例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QCoreApplication::<span class="built_in">setAttribute</span>(Qt::AA_UseStyleSheetPropagationInWidgetStyles, true);</span><br></pre></td></tr></tbody></table></figure><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a><strong>优先级</strong></h2><p>为什么要有优先级？</p><p>当一个控件被多个选择器选中并且设置了相同的属性（值不同）时， 不能仅仅根据设置样式语句出现的先后顺序进行层叠, 那么控件的样式如何确定，于是引出了选择器的优先级问题。</p><p>一般通过下面两步进行选择器优先级的判定.</p><h3 id="第一步：-设置方式所产生的优先级问题"><a href="#第一步：-设置方式所产生的优先级问题" class="headerlink" title="第一步： 设置方式所产生的优先级问题"></a><strong>第一步：</strong> <strong>设置方式所产生的优先级问题</strong></h3><p>在 CSS 中， 有如下层叠优先级规则：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内联样式&gt;内部样式&gt;外部样式&gt;浏览器缺省</span><br></pre></td></tr></tbody></table></figure><p>而在 Qss 中, 这个规则表现为:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给控件直接设置的样式&gt;给QApplication设置的样式</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>就是说， 调用控件的 setStylesheet 设置的样式的优先级永远高于给 QApplication 设置的样式， 即使 QApplication 中的选择器优先级更高</code></font></p><h3 id="第二步：样式表本身的优先级问题"><a href="#第二步：样式表本身的优先级问题" class="headerlink" title="第二步：样式表本身的优先级问题"></a><strong>第二步：样式表本身的优先级问题</strong></h3><p>当设置方式相同，且几个样式规则为同一个控件的同一个属性指定不同的值时,就产生了冲突.此时, 如何层叠就由选择器的优先级来确定.一般而言，<font color="red"><code>选择器越特殊，它的优先级越高。也就是选择器指向的越准确，它的优先级就越高。</code></font></p><h3 id="优先级判断的三种方式"><a href="#优先级判断的三种方式" class="headerlink" title="优先级判断的三种方式"></a><strong>优先级判断的三种方式</strong></h3><h4 id="间接选中"><a href="#间接选中" class="headerlink" title="间接选中"></a>间接选中</h4><p>间接选中就是指继承, 也就是在 Qt5.7 及以上版本, 程序中给 <font color="orange"><code>QApplication</code></font> 对象设置了<font color="purple"><code>Qt::AA_UseStyleSheetPropagationInWidgetStyles</code> </font>属性时, 才会有间接选中.</p><p><font color="orange"><code>如果是间接选中,那么最终的样式就是离目标最近的那个</code></font>, 这里的近指的是两个控件的父子关系. </p><p>例如:</p><blockquote><p>一个 QPushButton 对象被布局在 QGroupBox 中, 而 QGroupBox 又被布局在 QWidget 中, 此时如果给 QGroupBox 和 QWidget 都设置了 color 属性的颜色, 那么无论设置顺序如何, QPushButton 的前景色总是表现为 QGroupBox 设置的颜色, 因为QGroupBox 显然是离 QPushButton 最近的那一个.</p></blockquote><h4 id="相同选择器-直接选中"><a href="#相同选择器-直接选中" class="headerlink" title="相同选择器(直接选中)"></a>相同选择器(直接选中)</h4><p>如果都是直接选中, 并且都是同类型的选择器, 那么写在后面的样式会覆盖掉前面的样式, 例如</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pBtn1-&gt;setStyleSheet("QPushButton{<span class="attribute">color</span>: green;}");</span><br><span class="line"></span><br><span class="line">pBtn1-&gt;setStyleSheet("QPushButton{<span class="attribute">color</span>: blue;}");</span><br></pre></td></tr></tbody></table></figure><p>显而易见, pBtn1 的前景色是蓝色.</p><h4 id="不同选择器-直接选中"><a href="#不同选择器-直接选中" class="headerlink" title="不同选择器(直接选中)"></a>不同选择器(直接选中)</h4><p>如果都是直接选中, 并且不是相同类型的选择器, 那么就会按照选择器的优先级来层叠.</p><p>具体的优先级如下: </p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Id &gt; 类 &gt; 类型 &gt; 通配符 &gt; 继承 &gt; 默认</span><br></pre></td></tr></tbody></table></figure><h3 id="优先级权重"><a href="#优先级权重" class="headerlink" title="优先级权重"></a><strong>优先级权重</strong></h3><p>为什么会有优先级权重？</p><p>当多个选择器混合在一起使用时, 我们可以通过计算权重来判断谁的优先级最高,从而确定控件的样式.</p><p>注意点： </p><p><font color="red"><code>只有选择器是直接选中控件时才需要计算权重， 否则直接选择器高于一切间接选中的选择器</code></font></p><p>优先级权重的计算方式:</p><blockquote><ol><li><p>计算选择器中的 id 选择器数量[=a]</p></li><li><p>计算选择器中类选择器的数量+属性选择器的数量[=b]</p></li><li><p>计算选择器中类型选择器的数量[=c]</p></li><li><p>忽略子控件选择器</p></li></ol><p>串联这三个数字 a-b-c 就得到优先级权重, 数字越大优先级越高.</p></blockquote><p>串联这三个数字 a-b-c 就得到优先级权重, 数字越大优先级越高.</p><p>这里给出我写的一个例子， qss 文件位于资源文件中：</p><h3 id="Qt-官方关于冲突解决的说明"><a href="#Qt-官方关于冲突解决的说明" class="headerlink" title="Qt 官方关于冲突解决的说明"></a><strong>Qt</strong> <strong>官方关于冲突解决的说明</strong></h3><p>当几个样式规则为同一个属性指定不同的值时，就产生了冲突。请考虑下面的样式表：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QPushButton**<span class="selector-id">#okButton</span>** { <span class="attribute">color</span>: gray; }</span><br><span class="line"></span><br><span class="line">QPushButton { <span class="attribute">color</span>: red; }</span><br></pre></td></tr></tbody></table></figure><p>两条规则都匹配名为 okButton 的 QPushButton 实例并且冲突于颜色属性。为了解决冲突，我们必须考虑到选择器的特殊性。在上面的例子中，QPushButton#okButton 被视为比QPushButton 更特殊，<font color="orange"><code>因为它（通常）指向一个单一的对象而不是 QPushButton 的所有实例</code></font>。 相似的，<font color="orange"><code>指定了伪状态的选择器比没有指定伪状态的更特殊</code></font>。从而，下面的样式表指明了当鼠标悬浮到 QPushButton 上方时其字体颜色应该为白色，而其余情况则为红色：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:hover</span> { <span class="attribute">color</span>: white; }</span><br><span class="line"></span><br><span class="line">QPushButton { <span class="attribute">color</span>: red; }</span><br></pre></td></tr></tbody></table></figure><p>接下来看一个很有意思的：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:hover</span> { <span class="attribute">color</span>: white; }</span><br><span class="line"></span><br><span class="line">QPushButton<span class="selector-pseudo">:enabled</span> { <span class="attribute">color</span>: red; }</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>两个选择器都有相同的特殊性</code></font>，所以当鼠标悬浮在一个 enabled 的按钮上时，第二条规则优先。</p><p>如果在这种情况下我们想要文字变成白色，我们可以像下面那样重新排布一下样式规则：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:enabled</span> { <span class="attribute">color</span>: red; }</span><br><span class="line"></span><br><span class="line">QPushButton<span class="selector-pseudo">:hover</span> { <span class="attribute">color</span>: white; }</span><br></pre></td></tr></tbody></table></figure><p>另外，我们可以使第一条规则更特殊一些：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:hover</span><span class="selector-pseudo">:enabled</span> { <span class="attribute">color</span>: white; }</span><br><span class="line"></span><br><span class="line">QPushButton<span class="selector-pseudo">:enabled</span> { <span class="attribute">color</span>: red; }</span><br></pre></td></tr></tbody></table></figure><p>相似的问题出现在相互配合的类型选择器上。考虑以下情况：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QPushButton { <span class="attribute">color</span>: red; }</span><br><span class="line"></span><br><span class="line">QAbstractButton { <span class="attribute">color</span>: gray; }</span><br></pre></td></tr></tbody></table></figure><p>两条规则都应用于 QPushButton 的实例（因为 QPushButton 继承于 QAbstractButton）并且冲突于 color 属性。因为 QPushButton 继承于 QAbstractButton，这让人不禁想到 QPushButton比 QAbstractButton 更特殊(<font color="red">并没有更特殊</font>)。然而，<font color="orange"><code>对于样式表的运算，所有的类型选择器都具有同等的特殊性，并且出现在更后面的规则优先级更高</code></font>。换句话说，QAbstractButton 的 color 会被设置成灰色，包括 QPushButton。如果我们确实想要 QPushButton 字体颜色设置为红色，<font color="orange"><code>我们总是可以使用重新排列样式表规则顺序的方式实现</code></font>。</p><p>为确定规则的特殊性，Qt 样式表跟随 CSS2 规范</p><p>一个选择器的特殊性由下面的方式计算：</p><blockquote><ul><li><p>计算选择器中 ID 属性的数量[=a] </p></li><li><p>计算选择器中其他属性和伪类的数量[=b] </p></li><li><p>计算选择器中元素名字的数量[=c] </p></li><li><p>忽略伪原素[如:subcontrol]</p></li></ul></blockquote><p>串联这三个数字<font color="orange"> <code>a-b-c</code></font>（在一个大基数的数字系统）就得到了特殊性等级。</p><p>举个例子：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* {} <span class="comment">/* a=0 b=0 c=0 -&gt; specificity = 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">LI</span> {} <span class="comment">/* a=0 b=0 c=1 -&gt; specificity = 1 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">UL</span> <span class="selector-tag">LI</span> {} <span class="comment">/* a=0 b=0 c=2 -&gt; specificity = 2 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">UL</span> <span class="selector-tag">OL</span>+<span class="selector-tag">LI</span> {} <span class="comment">/* a=0 b=0 c=3 -&gt; specificity = 3 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">H1</span> + *<span class="selector-attr">[REL=up]</span>{} <span class="comment">/* a=0 b=1 c=1 -&gt; specificity = 11 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">UL</span> <span class="selector-tag">OL</span> <span class="selector-tag">LI</span><span class="selector-class">.red</span> {} <span class="comment">/* a=0 b=1 c=3 -&gt; specificity = 13 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">LI</span><span class="selector-class">.red</span><span class="selector-class">.level</span> {} <span class="comment">/* a=0 b=2 c=1 -&gt; specificity = 21 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#x34y</span> {} <span class="comment">/* a=1 b=0 c=0 -&gt; specificity = 100 */</span></span><br></pre></td></tr></tbody></table></figure><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a><strong>盒模型</strong></h2><p>在讲解属性之前, 我们必须了解一下 QSS 的盒模型.</p><h3 id="什么是盒模型"><a href="#什么是盒模型" class="headerlink" title="**什么是盒模型? **"></a>**什么是盒模型? **</h3><p>盒模型仅仅是一个形象的比喻, 所有的 widget 都被看做是一个”盒子”, 一个盒子包括：外边距，边框，内边距，和实际内容. 它们可以看作是有包含关系的矩形, 并且这种包含关系是固定不变的.</p><p>如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081520165.png"></p><blockquote><p><strong>Margin</strong> <strong>（外边距）</strong> - 与其他盒子之间的距离.</p><p><strong>Border</strong> <strong>（边框）</strong> - 外边距与内边距之间的区域.边框有自己的颜色不会受到盒子的背景颜色影响</p><p><strong>Padding</strong> <strong>（内边距）</strong> - 内容和边框之间的区域.会受到背景颜色影响. </p><p><strong>Content</strong> <strong>（内容）</strong> - 盒子的内容,显示文本,图像或其他控件</p></blockquote><p>除了内容外, 其他三个部分均不能单独设置颜色, 只能设置其宽度, 并且是以像素为单位.</p><p>对比一张生活中的一张照片墙来看会更容易理解</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081522950.png"></p><h3 id="盒模型中的宽度与高度"><a href="#盒模型中的宽度与高度" class="headerlink" title="盒模型中的宽度与高度"></a><strong>盒模型中的宽度与高度</strong></h3><p>在属性中将要学到的 width, height 两个属性, 设置的均是盒子的<strong>内容</strong>的宽高, 而我们在 c++</p><p>代码中的窗口的 width 与 height 指的是<strong>整个盒子的宽度与高度</strong>, 这一点非常重要.</p><p>整个盒子的宽度应该等于:</p><p>左外边距 + 左边框 + 左内边距 + 内容宽度 + 右内边距 + 右边框 + 右外边距,</p><p>同理, 整个盒子的高度也是上下外边距,内边距,边框和内容高度的和.</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a><strong>属性</strong></h4><p><font color="orange"><code>属性即控件的具体外观样式</code></font>, 比如背景颜色, 边框宽度等等. 本节主要列举一些常用的属性,并介绍它们的具体格式或取值</p><p>注意:<font color="red"><code>一个属性并不是被所有 widget 都支持的</code></font>, 要想查看什么 widget 支持哪些属性, 或一个属性被哪些 widget 支持, 请查看文档后面给出的官方链接.</p><h4 id="背景属性-background"><a href="#背景属性-background" class="headerlink" title="背景属性 background"></a><strong>背景属性</strong> <strong>background</strong></h4><p>背景共有 7 个属性, <font color="orange"><code>既可以每个属性单独设置, 也可以连写</code></font>, 下面将对他们逐一进行分析,并在最后给出其连写格式</p><h5 id="background-color"><a href="#background-color" class="headerlink" title="background-color"></a><strong>background-color</strong></h5><p>取值: Brush 类型(Brush 类型介绍见本节最后)</p><p>作用: 设置控件的背景颜色, <font color="orange"><code>默认是 border 之内的矩形区域, 包括内边距和内容矩形</code></font>.</p><h5 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a><strong>background-image</strong></h5><p>取值: Url 类型, 格式是 url(filename), <font color="orange"><code>filename 是一个本地文件路径或 Qt 资源文件路径, 不支持网络图片</code></font></p><p>作用: 设置控件的背景图片. <font color="orange"><code>可以与背景颜色共存, 背景图片会覆盖背景颜色, 在没有被图片覆盖的区域, 显示背景颜色.</code></font></p><h5 id="background-repeat"><a href="#background-repeat" class="headerlink" title="background-repeat"></a><strong>background-repeat</strong></h5><p>取值:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repeat-x: 在水平方向上平铺</span><br><span class="line"></span><br><span class="line">repeat-y: 在垂直方向上平铺</span><br><span class="line"></span><br><span class="line">repeat: 在水平和垂直方向上都平铺, 这是默认值(但是 Qt 好像有 bug, 设置了 repeat 反而不会平铺, 不设置才平铺)</span><br><span class="line"></span><br><span class="line">no-repeat: 不平铺</span><br></pre></td></tr></tbody></table></figure><p>作用: <font color="orange"><code>设置背景图片的平铺方式.</code> </font></p><p>例子: </p><p>给一个 QTextEdit 设置背景图片,代码和效果分别如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>);</span><br><span class="line"><span class="attribute">background-repeat</span>: no-repeat;<span class="comment">/*repeat-x; repeat-y; repeat;*/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081535428.png" alt="repeat-x"><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081535917.png" alt="repeat-y"></p><p>​            </p><p>  <img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081535678.png" alt="repeat"><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081535053.png" alt="no-repeat">  </p><p>​</p><h5 id="background-position"><a href="#background-position" class="headerlink" title="background-position"></a><strong>background-position</strong></h5><p>取值:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">top</span>: 向上对齐 left: 向左对齐</span><br><span class="line"></span><br><span class="line">bottom: 向下对齐 right:向右对齐</span><br><span class="line"></span><br><span class="line">center: 居中</span><br></pre></td></tr></tbody></table></figure><p>格式:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-position</span>: 水平对齐方式 垂直对齐方式;</span><br></pre></td></tr></tbody></table></figure><p>这是 css 规定的标准顺序, 而 qss 并未严格规定, 但建议按照 css 的顺序写</p><p>作用: <font color="orange"><code>设置背景图片的对齐方式, 默认情况下向左向上对齐,</code></font></p><p>举例: 水平向左垂直居中对齐, 代码和效果如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>);</span><br><span class="line"><span class="attribute">background-position</span>: right center; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081535623.png"></p><h5 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a><strong>background-attachment</strong></h5><p>取值:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scroll : 滚动, 这是默认值</span><br><span class="line"></span><br><span class="line">fixed: 固定</span><br></pre></td></tr></tbody></table></figure><p>作用: <font color="orange">设置背景图片在带滚动条的控件(QAbstractScrollArea)中是固定在一个位置还是随着滚动条滚动.</font></p><p>比如: css 代码分别如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>);</span><br><span class="line"><span class="attribute">background-repeat</span>: no-repeat;<span class="comment">/*repeat-x; repeat-y; repeat;*/</span></span><br><span class="line"><span class="attribute">background-position</span>: right center;</span><br><span class="line"><span class="attribute">background-attachment</span>: scroll; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;<span class="comment">/*repeat-x; repeat-y; repeat;*/</span></span><br><span class="line"><span class="attribute">background-position</span>: right center;</span><br><span class="line"><span class="attribute">background-attachment</span>: fixed; </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p>效果图</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081541879.png" alt="scroll "><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081541064.png" alt="fixed"></p><p>​</p><h5 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a><strong>background-clip</strong></h5><p>取值:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">margin</span>: 外边距矩形</span><br><span class="line"></span><br><span class="line">border: 边框矩形</span><br><span class="line"></span><br><span class="line">padding: 内边距矩形</span><br><span class="line"></span><br><span class="line">content: 内容矩形</span><br></pre></td></tr></tbody></table></figure><p>作用: <font color="orange"><code>设置背景颜色覆盖的区域, 默认情况下背景只覆盖内边距矩形, 如果没有指定, 默认值为 border</code></font></p><p>例子: 为了区别各矩形, 我们先给 QTextEdit 设置边框,内边距和外边距, 为了区别明显, 我们将边框宽度设置大一点</p><p>代码和图片如下:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">20px</span> solid purple;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>);</span><br><span class="line"><span class="attribute">background-repeat</span>: no-repeat;<span class="comment">/*repeat-x; repeat-y; repeat;*/</span></span><br><span class="line"><span class="attribute">background-position</span>: left top;</span><br><span class="line"><span class="attribute">background-attachment</span>: fixed; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205101117655.png"></p><p>分别将 background-clip 属性的值设为 margin, border, padding, content, </p><p>效果图如下</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081542686.png" alt="margin "><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081548247.png" alt="border"></p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081543791.png" alt="padding"><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081543463.png" alt="content"></p><pre><code>                                                                 content</code></pre><p><font color="orange"><code>可见, background-clip 属性只对背景的渲染区域有关系</code></font>, 背景图片始终是靠在 padding 边上</p><h5 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a><strong>background-origin</strong></h5><p>取值: 与 background-clip 一样</p><p>作用: 与 background-position 和 background-image 一起使用,<font color="orange"> 指明背景图片的覆盖范围矩形</font>,如果没有指定, <font color="orange">默认为 padding</font></p><p>下面是分别设置为 margin, border, padding 和 content 的代码和效果图</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">20px</span> solid purple;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>);</span><br><span class="line"> <span class="comment">/*background-repeat: no-repeat;*/</span><span class="comment">/*repeat-x; repeat-y; repeat;*/</span></span><br><span class="line"><span class="attribute">background-position</span>: left top;</span><br><span class="line"><span class="attribute">background-attachment</span>: fixed;</span><br><span class="line"><span class="attribute">background-clip</span>: margin; <span class="comment">/*border; padding; content;*/</span></span><br><span class="line"><span class="attribute">background-origin</span>: margin; <span class="comment">/*border; padding; content;*/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081548330.png" alt=" margin "><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081549270.png" alt="border"></p><p>​</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081808678.png" alt="padding"><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081549494.png" alt="content"></p><p>注意观察 border 与 padding 的图片, 它们是不同的, 差别就是 border 的 20 个像素所造成的不一致。</p><h5 id="背景属性的连写格式"><a href="#背景属性的连写格式" class="headerlink" title="背景属性的连写格式"></a><strong>背景属性的连写格式</strong></h5><p>格式:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background</span>: color image repeat position;</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>在这种连写格式中, 只能包含着四个属性, 其他几个仍然需要单独写, 而且这四个属性可以省略任何一个, 最多可以省略三个, 也就是最少需要保留一个,即属性值不能为空</code></font></p><p><font color="red"><code>另外让人比较迷惑的是, 在这种连写方式中,repeat 确实是平铺了图片, 而单独写时, 它又是不平铺的, 具体原因还未找到.</code></font></p><p>举个例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">20px</span> solid purple;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">background</span>: skyblue <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>) repeat left top; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>效果图</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081552920.png"></p><h4 id="前景属性-color"><a href="#前景属性-color" class="headerlink" title="前景属性 color"></a><strong>前景属性</strong> <strong>color</strong></h4><p>与背景相对应, 背景设置的是控件的最底层的颜色, 作为背景, 但 <font color="orange"><code>color 设置的前景色, 也就是控件文字的颜色</code></font>, color 属性是被所有 widget 都支持的.</p><p>格式:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">color</span>: Brush类型的值;</span><br></pre></td></tr></tbody></table></figure><p>举个例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081556014.png"></p><h4 id="边框属性-border"><a href="#边框属性-border" class="headerlink" title="**边框属性 border"></a>**<strong>边框属性</strong> <strong>border</strong></h4><p>边框属性有四种书写方式, 同样, 先逐一进行分析, 最后给出书写格式</p><h5 id="border-width"><a href="#border-width" class="headerlink" title="border-width"></a><strong>border-width</strong></h5><p>取值: ?px 像素宽度, 数值后面一定要加上像素单位 px, 也有其他单位, 但不推荐使用</p><p>作用:用于边框宽度</p><p>例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border-width</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">border-style</span>: solid;</span><br><span class="line"><span class="attribute">border-color</span>:purple;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">20px</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>效果图</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081557565.png"></p><h5 id="border-style"><a href="#border-style" class="headerlink" title="border-style"></a><strong>border-style</strong></h5><p>设置边框的渲染样式.</p><p>取值以及效果如下:</p><p>dashed </p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081557030.png"></p><p>dot-dash </p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081557540.png"></p><p>dot-dot-dash</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081557180.png"></p><p>dotted</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081558909.png"></p><p>double</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081558333.png"></p><p>groove</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081558590.png"></p><p>inset</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081558125.png"></p><p>outset</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081558853.png"></p><p>ridge</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081559284.png"></p><p>solid</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081559793.png"></p><p>none</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081559309.png"></p><h5 id="border-color"><a href="#border-color" class="headerlink" title="border-color"></a><strong>border-color</strong></h5><p>取值: Brush 类型</p><p>作用: 设置边框的颜色</p><h5 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a><strong>border-radius</strong></h5><p>取值: 水平半径 垂直半径;</p><p>均是以像素为单位, 值必须带 px, 第二个值是可选的, 如果只有一个值, 表示同时水平半径和垂直半径, 如果有两个值, 则第一个代表水平半径, 第二个代表垂直半径.</p><p>示例图</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081600183.png"></p><p>作用: 设置边框四个角的弧度</p><p>举个例子:</p><p>代码 1:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line">border-width: 10px;</span><br><span class="line">border-style: solid;</span><br><span class="line">border-color: red;</span><br><span class="line">border-radius: 50px;</span><br><span class="line">padding: 20px;</span><br><span class="line">margin: 20px; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码 2:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border-width</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">border-style</span>: solid;</span><br><span class="line"><span class="attribute">border-color</span>: red;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">50px</span> <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">20px</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081802324.png" alt=""><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081801057.png" alt="" style="zoom:;"></p><p> 代码 1 效果图 代码 2 效果图</p><h5 id="border-image"><a href="#border-image" class="headerlink" title="border-image"></a><strong>border-image</strong></h5><p>取值: 这是一个连写格式, 下面给出具体的书写格式, 由于 <font color="orange"><code>Qt 对这个属性支持不是很好, 因此不建议使用</code></font>, 下面简要介绍一下</p><p>格式:</p><p>CSS 的连写格式如下, 每一项分别代表分开写时的一个属性.</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-image</span>: border-image-source border-image-slice (fill)/ border-image-width</span><br><span class="line">/ border-image-outset border-image-repeat</span><br></pre></td></tr></tbody></table></figure><p>其中,<font color="orange"> <code>fill, border-image-width 和 border-image-outset 在 Qt 中不被支持</code></font>, 而且 Qt 只支持连写格式, 因此在 Qt 中, 我们实际的代码格式是</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-image</span>: border-image-source border-image-slice border-image-repeat</span><br></pre></td></tr></tbody></table></figure><p>下面简略说一下每项的含义:</p><blockquote><p>border-image-source: <font color="orange">图片路径,还是只支持本地路径和 Qt 资源文件路径.</font></p><p>border-image-slice: 图片切片, 单位只能是像素值, 因此数值不必带单位 px, 它最多可以指 定 4 个值,按照顺序分别代表上右下左, 最少指定 1 个值, 左省略时和右相同,下省略时和上相同, 右省略时和上相同; 它们的含义是, 距图片顶部, 右侧, 下部, 左侧分别按照指定的像素值进行切片, 将图片分成 四个角(左上,右上,右下,左下) + 四个边(上右下左) + 中间部分 = 共 9 个部分, 在 CSS 中, 如果指定了 fill, 则中间部分会覆盖元素(控件)的背景, 否则中间部分默认被省略</p><p>border-image-repeat: 最多两个值最少一个值, 第一个值表示水平方向, 第二个值表示垂直方向. 作用是指定边框图片的四条边和四个角的平铺方式,不包括中间部分, 有三种取值, 分别为 <strong>stretch</strong>(默认), <strong>round</strong>(均分平铺), <strong>repeat</strong>(平铺). stretch 表示拉伸四条边相应的切片图片,来填补边框的间隙.round 是把四个角和四条边分成均等区域然后用背景图片切好能铺满整个边框空隙, 不能多也不能少, 正好合适. repeat 是做直接复制填满空隙.</p></blockquote><p>下面是一个切片的具体示例:利用上面这张图片,来看一下 border-image 的一些效果图</p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20220508160643576.png" alt="" style="zoom:150%;"><p>效果 1:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">30px</span> solid red;</span><br><span class="line"><span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/border.png</span>) <span class="number">30</span> round;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081607846.png"></p><p>效果 2:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">30px</span> solid red;</span><br><span class="line"><span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/border.png</span>) <span class="number">30</span> stretch;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081609325.png"></p><p>效果 3:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">30px</span> solid red;</span><br><span class="line"><span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/border.png</span>) <span class="number">30</span> repeat;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081609923.png"></p><p>效果 4:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">30px</span> solid red;</span><br><span class="line"><span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/border.png</span>) <span class="number">30</span> repeat stretch;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081610885.png"></p><h5 id="格式-10"><a href="#格式-10" class="headerlink" title="格式"></a><strong>格式</strong></h5><p>border 属性的 style, color, width 可以连写也可以单独写, 并且可以分别设置四条边的边框,</p><p>下面进行详细介绍</p><h6 id="连写格式-1"><a href="#连写格式-1" class="headerlink" title="连写格式 1"></a><strong>连写格式</strong> <strong>1</strong></h6><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>: width style color;</span><br></pre></td></tr></tbody></table></figure><p>这种格式将四条边框的宽度, 风格, 颜色全部设置为一样.</p><p>例子如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">10px</span> solid red;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20220508161138157.png" alt=""><h6 id="连写格式-2"><a href="#连写格式-2" class="headerlink" title="连写格式 2"></a><strong>连写格式</strong> <strong>2</strong></h6><p>这种格式设置指定方向的边框的样式, 可以只设置一条边, 格式如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-top</span>: width style color;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border-right</span>: width style color;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border-bottom</span>: width style color;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border-left</span>: width style color;</span><br></pre></td></tr></tbody></table></figure><p>例子如下:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border-top</span>: <span class="number">10px</span> solid red;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20220508161311854.png" alt=""><p><strong>连写格式</strong> <strong>3</strong> </p><p>这种连写格式是指定一种属性, 按照上右下左四个方向进行设置边框, 格式如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-style</span>:上 右 下 左;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border-width</span>:上 右 下 左;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border-color</span>:上 右 下 左;</span><br></pre></td></tr></tbody></table></figure><p>其中, 后三个可以省略, 左省略则与右相同, 下省略则与上相同, 右省略与上相同</p><p>这里给两个示例:</p><p>示例 1:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border-style</span>: solid dashed dotted double;</span><br><span class="line"><span class="attribute">border-color</span>: red green blue purple;</span><br><span class="line"><span class="attribute">border-width</span>: <span class="number">5px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20220508161913218.png" alt=""><p>示例 2:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border-style</span>: solid dashed ;</span><br><span class="line"><span class="attribute">border-color</span>: red green blue;</span><br><span class="line"><span class="attribute">border-width</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>单写格式</strong> </p><p>单写格式指的是, 对每条边框的每个属性分别进行设置, 格式如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-top-width</span> <span class="attribute">border-top-style</span> <span class="attribute">border-top-color</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">border-right-width</span> <span class="attribute">border-right-style</span> <span class="attribute">border-right-color</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">border-bottom-width</span> <span class="attribute">border-bottom-style</span> <span class="attribute">border-bottom-color</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">border-left-width</span> <span class="attribute">border-left-style</span> <span class="attribute">border-left-color</span></span><br></pre></td></tr></tbody></table></figure><h4 id="字体属性-font"><a href="#字体属性-font" class="headerlink" title="字体属性 font"></a><strong>字体属性</strong> <strong>font</strong></h4><h5 id="font-style"><a href="#font-style" class="headerlink" title="font-style"></a><strong>font-style</strong></h5><p>作用: 设置字体风格</p><p>取值:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">normal</span>: 正常</span><br><span class="line"></span><br><span class="line">italic: 斜体</span><br><span class="line"></span><br><span class="line">oblique: 倾斜的字体</span><br></pre></td></tr></tbody></table></figure><p>关于 italic 和 oblique 的区别:</p><p>他们都是向右倾斜的文字, 大多数情况下看不出任何区别, 但是原理却不一样.</p><p>要搞清楚这个问题，首先要明白字体是怎么回事。一种字体有粗体、斜体、下划线、删除线</p><p>等诸多属性。但是并不是所有字体都做了这些，一些不常用的字体，或许就只有个正常体，如果你用 Italic，</p><p>就没有效果了,这时候就要用 Oblique.</p><p><font color="orange"><code>可以理解成 Italic 是使用文字的斜体，Oblique 是让没有斜体属性的文字倾斜！</code></font></p><h5 id="font-weight"><a href="#font-weight" class="headerlink" title="font-weight"></a><strong>font-weight</strong></h5><p>作用: 设置文字的粗细</p><p>取值:</p><p>它有两种取值, 一种是单次表示:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">normal</span>: 正常粗细</span><br><span class="line"></span><br><span class="line">bold: 加粗</span><br></pre></td></tr></tbody></table></figure><p>另一种是整数表示, 整数越大, 字体越粗</p><p>100, 200, 300, …, 900 </p><h5 id="font-size"><a href="#font-size" class="headerlink" title="font-size"></a><strong>font-size</strong></h5><p>作用: 设置字体大小</p><p>取值:</p><p>字体大小的取值是一个数值加上单位, 它的单位有 px , pt , 但一般都使用 px, 表示多少个像素, 如 20px, 表示字体的宽和高</p><p>说明:</p><p>注意，<font color="orange"><code>实际上它设置的是字体中字符框的高度；实际的字符字形可能比这些框高或矮（通常会矮）</code></font>。</p><p>各关键字对应的字体必须比一个最小关键字相应字体要高，并且要小于下一个最大关键字对应的字体。</p><h5 id="font-family"><a href="#font-family" class="headerlink" title="font-family"></a><strong>font-family</strong></h5><p>作用: 设置文字字体</p><p>取值: 各种字体名称</p><p>如果字体是中文, 尽量用双引号括起来</p><p>QSS 中 font-family 只能指定一种字体</p><h5 id="连写格式"><a href="#连写格式" class="headerlink" title="连写格式"></a><strong>连写格式</strong></h5><p>字体属性可以单写, 也可以连写, 连写格式如下:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">font</span>: style weight size family</span><br></pre></td></tr></tbody></table></figure><p>这种书写格式中的注意点:</p><blockquote><ol><li><p>style 和 weight 的位置可以交换, 并且可以省略;</p></li><li><p>size 不能被省略</p></li><li><p>size 和 family 必须写在其他两个属性的后面, 并且位置不能交换</p></li><li><p>family 可以省略, 省略后使用默认字体</p></li></ol></blockquote><p>举个例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">font</span>: normal normal <span class="number">30px</span> <span class="string">"隶书"</span>;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081631678.png"></p><h4 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a><strong>文本属性</strong></h4><h5 id="text-align"><a href="#text-align" class="headerlink" title="text-align"></a><strong>text-align</strong></h5><p>作用:设置文本的对齐方式</p><p>取值:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">top</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">bottom</span> </span><br><span class="line"></span><br><span class="line"><span class="attribute">left</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">right</span></span><br><span class="line"></span><br><span class="line">center</span><br></pre></td></tr></tbody></table></figure><p><font color="red">注意点: 支持这个属性的控件目前只有 QPushButton 和 QProgressBar.</font></p><p>格式:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">text-align</span>: 水平对齐方式(left, right, center) 垂直对齐方式(top bottom center);</span><br></pre></td></tr></tbody></table></figure><p>举个例子</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QPushButton{</span><br><span class="line"><span class="attribute">background-color</span>: pink;</span><br><span class="line"><span class="attribute">min-height</span>: <span class="number">80px</span>;</span><br><span class="line"><span class="attribute">text-align</span>: left top; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081638898.png"></p><h5 id="text-decoration"><a href="#text-decoration" class="headerlink" title="text-decoration"></a><strong>text-decoration</strong></h5><p>作用: 给文本添加装饰</p><p>取值:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">none</span>: 没有装饰</span><br><span class="line"></span><br><span class="line">underline: 下划线</span><br><span class="line"></span><br><span class="line">overline: 上划线</span><br><span class="line"></span><br><span class="line">line-through: 删除线</span><br></pre></td></tr></tbody></table></figure><p>举个例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line">    <span class="attribute">font</span>: normal normal <span class="number">30px</span> <span class="string">"微软雅黑"</span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#text_edit_1</span>{</span><br><span class="line"><span class="attribute">text-decoration</span>: none; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#text_edit_2</span>{</span><br><span class="line"><span class="attribute">text-decoration</span>: underline; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#text_edit_3</span>{</span><br><span class="line"><span class="attribute">text-decoration</span>: overline; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#text_edit_4</span>{</span><br><span class="line"><span class="attribute">text-decoration</span>: line-through; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081639340.png"></p><h4 id="padding-和-margin"><a href="#padding-和-margin" class="headerlink" title="padding 和 margin"></a><strong>padding</strong> <strong>和</strong> <strong>margin</strong></h4><p>盒模型中的 padding 和 margin 都可以连写, 也可以单独写, 它们都能完成四个方向上的边距设置, <font color="orange"><code>默认情况下都是 0.</code></font></p><p>与边框和其他连写格式一样, 如果它们连写时, 最多可以指定 4 个值, 最少指定 1 个值,指定 4 个时, 分别表示上右下左方向的边距, 省略时, 也有相同的效果, 即左省略时默认和右一样, 下省略时默认和上一样, 右省略时和上一样.</p><p>设置边距时, 数值后面必须要带像素单位, 即 px;</p><h5 id="padding"><a href="#padding" class="headerlink" title="padding"></a><strong>padding</strong></h5><p>padding 既可以连写也可以分四个方向单独设置,</p><p>格式如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">padding</span>: 上 右 下 左;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"><span class="attribute">padding-top</span>: ?px;</span><br><span class="line"></span><br><span class="line"><span class="attribute">padding-right</span>: ?px;</span><br><span class="line"></span><br><span class="line"><span class="attribute">padding-bottom</span>: ?px;</span><br><span class="line"></span><br><span class="line"><span class="attribute">padding-left</span>: ?px;</span><br></pre></td></tr></tbody></table></figure><h5 id="margin"><a href="#margin" class="headerlink" title="margin"></a><strong>margin</strong></h5><p>格式与 padding 类似, 具体如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">margin</span>: 上 右 下 左; </span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"><span class="attribute">margin</span> -<span class="attribute">top</span>: ?px;</span><br><span class="line"></span><br><span class="line"><span class="attribute">margin</span> -<span class="attribute">right</span>: ?px;</span><br><span class="line"></span><br><span class="line"><span class="attribute">margin</span> -<span class="attribute">bottom</span>: ?px;</span><br><span class="line"></span><br><span class="line"><span class="attribute">margin</span> -<span class="attribute">left</span>: ?px;</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>由于 Qt 将整个盒子看做是一个控件, 因此在布局时, 不会考虑每个盒子的垂直方向的外边距是否有合并现象等, 所以一个控件的外边距只会对自己产生影响, 不会对其他的控件产生影响.</code></font></p><p>下面看一个例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">2px</span> solid red;</span><br><span class="line"><span class="attribute">background</span>: skyblue;</span><br><span class="line"><span class="attribute">background-clip</span>: margin;</span><br><span class="line"><span class="attribute">font</span>: normal normal <span class="number">30px</span> <span class="string">"微软雅黑"</span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#text_edit_1</span>{ </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">5px</span>; </span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>; </span><br><span class="line">    <span class="attribute">text-decoration</span>: none; </span><br><span class="line">} <span class="selector-id">#text_edit_2</span>{ </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>; </span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>; </span><br><span class="line">    <span class="attribute">text-decoration</span>: underline; </span><br><span class="line">} <span class="selector-id">#text_edit_3</span>{ </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">15px</span>; </span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span>; </span><br><span class="line">    <span class="attribute">text-decoration</span>: overline; </span><br><span class="line">} <span class="selector-id">#text_edit_4</span>{ </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>; </span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>; </span><br><span class="line">    <span class="attribute">text-decoration</span>: line-through; </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081644843.png"></p><h4 id="width-与-height"><a href="#width-与-height" class="headerlink" title="width 与 height"></a><strong>width</strong> <strong>与</strong> <strong>height</strong></h4><h5 id="width-height"><a href="#width-height" class="headerlink" title="width, height"></a><strong>width, height</strong></h5><ul><li>这两个属性设置的是<font color="orange"><code>盒子内容</code></font>的宽高.</li><li>这两个属性只对子控件选择器选中的对象有效</li><li>这两个属性的取值均是像素值, 即数字加像素单位 px;</li></ul><h5 id="max-width-min-width-与-max-height-min-height"><a href="#max-width-min-width-与-max-height-min-height" class="headerlink" title="max-width min width 与 max-height min-height"></a><strong>max-width min width</strong> <strong>与</strong> <strong>max-height min-height</strong></h5><ul><li>这四个属性对所有的 widget 都有效, 用来设置盒子内容的最小或最大尺寸</li><li>当最小宽度与最大宽度相等时, 意味着给这个盒子的内容设置了一个固定宽度.</li><li>当最小高度与最大高度相等时, 意味着给这个盒子的内容设置了一个固定高度.</li></ul><p>举个例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QComboBox{ </span><br><span class="line">    <span class="attribute">background-color</span>: skyblue; </span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red; </span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>; </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>; </span><br><span class="line">    <span class="attribute">background-clip</span>: content; </span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">50px</span>; </span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">50px</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081645397.png"></p><p><strong>outline</strong> </p><p>outline （轮廓）是控件有焦点时, 绘制在边框边缘的外围,可起到突出作用,轮廓线不占据控</p><p>件, 也不一定是矩形.</p><p>它有如下属性,</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">outline</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">outline-color</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">outline-offset</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">outline-style</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">outline</span>-radius</span><br><span class="line"></span><br><span class="line"><span class="attribute">outline</span>-<span class="attribute">bottom</span>-<span class="attribute">left</span>-radius</span><br><span class="line"></span><br><span class="line"><span class="attribute">outline</span>-<span class="attribute">bottom</span>-<span class="attribute">right</span>-radius</span><br><span class="line"></span><br><span class="line"><span class="attribute">outline</span>-<span class="attribute">top</span>-<span class="attribute">left</span>-radius</span><br><span class="line"></span><br><span class="line"><span class="attribute">outline</span>-<span class="attribute">top</span>-<span class="attribute">right</span>-radius</span><br></pre></td></tr></tbody></table></figure><p>这里对这些属性不做详细介绍, 只需要知道, 当我们想在一个控件有焦点时, 不绘制轮廓,</p><p>只需要这样做,</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">outline</span>: none;</span><br></pre></td></tr></tbody></table></figure><h3 id="属性结语"><a href="#属性结语" class="headerlink" title="属性结语"></a><strong>属性结语</strong></h3><p>这一小节主要列举了一些常用的属性, 并列举了它们的用法和取值等, 还有其他一些属性并未介绍, 但很可能在开发中需要用到. 这里啰嗦一下, 这种总结性质的东西, 不可能尽善尽美罗列所有, 如果有需要, 还是要去自己查看 Qt 官方给的资料, 查阅文档搜寻有用的知识也是一种很重要的技能.</p><h2 id="Brush-类型介绍"><a href="#Brush-类型介绍" class="headerlink" title="Brush 类型介绍"></a><strong>Brush</strong> <strong>类型介绍</strong></h2><p>brush 一般用来设置颜色, 其取值有 3 种, 分别是 <font color="orange">Color</font>, <font color="orange">Gradient </font>和 <font color="orange">PaletteRole</font>, 下面简单介绍一下</p><h3 id="Color"><a href="#Color" class="headerlink" title="Color"></a><strong>Color</strong></h3><p>color 本身又支持很多格式, 列举所有格式, 如下:</p><ul><li><p>rgb(r, g, b) 每个数字表示每个通道的值, 依次分别是红绿蓝</p></li><li><p>rgba(r, g, b, a) 与 rgb 相同, a 代表 α 通道, 是一个范围 0~1 的浮点数, 表示透明度, 1 代表不透明, 0 表示全透明</p></li><li><p>hsv(h, s, v)</p></li><li><p>hsva(h, s, v, a)</p></li><li><p>#rrggbb: 16 进制表示的 rgb 值, 每个值占两位, 但如果每个通道的两位都一样, 可以简写为</p></li><li><p>#rgb, 如#66FFAA 可以简写为 #6FA, 并且大小写不敏感.</p></li><li><p>name: 常见的表示颜色的单次, 如 red, green, blue, yellow, purple 等</p><p><font color="orange"><code>常用的是 rgb, rgba, #rrggbb, name</code></font></p></li></ul><h3 id="Gradient"><a href="#Gradient" class="headerlink" title="Gradient"></a><strong>Gradient</strong></h3><p>可实现渐变效果,三种取值:</p><ul><li>qlineargradient 线性渐变</li><li>qradialgradient 径向渐变</li><li>qconicalgradient 锥形渐变</li></ul><p>它们分别对应了 Qt 的 3 个类, <font color="orange"><code>QLinearGradient</code></font>, <font color="orange"><code>QRadialGradient</code></font>, <font color="orange"><code>QConicalGradient</code></font>, 参数可以</p><p>参考它们的函数, 这里不多赘述</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{ </span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid red; </span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">qlineargradient</span>(x1:<span class="number">0</span>, y1:<span class="number">0</span>, x2:<span class="number">1</span>, y2:<span class="number">1</span>, stop:<span class="number">0</span> </span><br><span class="line"><span class="number">#ace</span>, stop: <span class="number">0.4</span> <span class="number">#f96</span>, stop:<span class="number">1</span> <span class="number">#ace</span>); </span><br><span class="line">    <span class="attribute">background-clip</span>: margin; </span><br><span class="line">    <span class="attribute">font</span>: normal normal <span class="number">30px</span> <span class="string">"微软雅黑"</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081658453.png"></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{ </span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid red; </span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">qradialgradient</span>(cx:<span class="number">0</span>, cy:<span class="number">0</span>, radius: <span class="number">1</span>, </span><br><span class="line">        fx:<span class="number">0.5</span>, fy:<span class="number">0.5</span>, stop:<span class="number">0</span> <span class="number">#ace</span>, stop:<span class="number">1</span> <span class="number">#f96</span>); </span><br><span class="line">    <span class="attribute">background-clip</span>: margin; </span><br><span class="line">    <span class="attribute">font</span>: normal normal <span class="number">30px</span> <span class="string">"微软雅黑"</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081659550.png"></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{ </span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid red; </span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">qconicalgradient</span>(cx:<span class="number">0.5</span>, cy:<span class="number">0.5</span>, angle:<span class="number">30</span>, </span><br><span class="line">                       stop:<span class="number">0</span> <span class="number">#ace</span>, stop:<span class="number">1</span> <span class="number">#f96</span>); </span><br><span class="line">    <span class="attribute">background-clip</span>: margin; </span><br><span class="line">    <span class="attribute">font</span>: normal normal <span class="number">30px</span> <span class="string">"微软雅黑"</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Qt-官方链接"><a href="#Qt-官方链接" class="headerlink" title="Qt 官方链接"></a><strong>Qt</strong> <strong>官方链接</strong></h3><p>链接地址: <a href="http://doc.qt.io/qt-5/stylesheet.html">http://doc.qt.io/qt-5/stylesheet.html</a></p><p>assistan 搜索方法: 输入 style sheet 即可, 注意两个单词之间有空格, 然后进入</p><p>Qt Style Sheets Reference 专题, 如图:</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081701854.png"></p><h3 id="加载QSS文件方法"><a href="#加载QSS文件方法" class="headerlink" title="加载QSS文件方法"></a>加载QSS文件方法</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可用过qApp对象设置整个程序的qss或者通过this指针设置单前界面的qss</span></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">qApp-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">"file:///:qss/defaultStyle.qss"</span>); <span class="comment">//通过qApp对象设置</span></span><br><span class="line">qApp-&gt;<span class="built_in">setStyleSheet</span>(<span class="built_in">QString</span>(<span class="string">"file:///%1"</span>).<span class="built_in">arg</span>(qssFileName));</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">"file:///:qss/defaultStyle.qss"</span>); <span class="comment">//通过this对象设置当前界面的qss</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setStyleSheet</span>(<span class="built_in">QString</span>(<span class="string">"file:///%1"</span>).<span class="built_in">arg</span>(qssFileName));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">QString qss;  </span><br><span class="line"><span class="function">QFile <span class="title">qssFile</span><span class="params">(<span class="string">":/qss/luffy.qss"</span>)</span></span>;  <span class="comment">//样式表文件</span></span><br><span class="line">qssFile.<span class="built_in">open</span>(QFile::ReadOnly);   </span><br><span class="line"><span class="keyword">if</span> (qssFile.<span class="built_in">isOpen</span>()) {        </span><br><span class="line">    qss = <span class="built_in">QLatin1String</span>(qssFile.<span class="built_in">readAll</span>());       </span><br><span class="line">    qApp-&gt;<span class="built_in">setStyleSheet</span>(qss);       </span><br><span class="line">    qssFile.<span class="built_in">close</span>();  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">QT入门，QT样式表</summary>
    
    
    
    <category term="QT" scheme="https://ouyujia.github.io/categories/QT/"/>
    
    <category term="QSS" scheme="https://ouyujia.github.io/categories/QT/QSS/"/>
    
    
    <category term="QT" scheme="https://ouyujia.github.io/tags/QT/"/>
    
    <category term="QSS" scheme="https://ouyujia.github.io/tags/QSS/"/>
    
    <category term="CSS" scheme="https://ouyujia.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CPU上下文</title>
    <link href="https://ouyujia.github.io/2022/05/05/CPU%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://ouyujia.github.io/2022/05/05/CPU%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2022-05-05T08:43:26.000Z</published>
    <updated>2023-04-28T05:56:04.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux 是一个多任务操作系统，它支持远大于 CPU 数量的任务同时运行。当然，这些任务实际上并不是真的在同时运行，而是因为系统在很短的时间内，将 CPU 轮流分配给它们，造成多任务同时运行的错觉。</p><p>而在每个任务运行前，CPU 都需要知道<font color="orange">任务从哪里加载</font>、又<font color="orange">从哪里开始运行</font>，任务执行的<font color="orange">状态</font>和<font color="orange">数据</font>等信息，也就是说，需要系统事先帮它设置好<font color="orange">CPU 寄存器</font>和<font color="orange">程序计数器</font>。</p><h2 id="什么是CPU上下文"><a href="#什么是CPU上下文" class="headerlink" title="什么是CPU上下文"></a>什么是CPU上下文</h2><blockquote><p>CPU 寄存器和程序计数器就是 CPU 上下文，因为它们都是 CPU 在运行任何任务前，必须的依赖环境。</p><ul><li>CPU 寄存器是 CPU 内置的容量小、但速度极快的内存。</li><li>程序计数器则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置</li></ul></blockquote><h2 id="什么是CPU上下文切换"><a href="#什么是CPU上下文切换" class="headerlink" title="什么是CPU上下文切换"></a>什么是CPU上下文切换</h2><blockquote><p>就是先把前一个任务的 CPU 上下文（也就是 CPU寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p><p>而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p></blockquote><h2 id="CPU上下文切换的类型"><a href="#CPU上下文切换的类型" class="headerlink" title="CPU上下文切换的类型"></a>CPU上下文切换的类型</h2><p>根据任务的不同，可以分为以下三种类型 - <font color="red">进程上下文切换</font> - <font color="red">线程上下文切换</font> - <font color="red">中断上下文切换</font></p><h4 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h4><p>Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中， CPU 特权等级的 Ring 0 和 Ring 3。</p><ul><li>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；</li><li>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205051655043.png" alt="image-20220505165129232"></p><p>进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。</p><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><blockquote><p>进程访问内核特定资源时将从用户态转为内核态。从用户态到内核态的转变，需要通过系统调用来完成。比如，当我们查看文件内容时，就需要多次系统调用来完成：首先调用 open()<br>打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件。</p><p>在这个过程中就发生了CPU上下文切换，整个过程是这样的：</p><ol><li>保存 CPU 寄存器里原来用户态的指令位</li><li>为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。</li><li>跳转到内核态运行内核任务。</li><li>当系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程<br>所以，<strong>一次系统调用的过程，其实是发生了两次 CPU 上下文切换</strong>。（<font color="orange">用户态-内核态  内核态-用户态</font>）</li></ol></blockquote><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这跟我们通常所说的进程上下文切换是不一样的：<font color="red"><code>进程上下文切换，是指从一个进程切换到另一个进程运行；而系统调用过程中一直是同一个进程在运行</code></font>.</p><p><font color="orange"><code>所以，系统调用过程通常称为特权模式切换，而不是上下文切换。系统调用属于同进程内的 CPU 上下文切换。但实际上，系统调用过程中，CPU 的上下文切换还是无法避免的。</code></font></p><h4 id="进程上下文切换与系统调用的区别"><a href="#进程上下文切换与系统调用的区别" class="headerlink" title="进程上下文切换与系统调用的区别"></a>进程上下文切换与系统调用的区别</h4><blockquote><p>进程是由内核来管理和调度的，<font color="orange"><code>进程的切换只能发生在内核态</code></font>。所以，<font color="greed"><strong>进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态</strong></font><br>因此，进程的上下文切换就比系统调用时多了一步：<font color="orange"><code>在保存内核态资源（当前进程的内核状态和 CPU 寄存器）之前，需要先把该进程的用户态资源（虚拟内存、栈等）保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</code></font></p></blockquote><p>如下图所示，保存上下文和恢复上下文的过程并不是“免费”的，需要内核在 CPU 上运行才能完成。</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205051707207.png" alt="image-20220505170736442"></p><h4 id="进程上下文切换潜在的性能问题"><a href="#进程上下文切换潜在的性能问题" class="headerlink" title="进程上下文切换潜在的性能问题"></a>进程上下文切换潜在的性能问题</h4><blockquote><p>根据 Tsuna 的测试报告，每次上下文切换都需要几十纳秒到数微秒的 CPU时间。</p><p>这个时间还是相当可观的，特别是在进程上下文切换次数较多的情况下，很容易导致 CPU将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，进而大大缩短了真正运行进程的时间。这也正是导致平均负载升高的一个重要因素。</p><p>另外，我们知道， Linux 通过 TLB（Translation LookasideBuffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB也需要刷新，内存的访问也会随之变慢。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。</p></blockquote><h4 id="发生进程上下文切换的场景"><a href="#发生进程上下文切换的场景" class="headerlink" title="发生进程上下文切换的场景"></a>发生进程上下文切换的场景</h4><blockquote><ol><li>为了保证所有进程可以得到公平调度，CPU时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU的进程运行。</li><li>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。</li><li>当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。</li><li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。</li><li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。</li></ol></blockquote><h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><blockquote><p>线程与进程最大的区别在于：<font color="red"><strong><code>线程是调度的基本单位，而进程则是资源拥有的基本单位</code></strong></font>。说白了，<font color="green">所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。</font></p><p>所以，对于线程和进程，我们可以这么理解： </p><ul><li>当进程只有一个线程时，可以认为进程就等于线程。 </li><li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。 </li><li>另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的</li></ul></blockquote><h4 id="发生线程上下文切换的场景"><a href="#发生线程上下文切换的场景" class="headerlink" title="发生线程上下文切换的场景"></a>发生线程上下文切换的场景</h4><blockquote><ol><li>前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。</li><li>前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据</li></ol></blockquote><h4 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h4><blockquote><p>为了快速响应硬件的事件，**<font color="orange"><code>中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件</code></font>。**而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。</p><p>**<font color="orange"><code>跟进程上下文不同，中断上下文切换并不涉及到进程的用户态</code></font>**。所以，即便中断过程打断了一个正处在用户态的进程，<font color="orange"><code>也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源(中断上下文切换不会覆盖这个进程的虚拟内存、全局变量等用户态资源)。</code></font>中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括CPU 寄存器、内核堆栈、硬件中断参数等。</p><p>**<font color="orange"><code>对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生</code></font>**。同样道理，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。</p><p>另外，跟进程上下文切换一样，中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的<br>CPU，甚至严重降低系统的整体性能。所以，当你发现中断次数过多时，就需要注意去排查它是否会给你的系统带来严重的性能问题。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Linux 是一个多任务操作系统，它支持远大于 CPU 数量的任务同时运行。当然，这些任务实际上并不是真的在同时运行，而是因为系统在很短的时</summary>
      
    
    
    
    <category term="操作系统" scheme="https://ouyujia.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="CPU上下文" scheme="https://ouyujia.github.io/tags/CPU%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
    <category term="多进程hexo" scheme="https://ouyujia.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8Bhexo/"/>
    
    <category term="多线程" scheme="https://ouyujia.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>回调函数</title>
    <link href="https://ouyujia.github.io/2022/05/05/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <id>https://ouyujia.github.io/2022/05/05/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</id>
    <published>2022-05-05T06:54:49.000Z</published>
    <updated>2023-04-28T05:56:04.362Z</updated>
    
    <content type="html"><![CDATA[<p><font color="orange"><code>回调函数</code></font>就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p><h3 id="基于C语言的回调函数来实现一个回调的过程"><a href="#基于C语言的回调函数来实现一个回调的过程" class="headerlink" title="基于Ｃ语言的回调函数来实现一个回调的过程"></a>基于Ｃ语言的回调函数来实现一个回调的过程</h3><h4 id="回调函数机制："><a href="#回调函数机制：" class="headerlink" title="回调函数机制："></a>回调函数机制：</h4><p>1、定义一个函数（普通函数即可）；<br>2、将此函数的地址注册给调用者；<br>3、特定的事件或条件发生时，调用者使用函数指针调用回调函数。</p><h4 id="回调函数的参数传递"><a href="#回调函数的参数传递" class="headerlink" title="回调函数的参数传递"></a>回调函数的参数传递</h4><p>回调函数的参数定义和普通函数是一致的（回调函数一般就是普通函数）。</p><p><font color="red"><code>一般而言回调函数的参数通过调用该回调函数（调用者）的参数传入</code></font>。</p><ol><li><p>参数通过<font color="orange"><code>调用者</code></font>传递</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*callback)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, intc, callback p)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> (*p)(a,b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *args[])</span></span>{</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">Add</span>(<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，可以看到，我们定义了一个callbak的函数指针，参数为两个int，返回值为int，通过调用函数地址来进行简单的相加运算。<font color="orange"><code>回调函数add中的参数是通过调用者Add传递的（Add的前两个参数都是为回调函数add服务的，当然调用者Add可以有不用为回调函数add传递参数的有实际作用的其他参数，本例中的c）</code></font></p></li><li><p>参数由<font color="orange"><code>调用者</code></font>内部定义</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*callback)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(callback p)</span></span>{</span><br><span class="line">    <span class="type">int</span> a{<span class="number">5</span>}, b{<span class="number">6</span>};</span><br><span class="line">    <span class="keyword">return</span> (*p)(a,b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *args[])</span></span>{</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">Add</span>(add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，可以看到，我们定义了一个callbak的函数指针，参数为两个int，返回值为int，通过调用函数地址来进行简单的相加运算。<font color="orange"><code>回调函数add中的参数是用者Add内部定义的，没有通过形参从外部获取。</code></font></p></li><li><p>回调函数的输出参数</p><p>前面两个示例都是输入参数，<font color="orange"><code>回调函数当然也可以有输出参数来返回调用者需要的信息</code></font>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*callback)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">addInfo</span>{</span><br><span class="line">    <span class="type">int</span> add1;</span><br><span class="line">    <span class="type">int</span> add2;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, callback p)</span></span>{</span><br><span class="line">    <span class="comment">//定义一个对象作为输出参数</span></span><br><span class="line">    addInfo info;</span><br><span class="line">    <span class="comment">//通过回调函数获取需要的输出信息</span></span><br><span class="line">    (*p)(a, b, info);</span><br><span class="line">    <span class="comment">//使用回去的输出参数内容</span></span><br><span class="line">    <span class="keyword">return</span> info.sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">info <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b, addInfo&amp; info)</span></span>{</span><br><span class="line">    info.add1 = a;</span><br><span class="line">    info.add2 = b;</span><br><span class="line">    info.sum = a + b;</span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *args[])</span></span>{</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">Add</span>(<span class="number">4</span>, <span class="number">2</span>, add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，可以看到，我们定义了一个callbak的函数指针，参数为两个int，返回值为int，通过调用函数地址来进行简单的相加运算。<font color="orange"><code>回调函数add中的参数既有输入参数也有输出给调用者Add的输出参数。</code></font></p></li></ol><h3 id="基于C＋＋面向对象过程的代码"><a href="#基于C＋＋面向对象过程的代码" class="headerlink" title="基于Ｃ＋＋面向对象过程的代码"></a>基于Ｃ＋＋面向对象过程的代码</h3><p>举个例子：</p><p>　财务处是负责对公司财务状况和每个月的开销进行汇总，老板只会去看每个月的报表。</p><p>​那么在这个当中，老板不会去关心，财务整个汇总的过程，他只会去关心结果，那么，如果从面向对象的方法去理解的话，老板是一个对象．财务部是一个对象，当老板想看报表的时候，会跟财务打个招呼，等财务部汇总完了．然后将报表再去提交给老板，那么问题来了，而两个类之间实现通信的就是接口回调，从财务类的中，将结果回调到对象中．<font color="green"><strong><code>这种实现是通过接口自动完成的</code></strong></font><br>　<br>　如果用Ｃ语言的面向过程去理解的话，那么老板想看报表可以理解为一个函数，而财务处计算过程可以看成一个回调函数，如果老板想看报表的话，可以直接通过财务处回调函数的返回结果来查看．这中主要是依赖于函数指针的形式来实现。</p><hr><p>为了对比先基于C实现回调</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> *财务的统计状况函数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">finance_result</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> *老板想看财务报表</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">boss_read_finance</span><span class="params">(<span class="type">int</span> *array,<span class="type">int</span> n,<span class="type">int</span> (*fp)(<span class="type">int</span>*,<span class="type">int</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span>{</span><br><span class="line">  <span class="comment">//定义一个数组数据</span></span><br><span class="line">  <span class="type">int</span> array[<span class="number">10</span>] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>};</span><br><span class="line">  <span class="comment">//因为Ｃ语言中函数名也是地址，因此对于形参数是函数指针的话，这个时候直接将地址传进去就可以了；</span></span><br><span class="line">  <span class="comment">//注意：函数指针是指向函数的地址,对于fp是地址，那么调用的时候固然需要(*fp)</span></span><br><span class="line">  <span class="comment">//也可以这样写：</span></span><br><span class="line">  <span class="comment">//int (*fp)(int *a,int n);</span></span><br><span class="line">  <span class="comment">//fp = finance_result;</span></span><br><span class="line">  <span class="comment">//boss_read_finance(array,10,finance_result);</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">boss_read_finance</span>(array,<span class="number">10</span>,finance_result);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> *老板查看财务状况的实现，参数中有一个函数指针，</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">boss_read_finance</span><span class="params">(<span class="type">int</span>* array,<span class="type">int</span> n,<span class="type">int</span> (*fp)(<span class="type">int</span>* a,<span class="type">int</span> n))</span></span>{</span><br><span class="line">  <span class="comment">//对于老板来说，他是不需要去了解财务部的具体实现的过程，只要结果就行了</span></span><br><span class="line">  <span class="comment">//这就有助于我们对函数封装</span></span><br><span class="line">  <span class="type">int</span> result = (*fp)(array,n);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"caculate result:%d\n"</span>,result);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* **</span></span><br><span class="line"><span class="comment"> *财务计算报表的具体实现</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">finance_result</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span> n)</span></span>{</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i =  <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++){</span><br><span class="line">    result += *(a+i);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>基于C++面相对象实现代码</p><p>finance.h</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __FINANCE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FINANCE_H__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> zzf{</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::std;</span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> *定义一个ｃａｌｌｂａｃｋ的接口</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallBack</span>{</span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setFinanceResult</span><span class="params">(<span class="type">int</span> result)</span>  <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> *财务：</span></span><br><span class="line"><span class="comment"> 专门用于计算结果的</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Finance</span>{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Finance</span>(CallBack* mCallBack2):<span class="built_in">mCallBack</span>(mCallBack2){</span><br><span class="line">      cout &lt;&lt; <span class="string">"finance constructor"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">Finance</span>(){</span><br><span class="line">      cout &lt;&lt; <span class="string">"finance destructor"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">caculateFinance</span><span class="params">(<span class="type">int</span> * a,<span class="type">int</span> n)</span></span>{</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ;i &lt; n;i++){</span><br><span class="line">      result += *(a + i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(mCallBack != <span class="literal">NULL</span>){</span><br><span class="line">      cout &lt;&lt;<span class="string">"result:"</span>&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">       mCallBack-&gt;<span class="built_in">setFinanceResult</span>(result);</span><br><span class="line">    }</span><br><span class="line">  }  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">     CallBack* mCallBack;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> *老板，实现接口ｃａｌｌｂａｃｋ</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boss</span>:<span class="keyword">public</span> CallBack{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">Boss</span>(){</span><br><span class="line">       <span class="comment">//将接口实例化后，传递给Ｆｉｎａｎｃｅ</span></span><br><span class="line">       mFinace = <span class="keyword">new</span> <span class="built_in">Finance</span>(<span class="keyword">this</span>);</span><br><span class="line">      cout &lt;&lt; <span class="string">"boss constructor"</span> &lt;&lt; endl;</span><br><span class="line">     }</span><br><span class="line">     ~<span class="built_in">Boss</span>(){</span><br><span class="line">       <span class="keyword">delete</span> mFinace;</span><br><span class="line">       cout &lt;&lt; <span class="string">"boss destructor"</span> &lt;&lt; endl;</span><br><span class="line">     }</span><br><span class="line">     <span class="comment">//查看财务的函数</span></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">readFianace</span><span class="params">(<span class="type">int</span> *array ,<span class="type">int</span> n)</span></span>{</span><br><span class="line">       cout &lt;&lt; <span class="string">"boss readFianace"</span>&lt;&lt; endl;</span><br><span class="line">       mFinace -&gt; <span class="built_in">caculateFinance</span>(array,n);</span><br><span class="line">     }</span><br><span class="line">    <span class="comment">//实现后的回调函数，这个函数就是用来接收回调的值的</span></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">setFinanceResult</span><span class="params">(<span class="type">int</span> result)</span> <span class="type">const</span></span>{</span><br><span class="line">       cout &lt;&lt; <span class="string">"caculate result:"</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">     }</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">     Finance *mFinace;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>finance.cpp</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;finance.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::zzf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv [])</span></span>{</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> array[<span class="number">10</span>] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>};</span><br><span class="line"></span><br><span class="line">  Boss boss;</span><br><span class="line"></span><br><span class="line">  boss.<span class="built_in">readFianace</span>(array,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>其实这个案例能够让我们对回调有更加深刻的认识：</p><ol><li>老板想查看财务(调用自己函数,函数在ｂｏｓｓ内)</li><li>通知财务，我要查看报表(进行计算的过程，函数在ｆｉｎａｎｃｅ内部)</li><li>财务算好之后，返回给老板(回调的函数在ｂｏｓｓ内部)也就是回调就是把不需要自己处理的东西放到别的类去，然后等其处理完毕之后，再返回给调用的类．</li></ol><h4 id="面向对象回调函数机制"><a href="#面向对象回调函数机制" class="headerlink" title="面向对象回调函数机制"></a>面向对象回调函数机制</h4><ol><li>定义一个回调接口</li><li>定义一个调用类，继承接口类去实现这个接口，重写方法</li><li>被调用者(任务具体实现类)将接口做为参数传递进去，并且在某个时刻进行出发</li><li>调用者在调用的时候去实例化这个回调接口(如上述案例中因为已经实现了接口，所以将类本身对应的对象作为参数传递进去)</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;font color=&quot;orange&quot;&gt;&lt;code&gt;回调函数&lt;/code&gt;&lt;/font&gt;就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而</summary>
      
    
    
    
    <category term="C++" scheme="https://ouyujia.github.io/categories/C/"/>
    
    <category term="指针" scheme="https://ouyujia.github.io/categories/C/%E6%8C%87%E9%92%88/"/>
    
    
    <category term="C++" scheme="https://ouyujia.github.io/tags/C/"/>
    
    <category term="回调函数" scheme="https://ouyujia.github.io/tags/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>函数指针</title>
    <link href="https://ouyujia.github.io/2022/05/05/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    <id>https://ouyujia.github.io/2022/05/05/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</id>
    <published>2022-05-05T06:35:26.000Z</published>
    <updated>2023-04-28T05:56:04.361Z</updated>
    
    <content type="html"><![CDATA[<h3 id="指向函数的指针–函数指针"><a href="#指向函数的指针–函数指针" class="headerlink" title="指向函数的指针–函数指针"></a>指向函数的指针–函数指针</h3><p> 函数具有可赋值给指针的物理内存地址，一个函数的<font color="orange"><code>函数名</code></font>就是一个指针，它指向函数的代码。<font color="orange"><code>一个函数的地址是该函数的进入点，也是调用函数的地址</code></font>。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数。</p><blockquote><p>不带括号和变量列表的函数名，这可以表示函数的地址，正如不带下标的数组名可以表示数组的首地址。</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">定义形式：</span><br><span class="line">类型 （*指针变量名）（参数列表）；</span><br><span class="line">例如：</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> i + j;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">int</span> (*p)(<span class="type">int</span> i,<span class="type">int</span> j);</span><br><span class="line">p = add; <span class="comment">// p = &amp;add;</span></span><br><span class="line"></span><br><span class="line">使用<span class="keyword">typedef</span>定义函数指针类型别名：</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*funPtr)</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>; <span class="comment">//定义别名</span></span><br><span class="line">funPtr p; <span class="comment">//实例函数指针对象</span></span><br><span class="line">p = add;</span><br><span class="line">使用<span class="keyword">using</span>定义函数指针类型别名：</span><br><span class="line">    <span class="keyword">using</span> funPtr = <span class="built_in">int</span> (*)(<span class="type">int</span> i, <span class="type">int</span> j); <span class="comment">//定义别名</span></span><br><span class="line">funPtr p; <span class="comment">//实例函数指针对象</span></span><br><span class="line">p = add;</span><br><span class="line"><span class="comment">//3个p是同一个类型变量</span></span><br><span class="line"><span class="built_in">p</span>(<span class="number">5</span> , <span class="number">6</span>); <span class="comment">//通过函数指针调用函数</span></span><br></pre></td></tr></tbody></table></figure><p> p是一个指针，它指向一个函数，该函数有2个整形参数，返回类型为int。p首先和*结合，表明p是一个指针。然后再与（）结合，表明它指向的是一个函数。指向函数的指针也称为函数指针。</p><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GET_MAX 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  GET_MIN 1</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_max</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> i&gt;j?i:j;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_min</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> i&gt;j?j:i;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//这里定义了一个函数指针，就可以根据传入的flag，灵活地决定其是指向求大数或求小数的函数</span></span><br><span class="line"><span class="comment">//便于方便灵活地调用各类函数</span></span><br><span class="line"><span class="built_in">int</span> (*p)(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(flag == GET_MAX)</span><br><span class="line">p = get_max;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p = get_min;</span><br><span class="line"> </span><br><span class="line">ret = <span class="built_in">p</span>(i,j);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> i = <span class="number">5</span>,j = <span class="number">10</span>,ret;</span><br><span class="line"> </span><br><span class="line">ret = <span class="built_in">compare</span>(i,j,GET_MAX);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The MAX is %d\n"</span>,ret);</span><br><span class="line"> </span><br><span class="line">ret = <span class="built_in">compare</span>(i,j,GET_MIN);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The MIN is %d\n"</span>,ret);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">char</span> *a,<span class="type">char</span> *b,<span class="type">int</span> (*cmp)(<span class="type">const</span> <span class="type">char</span> *,<span class="type">const</span> <span class="type">char</span> *))</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> s1[<span class="number">80</span>],s2[<span class="number">80</span>];</span><br><span class="line">    <span class="built_in">int</span> (*p)(<span class="type">const</span> <span class="type">char</span> *,<span class="type">const</span> <span class="type">char</span> *);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将库函数strcmp的地址赋值给函数指针p</span></span><br><span class="line">    p=strcmp;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter two strings.\n"</span>);</span><br><span class="line">    <span class="built_in">gets</span>(s1);</span><br><span class="line">    <span class="built_in">gets</span>(s2);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">check</span>(s1,s2,p);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">char</span> *a,<span class="type">char</span> *b,<span class="type">int</span> (*cmp)(<span class="type">const</span> <span class="type">char</span> *,<span class="type">const</span> <span class="type">char</span> *))</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Testing for equality.\n"</span>);</span><br><span class="line"><span class="comment">//表达式(*cmp)(a,b)调用strcmp，由cmp指向库函数strcmp()，由a和b作调用strcmp()的参数。</span></span><br><span class="line"><span class="comment">//调用时，与声明的情况类似，必须在*cmp周围使用一对括号，使编译程序正确操作，</span></span><br><span class="line"><span class="comment">//同时这也是一种良好的编码风格，指示函数是通过指针调用的，而不是函数名。</span></span><br><span class="line">    <span class="keyword">if</span>((*cmp)(a,b)==<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Equal\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not Equal\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//check()函数的第3个函数是函数指针，就可以根据具体情况传入不同的处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">char</span> *a,<span class="type">char</span> *b,<span class="type">int</span> (*cmp)(<span class="type">const</span> <span class="type">char</span> *,<span class="type">const</span> <span class="type">char</span> *))</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//自定义的比较两个字符串的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compvalues</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a,<span class="type">const</span> <span class="type">char</span> *b)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> s1[<span class="number">80</span>],s2[<span class="number">80</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter two values or two strings.\n"</span>);</span><br><span class="line">    <span class="built_in">gets</span>(s1);</span><br><span class="line">    <span class="built_in">gets</span>(s2);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//如果是数字，则用函数指针传入数字比较函数进行处理</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isdigit</span>(*s1)){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Testing values for equality.\n"</span>);</span><br><span class="line">        <span class="built_in">check</span>(s1,s2,compvalues);</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//如果是字符串，则用函数指针传入库函数strcmp进行处理</span></span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Testing strings for equality.\n"</span>);</span><br><span class="line">        <span class="built_in">check</span>(s1,s2,strcmp);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">char</span> *a,<span class="type">char</span> *b,<span class="type">int</span> (*cmp)(<span class="type">const</span> <span class="type">char</span> *,<span class="type">const</span> <span class="type">char</span> *))</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>((*cmp)(a,b)==<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Equal.\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not Equal.\n"</span>);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compvalues</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a,<span class="type">const</span> <span class="type">char</span> *b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">atoi</span>(a)==<span class="built_in">atoi</span>(b))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意：</p><p>函数指针本质是一个指针可以执行解引用操作。函数指针多用于回调使用。</p></blockquote>]]></content>
    
    
    <summary type="html">函数指针解析</summary>
    
    
    
    <category term="C++" scheme="https://ouyujia.github.io/categories/C/"/>
    
    <category term="指针" scheme="https://ouyujia.github.io/categories/C/%E6%8C%87%E9%92%88/"/>
    
    
    <category term="C++" scheme="https://ouyujia.github.io/tags/C/"/>
    
    <category term="指针" scheme="https://ouyujia.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>动态库常用关键字</title>
    <link href="https://ouyujia.github.io/2022/05/05/%E5%8A%A8%E6%80%81%E5%BA%93%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://ouyujia.github.io/2022/05/05/%E5%8A%A8%E6%80%81%E5%BA%93%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2022-05-05T05:51:26.000Z</published>
    <updated>2023-04-28T05:56:04.362Z</updated>
    
    <content type="html"><![CDATA[<h3 id="declspec-dllexport-与-declspec-dllimport"><a href="#declspec-dllexport-与-declspec-dllimport" class="headerlink" title="__declspec(dllexport)与__declspec(dllimport)"></a>__declspec(dllexport)与__declspec(dllimport)</h3><p>__declspec是Microsoft VC中专用的关键字，它配合着一些属性可以对标准C/C++进行扩充。__declspec关键字应该出现在声明的前面。</p><p>__declspec(dllexport)用于Windows中的动态库中，声明导出函数、类、对象等供外面调用，省略给出.def文件。即将函数、类等声明为导出函数，供其它程序调用，作为动态库的对外接口函数、类等。</p><p>.def文件(模块定义文件)是包含一个或多个描述各种DLL属性的Module语句的文本文件。.def文件或__declspec(dllexport)都是将公共符号导入到应用程序或从DLL导出函数。如果不提供__declspec(dllexport)导出DLL函数，则DLL需要提供.def文件。</p><p>__declspec(dllimport)用于Windows中，从别的动态库中声明导入函数、类、对象等供本动态库或exe文件使用。当你需要使用DLL中的函数时，往往不需要显示地导入函数，编译器可自动完成。不使用__declspec(dllimport)也能正确编译代码，但使用__declspec(dllimport)使编译器可以生成更好的代码。编译器之所以能够生成更好的代码，是因为它可以确定函数是否存在于DLL中，这使得编译器可以生成跳过间接寻址级别的代码，而这些代码通常会出现在跨DLL边界的函数调用中。声明一个导入函数，是说这个函数是从别的DLL导入。一般用于使用某个DLL的exe中。</p><p>他们都是DLL内的关键字，即<font color="orange"><code>导出</code></font>与<font color="orange"><code>导入</code></font>。他们是将DLL内部的类与函数以及数据导出与导入时使用的。</p><p> <font color="orange"><code>dllexport</code></font>是在这些类、函数以及数据的<font color="orange"><code>申明</code></font>的时候使用。用他表明这些东西可以被外部函数使用，<font color="red"><code>即（dllexport）是把 DLL中的相关代码（类，函数，数据）暴露出来为其他应用程序使用。</code></font><font color="red"><code>使用了（dllexport）关</code>键字，相当于声明了紧接在（dllexport）关键字后面的相关内容是可以为其他程序使用的</font>。</p><p> <font color="orange"><code>dllimport</code></font>是在<font color="orange"><code>外部程序</code></font>需要使用DLL内相关内容时使用的关键字。当一个外部程序要使用DLL 内部代码（类，函数，全局变量）时，只需要在程序内部使用（dllimport）关键字声明需要使用的代码就可以了，<font color="red"><code>即（dllimport）关键字是在外部程序需要使用DLL内部相关内容的时候才使用。（dllimport）作用是把DLL中的相关代码插入到应用程序中。</code></font></p><p> __declspec(dllexport)与__declspec(dllimport)是相互呼应，只有在DLL内部用dllexport作了声明，才能在外部函数中用dllimport导入相关代码。</p><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><p>  在为方便使用，我们经常在代码中定义宏<font color="orange"><code>DLL_EXPORT</code></font>，此宏用在需要导出的类和函数前，而此宏我们定义如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DLL_EXPORTS </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIMPLE_CLASS_EXPORT __declspec(dllexport) </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIMPLE_CLASS_EXPORT __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>作为动态库，在需要导出的类或函数前必须使用关键字<font color="orange">__declspec(dllexport)</font>声明，因此动态库需要定义宏<font color="orange">DLL_EXPORTS</font>(使用Vistualstudio建立动态库工程时，此宏已经定义好)。</p><p>  应用程序需要使用关键字<font color="orange">__declspec(dllimport)</font>，因此不能定义宏<font color="orange">DLL_EXPORTS</font>。</p><h3 id="可以省略dllimport"><a href="#可以省略dllimport" class="headerlink" title="可以省略dllimport???"></a>可以省略dllimport???</h3><p> 但MSDN文档里面，对于 __declspec(dllimport)的说明让人感觉有点奇怪，先来看看MSDN里面是怎么说的：</p><p>​     不使用 __declspec(dllimport)也能正确编译代码，但使用 __declspec(dllimport) 使编译器可以生成更好的代码。编译器之所以能够生成更好的代码，是因为它可以确定函数是否存在于 DLL 中，这使得编译器可以生成跳过间接寻址级别的代码，而这些代码通常会出现在跨DLL 边界的函数调用中。但是，必须使用 __declspec(dllimport) 才能导入 DLL 中使用的变量。</p><p>   使用__declspec(dllimport)可以生成更好的代码，这点好理解，但必须使用它才能导出dll中的变量，真的是如此吗？那我们就来测试一下:</p><p>   建立动态库，由SimpleClass.h和SimpleClass.cpp组成，SimpleClass.h的代码实现如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//file  SimpleClass.h</span><br><span class="line">#ifndef _SIMPLE_CLASS_H_</span><br><span class="line">#define _SIMPLE_CLASS_H_</span><br><span class="line"> </span><br><span class="line">#ifdef DLL_EXPORTS</span><br><span class="line">    #define SIMPLE_CLASS_EXPORT__declspec(dllexport)</span><br><span class="line">#else</span><br><span class="line">    #define SIMPLE_CLASS_EXPORT</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">extern int SIMPLE_CLASS_EXPORT g_Vaule; //全局变量</span><br><span class="line"> </span><br><span class="line">class SIMPLE_CLASS_EXPORT CSimpleClass</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">    CSimpleClass(void);</span><br><span class="line">    ~CSimpleClass(void);</span><br><span class="line">     int GetVale(void)const;</span><br><span class="line">};</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure><p>SimpleClass.cpp代码实现如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleClass.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"SimpleClass.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> g_Vaule = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">CSimpleClass::<span class="built_in">CSimpleClass</span>(<span class="type">void</span>)</span><br><span class="line">    :<span class="built_in">m_iValue</span>(<span class="number">100</span>)</span><br><span class="line">{}</span><br><span class="line">CSimpleClass::~<span class="built_in">CSimpleClass</span>(<span class="type">void</span>)</span><br><span class="line">{}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CSimpleClass::GetVale</span><span class="params">(<span class="type">void</span>)</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> g_Vaule;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果应用程序中不直接使用g_Vaule，能顺利编译通过，且调用函数GetVale能正确返回100.</p><p>  但如果在应用程序中直接使用g_Vaule,编译错误提示如下：</p><p>1&gt;main.obj : error LNK2001: unresolvedexternal symbol “int g_Vaule” (?g_Vaule@@3HA) </p><hr><p>如果将SimpleClass.h中的宏定义修改为下面值，成功编译：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DLL_EXPORTS</span></span><br><span class="line">      <span class="meta">#<span class="keyword">define</span> SIMPLE_CLASS_EXPORT __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="meta">#<span class="keyword">define</span> SIMPLE_CLASS_EXPORT __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><font color="orange"><strong>总结如下：对于动态库本身必须使用关键字__declspec(dllexport)，对于应用程序，如果不使用动态库导出的变量，不使用关键字__declspec(dllimport)也可以保证动态库的正常使用，但实际使用中，还是建议应用程序使用关键字__declspec(dllimport)，具体原因，还是上面MSDN的那段话。</strong></font></p></blockquote><h3 id="动态库与静态库并存"><a href="#动态库与静态库并存" class="headerlink" title="动态库与静态库并存"></a>动态库与静态库并存</h3><p>另外，有时我们的程序需要同时提供动态库和静态库库，且都使用一个头文件，为了解决关键字的使用冲突，建议使用如下的宏定义：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifdefined DLL_EXPORTS</span></span><br><span class="line">    <span class="meta">#ifdefined INSIDE_DLL</span></span><br><span class="line">         <span class="meta">#<span class="keyword">define</span> SIMPLE_CLASS_EXPORT__declspec(dllexport)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> SIMPLE_CLASS_EXPORT__declspec(dllimport)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="meta">#<span class="keyword">define</span> SIMPLE_CLASS_EXPORT</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>对于动态库本身，需要定义宏DLL_EXPORTS和INSIDE_DLL 使用动态库的应用程序定义宏DLL_EXPORTS</p><p>对于静态库，不需要定义DLL_EXPORTS，当然静态库的应用程序也不需要定义。</p><p>如此定义，就可以让动态库和静态库的导出都使用同一份头文件。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下是测试代码：新建一个动态库工程Library，然后在CppBaseTest工程中调用Library的接口：</p><p>library.hpp：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// library.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FBC_LIBRARY_LIBRARY_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FBC_LIBRARY_LIBRARY_HPP_</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// reference: http://geoffair.net/ms/declspec.htm</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> FBC_STATIC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FBC_API</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined FBC_EXPORT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FBC_API __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FBC_API __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">FBC_API <span class="type">int</span> <span class="title">library_add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line">FBC_API <span class="type">int</span> value;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FBC_API</span> Simple {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Simple</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(T a, T b)</span></span>;</span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T a, b;</span><br><span class="line">};</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// FBC_LIBRARY_LIBRARY_HPP_</span></span></span><br></pre></td></tr></tbody></table></figure><p>library.cpp:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"library.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">FBC_API <span class="type">int</span> <span class="title">library_add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">value = <span class="number">11</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">"File: %s, Function: %s, Line: %d\n"</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"><span class="keyword">return</span> (a+b);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Simple&lt;T&gt;::<span class="built_in">Init</span>(T a, T b)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T Simple&lt;T&gt;::<span class="built_in">Add</span>() <span class="type">const</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">"File: %s, Function: %s, Line: %d\n"</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"><span class="keyword">return</span> (a + b);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Simple</span>&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Simple</span>&lt;std::string&gt;;</span><br></pre></td></tr></tbody></table></figure><p>test_library.hpp:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FBC_CPPBASE_TEST_TEST_LIBRARY_HPP_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FBC_CPPBASE_TEST_TEST_LIBRARY_HPP_</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;library.hpp&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> test_library_ {</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">__declspec(dllimport) <span class="function"><span class="type">int</span> <span class="title">library_add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>; <span class="comment">//应用程序中使用dll中的方法可变量</span></span><br><span class="line">__declspec(dllimport) <span class="type">int</span> value;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_library_1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_library_2</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">} <span class="comment">// namespace test_library_</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// FBC_CPPBASE_TEST_TEST_LIBRARY_HPP_</span></span></span><br></pre></td></tr></tbody></table></figure><p>test_library.cpp:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"test_library.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;library.hpp&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> test_library_ {</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_library_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> a{ <span class="number">4</span> }, b{ <span class="number">5</span> }, c{ <span class="number">0</span> };</span><br><span class="line"> </span><br><span class="line">c = <span class="built_in">library_add</span>(a, b);</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">"%d + %d = %d\n"</span>, a, b, c);</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">"value: %d\n"</span>, value);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_library_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Simple&lt;<span class="type">int</span>&gt; simple1;</span><br><span class="line"><span class="type">int</span> a{ <span class="number">4</span> }, b{ <span class="number">5</span> }, c{ <span class="number">0</span> };</span><br><span class="line"> </span><br><span class="line">simple1.<span class="built_in">Init</span>(a, b);</span><br><span class="line">c = simple1.<span class="built_in">Add</span>();</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">"%d + %d = %d\n"</span>, a, b, c);</span><br><span class="line"> </span><br><span class="line">Simple&lt;std::string&gt; simple2;</span><br><span class="line">std::string str1{ <span class="string">"csdn blog: "</span> }, str2{ <span class="string">"http://blog.csdn.net/fengbingchun"</span> }, str3;</span><br><span class="line"> </span><br><span class="line">simple2.<span class="built_in">Init</span>(str1, str2);</span><br><span class="line">str3 = simple2.<span class="built_in">Add</span>();</span><br><span class="line"><span class="built_in">fprintf</span>(stdout, <span class="string">"contents: %s\n"</span>, str3.<span class="built_in">c_str</span>());</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">} <span class="comment">// namespace test_library_</span></span><br></pre></td></tr></tbody></table></figure><h3 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MVYQZ_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MVYQZ_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MV_EXP_API __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WINAPI __stdcall</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MV_EXP_API _EXPORTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MV_EXP_API __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">//MV_EXP_API</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MV_EXP_API __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//MV_EXP_API</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// _MSC_VER</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WINAPI</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MV_EXP_API</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _MSC_VER</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">IrisInfo</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> x1; </span><br><span class="line"><span class="type">int</span> y1;</span><br><span class="line"><span class="type">int</span> width1;</span><br><span class="line"><span class="type">int</span> height1;</span><br><span class="line"><span class="type">int</span> integrity1; <span class="comment">//完整度</span></span><br><span class="line"><span class="type">int</span>brightness1; <span class="comment">//亮度</span></span><br><span class="line"><span class="type">int</span>clarity1;<span class="comment">//清晰度</span></span><br><span class="line"><span class="type">int</span>gray_rate1; <span class="comment">//灰度比</span></span><br><span class="line"><span class="type">int</span>avg_score1; <span class="comment">//平均分数</span></span><br><span class="line">std::vector&lt;<span class="type">float</span>&gt; vec1;</span><br><span class="line"><span class="type">int</span> x2;</span><br><span class="line"><span class="type">int</span> y2;</span><br><span class="line"><span class="type">int</span> width2;</span><br><span class="line"><span class="type">int</span> height2;</span><br><span class="line"><span class="type">int</span> integrity2;</span><br><span class="line"><span class="type">int</span>brightness2;</span><br><span class="line"><span class="type">int</span>clarity2;</span><br><span class="line"><span class="type">int</span>gray_rate2;</span><br><span class="line"><span class="type">int</span>avg_score2;</span><br><span class="line">std::vector&lt;<span class="type">float</span>&gt; vec2;</span><br><span class="line">}IrisInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*功能：初始化模型</span></span><br><span class="line"><span class="comment">*参数modelPath：模型文件的文件夹路径</span></span><br><span class="line"><span class="comment">*返回值：1 -- 成功， 0 -- 失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">MV_EXP_API <span class="type">int</span>  __stdcall <span class="title">Init</span><span class="params">(<span class="type">char</span>* modelPath)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*功能：反初始化</span></span><br><span class="line"><span class="comment">*参数</span></span><br><span class="line"><span class="comment">*返回值：1 -- 成功， 0 -- 失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">MV_EXP_API <span class="type">int</span>  __stdcall <span class="title">UnInit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*CallbackFun 指向函数的指针类型</span></span><br><span class="line"><span class="comment">*info        回调参数，IrisInfo结构体</span></span><br><span class="line"><span class="comment">*contex      回调上下文，在C中一般传入nullptr，在C++中可传入对象指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*CallbackFun)</span><span class="params">(IrisInfo info, <span class="type">void</span>* contex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*功能：计算虹膜分数</span></span><br><span class="line"><span class="comment">*参数imgData：图片的char*类型</span></span><br><span class="line"><span class="comment">*参数length：图片转成char*长度</span></span><br><span class="line"><span class="comment">*参数IrisData：返回两只眼睛信息的回调函数</span></span><br><span class="line"><span class="comment">*返回值：0 -- 两只眼睛的检测结果，-1 -- 图片为空</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">MV_EXP_API <span class="type">int</span> __stdcall <span class="title">EvaluateScore</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* imgData, <span class="type">int</span> length, CallbackFun IrisData, <span class="type">void</span>* contex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">MV_EXP_API <span class="type">float</span> __stdcall <span class="title">SimilarityScore</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">float</span>&gt;&amp; vec1, <span class="type">const</span> std::vector&lt;<span class="type">float</span>&gt;&amp; vec2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*功能：控制灯</span></span><br><span class="line"><span class="comment">*参数nMode：1 开  0 是关</span></span><br><span class="line"><span class="comment">*返回值1 -- 成功， 0 -- 失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">MV_EXP_API <span class="type">int</span> __stdcall <span class="title">LightControl</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> nMode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">C++中动态库关键字</summary>
    
    
    
    <category term="C++" scheme="https://ouyujia.github.io/categories/C/"/>
    
    <category term="动态库" scheme="https://ouyujia.github.io/categories/C/%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    
    
    <category term="C++" scheme="https://ouyujia.github.io/tags/C/"/>
    
    <category term="动态库" scheme="https://ouyujia.github.io/tags/%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    
  </entry>
  
</feed>
