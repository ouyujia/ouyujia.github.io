<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>相遇之初</title>
  
  <subtitle>ouyang</subtitle>
  <link href="https://ouyujia.github.io/atom.xml" rel="self"/>
  
  <link href="https://ouyujia.github.io/"/>
  <updated>2023-05-05T11:26:22.026Z</updated>
  <id>https://ouyujia.github.io/</id>
  
  <author>
    <name>欧阳</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>QT信号和槽解析</title>
    <link href="https://ouyujia.github.io/2023/05/05/QT%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%E8%A7%A3%E6%9E%90/"/>
    <id>https://ouyujia.github.io/2023/05/05/QT%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%E8%A7%A3%E6%9E%90/</id>
    <published>2023-05-05T11:50:59.000Z</published>
    <updated>2023-05-05T11:26:22.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><ul><li>Qt使用信号与槽机制进行对象间的通信，当某个对象的状态发生变化时，该对象会触发一个信号，该信号和另外一些对象的槽函数绑定，信号的触发将导致执行这些槽函数，这些槽函数将处理第一个对象状态的变化，完成对象之间的通信。</li><li>信号和槽本质上还是回调函数。</li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。</p><p>槽的本质是类的成员函数，其参数可以是任意类型的。和普通C++成员函数几乎没有区别，它可以是虚函数；也可以被重载；可以是公有的、保护的、私有的、也可以被其他C++成员函数调用。唯一区别的是：槽可以与信号连接在一起，每当和槽连接的信号被发射的时候，就会调用这个槽。</p><hr><p>自定义信号槽注意事项：</p><blockquote><ol><li>发送者和接收者都需要是QObject的子类（当然，槽函数是全局函数、Lambda 表达式等无需接收者的时候除外）；</li><li>使用 signals 标记信号函数，信号是一个函数声明，返回 void，不需要实现函数代码；</li><li>槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响；</li><li>使用 emit 在恰当的位置发送信号(emit 是一个空宏定义,只作为一个信号发送的标志,没有实际含义,不适用emit也可以发送信号)；</li><li>使用QObject::connect()函数连接信号和槽；</li><li>任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数。</li></ol></blockquote><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><h3 id="信号的发出"><a href="#信号的发出" class="headerlink" title="信号的发出"></a>信号的发出</h3><p>由于某种条件到达可能引起了对象改变，其内部状态将发生改变，这时候对象就会发出信号。信号是公共访问函数，可以从任何地方发出，但是建议：<strong>【只从定义该信号的类及其子类发出信号】</strong>。</p><p>在Qt框架下，信号发出分为两种：</p><ol><li>【每个类预定义的信号】：这些信号何时发出可以通过查看官方文档获知。</li><li>【自定义的信号】：这些信号的发出由开发人员自行定义。</li></ol><h3 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a><strong>信号的处理</strong></h3><p>当一个信号发出时，连接到它的槽函数通常会立即执行，就像一个普通函数调用一样。在这种情况下，信号和槽函数机制是完全独立于GUI事件循环的，也并不会干扰GUI的事件循环。<code>emit</code>语句之后的代码将在所有槽函数都返回之后才执行。如果使用<strong>排队连接（queued connections）</strong>，情况略有不同，在这种情况下，emit关键字后面的代码将立即继续，槽函数将在后续执行。</p><p>如果几个槽函数连接到同一个信号上，当信号发出时，这些槽函数将按照它们连接时的顺序依次执行【这一点很重要】。</p><p>信号是由<code>moc</code>工具自动生成，不能在.cpp文件中实现，所以信号永远不能有返回类型(必须使用<code>void</code>关键字定义信号)。</p><p>关于信号和槽参数的注意事项：经验表明，如果信号和槽函数不使用特殊类型，那么代码具有极强的可重用性。</p><p>下表是使用<code>connect()</code>创建信号和槽函数连接时，可以指定5种不同的连接类型：</p><table><thead><tr><th>序号</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>Qt::AutoConnection</td><td>如果接收者生活在发出信号的线程中，Qt::DirectConnection被使用。否则，使用Qt::QueuedConnection。连接类型是在信号发出时确定。【这是Qt创建信号和槽函数时的默认连接方式】</td></tr><tr><td>2</td><td>Qt::DirectConnection</td><td>当信号发出时，槽函数立即被调用。槽函数在发送信号的线程中执行。</td></tr><tr><td>3</td><td>Qt::QueuedConnection</td><td>当控制返回到接收方线程的事件循环时，将调用槽函数。槽函数在接收方的线程中执行。</td></tr><tr><td>4</td><td>Qt::BlockingQueuedConnection</td><td>与Qt::QueuedConnection相同，只是在槽函数返回之前线程会阻塞。如果接收方存在于发送信号的线程中，则不能使用此连接，否则应用程序将会死锁。</td></tr><tr><td>5</td><td>Qt::UniqueConnection</td><td>这是一个标志，可以使用按位OR与上述的连接类型进行组合。当Qt::UniqueConnection被设置时，如果连接已经存在，QObject::connect()将失败(例如，如果相同的信号已经连接到同一对对象的相同槽位)。注：这个标志在Qt 4.6中引入。</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="槽函数"><a href="#槽函数" class="headerlink" title="槽函数"></a>槽函数</h2><p>当一个连接到槽函数的信号被发射时，槽函数将被调用。槽函数是普通的C++函数，在实际开发中也可以正常调用；它们唯一的特点是：【信号可以与它们相连接】。</p><p>由于槽是普通的成员函数，所以它们在直接调用时遵循普通的C++规则。但是，作为槽函数时，任何组件都可以通过信号连接从而调用它们。</p><p>还可以将槽函数定义为虚拟的，这在开发中非常有用。</p><p>与回调机制相比，信号和槽函数机制的速度稍微慢一些，这一点对于实际应用程序来说，这种差别并不显著。一般来说，发送一个连接到某些槽函数的信号，比直接调用非虚函数要慢大约10倍。这是定位连接对象、安全地遍历所有连接(即检查后续接收方在发射过程中没有被销毁)以及以函数调用增加的开销。虽然10个非虚函数调用听起来很多，但是它比new操作或delete操作的开销要小得多。一旦在后台执行一个需要new或delete的字符串、向量或列表操作，信号和槽函数的开销只占整个函数调用开销的很小一部分。在槽函数中执行系统调用时也是如此（或间接调用超过十个函数）。因此信号和槽函数机制的简单性和灵活性是值得的，这些开销在实际应用场景下甚至不会注意到。</p><p>注意，当与基于Qt的应用程序一起编译时，定义为信号或槽的变量的第三方库可能会导致编译器出现警告和错误。要解决这个问题，使用<code>#undef</code>来定义出错的预处理器符号即可。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ol><li><p>一个信号可以和多个槽相连</p><blockquote><p>如果是这种情况，这些槽会一个接一个的被调用，但是它们的调用顺序是不确定的。</p></blockquote></li><li><p>多个信号可以连接到一个槽</p><blockquote><p>只要任意一个信号发出，这个槽就会被调用。</p></blockquote></li><li><p>一个信号可以连接到另外的一个信号</p><blockquote><p>当第一个信号发出时，第二个信号被发出。除此之外，这种信号-信号的形式和信号-槽的形式没有什么区别。</p></blockquote></li><li><p>槽可以被取消链接</p><blockquote><p>这种情况并不经常出现，因为当一个对象delete之后，Qt自动取消所有连接到这个对象上面的槽。</p></blockquote></li><li><p>使用Lambda 表达式</p><blockquote><p>在使用 Qt 5 的时候，能够支持 Qt 5 的编译器都是支持 Lambda 表达式的。</p></blockquote></li></ol><p><strong>总结:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/20190109151732226.png" alt="信号和槽"></p><h3 id="带有默认参数的信号和槽函数"><a href="#带有默认参数的信号和槽函数" class="headerlink" title="带有默认参数的信号和槽函数"></a><strong>带有默认参数的信号和槽函数</strong></h3><p>信号和槽可以包含参数，参数可以有默认值。例如：<code>QObject::destroyed()</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroyed</span><span class="params">(QObject* = <span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>当<code>QObject</code>被删除时，它会发出这个<code>QObject::destroyed()</code>信号。无论我们在哪里有一个悬空引用指向已删除的QObject，都希望捕捉到这个信号，这样就可以清除它。合适的槽参数可以是：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">objectDestroyed</span><span class="params">(QObject* obj = <span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="使用QObject-connect-将信号连接到槽函数的三种方法"><a href="#使用QObject-connect-将信号连接到槽函数的三种方法" class="headerlink" title="使用QObject::connect()将信号连接到槽函数的三种方法"></a><strong>使用QObject::connect()将信号连接到槽函数的三种方法</strong></h3><ul><li><p>第一种方法：使用函数指针(qt5)</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender, &amp;QObject::destroyed, <span class="keyword">this</span>, &amp;MyObject::objectDestroyed);</span><br></pre></td></tr></tbody></table></figure><p>将<code>QObject::connect()</code>与函数指针一起使用有几个优点。它允许编译器检查信号的参数是否与槽的参数兼容。当然，编译器还可以隐式地转换参数。</p></li><li><p>第二种方法：连接到C++ 11的lambdas</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender, &amp;QObject::destroyed, <span class="keyword">this</span>, [=](){ <span class="keyword">this</span>-&gt;m_objects.<span class="built_in">remove</span>(sender); });</span><br></pre></td></tr></tbody></table></figure><p>在这种情况下，我们在connect()调用中提供这个上下文。上下文对象提供关于应该在哪个线程中执行接收器的信息。</p><p>当发送方或上下文被销毁时，<code>lambda</code>将断开连接。注意：当信号发出时，函数内部使用的所有对象依然是激活的。</p></li><li><p>第三种方法：使用<code>QObject::connect()</code>以及信号和槽声明宏。(qt4)</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在<span class="built_in">SIGNAL</span>()和<span class="built_in">SLOT</span>()宏中包含参数(如果参数有默认值)的规则是：传递给<span class="built_in">SIGNAL</span>()宏的参数不能少于传递给<span class="built_in">SLOT</span>()宏的参数。</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="使用disconnect断开信号-x2F-槽连接"><a href="#使用disconnect断开信号-x2F-槽连接" class="headerlink" title="使用disconnect断开信号/槽连接"></a><strong>使用disconnect断开信号/槽连接</strong></h3><p><code>disconnect()</code>用于断开对象发送器中的信号与对象接收器中的方法的连接。如果连接成功断开，则返回true；否则返回false。</p><p>当对信号/槽关联的两方中的任何一个对象进行销毁时，信号/槽连接将被移除。</p><p><code>disconnect()</code>有三种使用方法，如下示例所示：</p><p>1、断开所有与对象相连的信号/槽：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disconnect</span>(myObject, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br></pre></td></tr></tbody></table></figure><p>相当于非静态重载函数：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject-&gt;<span class="built_in">disconnect</span>();</span><br></pre></td></tr></tbody></table></figure><p>2、断开所有与特定信号相连的对象：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disconnect</span>(myObject, <span class="built_in">SIGNAL</span>(<span class="built_in">mySignal</span>()), <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br></pre></td></tr></tbody></table></figure><p>相当于非静态重载函数：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject-&gt;<span class="built_in">disconnect</span>(<span class="built_in">SIGNAL</span>(<span class="built_in">mySignal</span>()));</span><br></pre></td></tr></tbody></table></figure><p>3、断开特定接收对象的连接：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disconnect</span>(myObject, <span class="literal">nullptr</span>, myReceiver, <span class="literal">nullptr</span>);</span><br></pre></td></tr></tbody></table></figure><p>相当于非静态重载函数：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObject-&gt;<span class="built_in">disconnect</span>(myReceiver);</span><br></pre></td></tr></tbody></table></figure><p><code>nullptr</code>可以用作通配符，分别表示“任何信号”、“任何接收对象”或“接收对象中的任何槽”。</p><p>如下格式的使用示例：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disconnect</span>(发送对象，信号，接收对象，方法）</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>发送对象</strong>不会是nullptr。</li><li>如果<strong>信号</strong>为nullptr，将断开<strong>接收对象</strong>和<strong>槽函数</strong>与所有<strong>信号</strong>的连接。否则只断开指定的<strong>信号</strong>。</li><li>如果<strong>接收对象</strong>是nullptr，它断开所有关联该信号的连接。否则，只断开与<strong>接收对象</strong>的槽函数连接。</li><li>如果方法是nullptr，它会断开任何连接到<strong>接收对象</strong>的连接。如果不是，只有命名为<strong>方法</strong>的槽函数连接将被断开。如果没有<strong>接收对象</strong>，<strong>方法</strong>必须为nullptr。即：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disconnect</span>(发送对象，信号，<span class="literal">nullptr</span>，<span class="literal">nullptr</span>）</span><br></pre></td></tr></tbody></table></figure><h3 id="使用Qt与第三方信号和槽函数"><a href="#使用Qt与第三方信号和槽函数" class="headerlink" title="使用Qt与第三方信号和槽函数"></a><strong>使用Qt与第三方信号和槽函数</strong></h3><p>当第三方库中也有信号/槽函数机制时，这时候又需要使用Qt的信号和槽函数机制。对于这种开发场景，Qt可以在同一个项目中使用这两种机制。需将下面一行添加到qmake项目(.pro)工程配置文件中：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG += no_keywords</span><br></pre></td></tr></tbody></table></figure><p>该配置将告诉Qt不要定义moc关键字信号、槽函数和<code>emit</code>，因为这些名称将被第三方库使用（例如<code>Boost</code>）。如果要在使用no_keywords标志下继续使用Qt信号和槽机制，需将源文件中所有的Qt moc关键字替换为对应的Qt宏：Q_SIGNALS(或Q_SIGNAL)、Q_SLOT(或Q_SLOT)和Q_EMIT。</p><h2 id="信号和槽优缺点"><a href="#信号和槽优缺点" class="headerlink" title="信号和槽优缺点"></a>信号和槽优缺点</h2><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>为什么Qt使用信号与槽机制而不是传统的回调函数机制进行对象间的通信呢？<br>回调函数的本质是“你想让别人的代码执行你的代码，而别人的代码你又不能动”这种需求下产生的。<br>回调函数是函数指针的一种用法，如果多个类都关注某个类的状态变化，此时需要维护一个列表，以存放多个回调函数的地址。对于每一个被关注的类，都需要做类似的工作，因此这种做法效率低，不灵活。</p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>Qt使用信号与槽机制来解决这个问题，程序员只需要指定一个类含有哪些信号函数、哪些槽函数，Qt会处理信号函数和槽函数之间的绑定。当信号函数被调用时，Qt会找到并执行与其绑定的槽函数。允许一个信号函数和多个槽函数绑定，Qt会依次找到并执行与一个信号函数绑定的所有槽函数，这种处理方式更灵活。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><ul><li>类型安全：需要关联的信号槽的签名必须是等同的。即信号的参数类型和参数个数同接受该信号的槽的参数类型和参数个数相同。若信号和槽签名不一致，则编译器会报错。</li><li>松散耦合：信号和槽机制减弱了Qt对象的耦合度。激发信号的Qt对象无需知道是哪个对象的那个槽接收它发出的信号，它只需要在适当的时间发送适当的信号即可，而不需要关心是否被接收和哪个对象接收了。Qt保证适当的槽得到了调用，即使关联的对象在运行时删除，程序也不会崩溃。</li><li>灵活性：一个信号可以关联多个槽，多个信号也可以关联同一个槽。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>速度较慢：与回调函数相比，信号和槽机制运行速度比直接调用非虚函数慢10倍左右。</li></ul><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul><li>需要定位接收信号的对象。</li><li>安全地遍历所有槽。</li><li>编组，解组传递参数。</li><li>多线程的时候，信号需要排队等候。（然而，与创建对象的new操作及删除对象的delete操作相比，信号和槽的运行代价只是他们很少的一部分。信号和槽机制导致的这点性能损失，对于实时应用程序是可以忽略的。）</li></ul><h2 id="信号和槽无法连接问题分析"><a href="#信号和槽无法连接问题分析" class="headerlink" title="信号和槽无法连接问题分析"></a>信号和槽无法连接问题分析</h2><ol><li><p>使用qt4信号和槽方法转发信号到qt5信号和槽方法中</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slot</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="type">void</span> <span class="built_in">signal</span>()), <span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="type">void</span> <span class="built_in">signal2</span>()));</span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;test::siganl2, <span class="keyword">this</span>, &amp;test::slot);</span><br></pre></td></tr></tbody></table></figure><p>原因:qt4使用宏连接信号和槽,本质是将信号和槽函数转为字符串,而qt5是使用函数指针,因此无法混用转发信号.</p></li><li><p>使用qt4信号和槽的方式连接时带了形参</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">singal</span><span class="params">(QString text)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slot</span><span class="params">(QString text)</span></span>;</span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="type">void</span> <span class="built_in">signal</span>(QString text)), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="type">void</span> <span class="built_in">slot</span>(QString text))); <span class="comment">// 可能会在编译时报错,也可能不会,但在运行时slot一定不会生效</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>使用自定义类型参数而没有进行注册</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">{</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">(Myclass ha)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slot</span><span class="params">(Myclass he)</span></span>;</span><br><span class="line"><span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;test::siganl2, <span class="keyword">this</span>, &amp;test::slot);<span class="comment">// 槽函数没有生效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型注册</span></span><br><span class="line"><span class="number">1</span>、注册位置：在第一次使用此类链接跨线程的signal/slot之前，一般在当前类的构造函数中进行注册；</span><br><span class="line">  <span class="number">2</span>、注册方法：在当前类的顶部包含：<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMetaType&gt;</span>，构造函数中加入代码：qRegisterMetaType<span class="string">&lt;MyClass&gt;</span>(<span class="string">"Myclass"</span>)；</span></span><br><span class="line">  <span class="number">3</span>、Myclass的引用类型需单独注册：<span class="built_in">qRegisterMetaType</span>&lt;MyClass&gt;(<span class="string">"Myclass&amp;"</span>)；</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>连接信号和槽时,对象是空指针(未定义)</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">{</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slot</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">connect</span>(ha, &amp;test::siganl2, he, &amp;test::slot);<span class="comment">// 槽函数没有生效</span></span><br><span class="line">Myclass ha = <span class="keyword">new</span> <span class="built_in">Myclass</span>();</span><br><span class="line">Myclass he = <span class="keyword">new</span> <span class="built_in">Myclass</span>();</span><br></pre></td></tr></tbody></table></figure><p>信号和槽一定要在对象定义之后进行连接才能生效</p></li><li><p>信号声明为私有方法其他类对象连接失败(其他博客里提及,本人验证了放在私有里也是可以的,索性也列在这里供大家参考)</p><p>test.h</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> : <span class="keyword">public</span> QObject</span><br><span class="line">{</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(QObject* parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>; <span class="comment">//! 私有槽函数可以被其他类对象连接，并不是只能由本类内部连接</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span> : <span class="keyword">public</span> QObject</span><br><span class="line">{</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Test2</span><span class="params">(QObject* parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">signalPrint</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// TEST_H</span></span></span><br></pre></td></tr></tbody></table></figure><p>test.cpp</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"test.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Test::<span class="built_in">Test</span>(QObject *parent)</span><br><span class="line">    : <span class="built_in">QObject</span>(parent)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"private is connected\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Test2::<span class="built_in">Test2</span>(QObject *parent)</span><br><span class="line">    : <span class="built_in">QObject</span>(parent)</span><br><span class="line">{</span><br><span class="line">    Test test;</span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, <span class="built_in">SIGNAL</span>(<span class="built_in">signalPrint</span>()), &amp;test, <span class="built_in">SLOT</span>(<span class="built_in">print</span>()));</span><br><span class="line">    <span class="function">emit <span class="title">signalPrint</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>执行结果</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1683285517791.png" alt="执行结果"></p></li></ol><h3 id="虚拟槽函数"><a href="#虚拟槽函数" class="headerlink" title="虚拟槽函数"></a>虚拟槽函数</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq_30725967/article/details/104515447">Qt之信号signals和槽slots详解_private slots</a></p><p><a href="https://kevin-org.blog.csdn.net/article/details/121232524?spm=1001.2014.3001.5502">Qt之信号槽机制</a></p><p><a href="https://zhuanlan.zhihu.com/p/603617075">Qt一篇全面的信号和槽函数机制总结</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;机制&quot;&gt;&lt;a href=&quot;#机制&quot; class=&quot;headerlink&quot; title=&quot;机制&quot;&gt;&lt;/a&gt;机制&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Qt使用信号与槽机制进行对象间的通信，当某个对象的状态发生变化时，该对象会触发一个信号，该信号和另外一些对象的槽函数绑定，信号的</summary>
      
    
    
    
    <category term="QT" scheme="https://ouyujia.github.io/categories/QT/"/>
    
    
    <category term="QT" scheme="https://ouyujia.github.io/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title>page</title>
    <link href="https://ouyujia.github.io/2023/05/04/QTHtml/"/>
    <id>https://ouyujia.github.io/2023/05/04/QTHtml/</id>
    <published>2023-05-04T02:00:41.000Z</published>
    <updated>2023-05-05T11:26:51.981Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>QT串口通讯错误码解析</title>
    <link href="https://ouyujia.github.io/2023/05/01/QT%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF%E9%94%99%E8%AF%AF%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://ouyujia.github.io/2023/05/01/QT%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF%E9%94%99%E8%AF%AF%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2023-05-01T08:43:26.000Z</published>
    <updated>2023-04-28T09:12:14.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>项目使用qt串口接口QSerialPort进行串口通讯，生产反馈产品提示串口通讯异常，查看log发现有3个错误码</p><p>分别是PermissionError(2)、WriteError(7)、UnknownError(11)。后面分析日志、了解生产情况找到了问题点。</p><blockquote><ul><li>PermissionError原因：串口占用，生产电脑上面先跑了串口调试工具导致串口打开失败</li><li>WriteError及UnknownError原因：（这连个错误是同时出现的额，先报WriteError后面紧跟UnknownError）通过对比日志发现是Windows自动睡眠后再次唤醒出现的。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682670665137.png" alt="1682670665137"></p></blockquote><h3 id="QT串口通讯错误码及机翻"><a href="#QT串口通讯错误码及机翻" class="headerlink" title="QT串口通讯错误码及机翻"></a>QT串口通讯错误码及机翻</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SerialPortError</span> {</span><br><span class="line">        NoError, <span class="comment">// 没有错误</span></span><br><span class="line">    </span><br><span class="line">        DeviceNotFoundError,<span class="comment">// 试图打开不存在的设备时发生错误。</span></span><br><span class="line">    </span><br><span class="line">        PermissionError,<span class="comment">// 1、试图打开另一个进程已打开的设备时</span></span><br><span class="line">    <span class="comment">// 2、用户没有足够的权限和凭据打开时发生错误。</span></span><br><span class="line">    </span><br><span class="line">        OpenError,<span class="comment">// 试图打开本进程中已打开的设备时发生错误。</span></span><br><span class="line">    </span><br><span class="line">        ParityError,<span class="comment">// 读取数据时，硬件检测到奇偶校验错误。</span></span><br><span class="line">    <span class="comment">// 这个值已经过时了。我们强烈建议不要在新代码中使用它。</span></span><br><span class="line">    </span><br><span class="line">        FramingError,<span class="comment">// 读取数据时硬件检测到帧错误。</span></span><br><span class="line">    <span class="comment">// 这个值已经过时了。我们强烈建议不要在新代码中使用它。</span></span><br><span class="line">    </span><br><span class="line">        BreakConditionError,<span class="comment">// 硬件在输入线上检测到断路情况。</span></span><br><span class="line">    <span class="comment">// 这个值已经过时了。我们强烈建议不要在新代码中使用它。</span></span><br><span class="line">    </span><br><span class="line">        WriteError,<span class="comment">// 写入数据时发生I/O错误。</span></span><br><span class="line">    </span><br><span class="line">        ReadError,<span class="comment">// 读取数据时发生I/O错误。</span></span><br><span class="line">    </span><br><span class="line">        ResourceError,<span class="comment">// 当资源不可用时发生I/O错误，例如当设备意外地从系统中移除时。</span></span><br><span class="line">    </span><br><span class="line">        UnsupportedOperationError, <span class="comment">//当前操作系统不支持或不禁止所请求的设备操作。</span></span><br><span class="line">    </span><br><span class="line">        UnknownError,<span class="comment">// 发生了一个无法识别的错误。</span></span><br><span class="line">    </span><br><span class="line">        TimeoutError,<span class="comment">// 发生超时错误。这个值是在QtSerialPort 5.2中引入的。</span></span><br><span class="line">    </span><br><span class="line">        NotOpenError<span class="comment">// 当执行的操作只有在设备打开的情况下才能成功执行时，会发生此错误。</span></span><br><span class="line">            <span class="comment">// 这个值是在QtSerialPort 5.2中引入的。</span></span><br><span class="line">    };</span><br></pre></td></tr></tbody></table></figure><h3 id="串口错误码处理"><a href="#串口错误码处理" class="headerlink" title="串口错误码处理"></a>串口错误码处理</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">m_uart = <span class="keyword">new</span> <span class="built_in">QSerialPort</span>();  <span class="comment">//不能指定父对象</span></span><br><span class="line"><span class="comment">//! 连接串口通信错误信号</span></span><br><span class="line"><span class="built_in">connect</span>(m_uart, <span class="built_in">SIGNAL</span>(<span class="built_in">errorOccurred</span>(QSerialPort::SerialPortError)), <span class="keyword">this</span>,</span><br><span class="line">        <span class="built_in">SLOT</span>(<span class="built_in">errorFunc</span>(QSerialPort::SerialPortError)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//! 串口通信错误吗处理接口 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UartPortThread::errorFunc</span><span class="params">(QSerialPort::SerialPortError error)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (error != QSerialPort::NoError &amp;&amp; error != QSerialPort::TimeoutError</span><br><span class="line">            &amp;&amp; error != QSerialPort::NotOpenError &amp;&amp; error !=      QSerialPort::DeviceNotFoundError)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; Q_FUNC_INFO &lt;&lt; QString::<span class="built_in">number</span>(error) &lt;&lt; <span class="string">"error...."</span>;</span><br><span class="line">        m_needReconnect = <span class="literal">true</span>;</span><br><span class="line">        <span class="function">emit <span class="title">uartConnectState</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">setPortName</span>(<span class="string">""</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;项目使用qt串口接口QSerialPort进行串口通讯，生产反馈产品提示串口通讯异常，查看log发现有3个错误码&lt;/p&gt;
&lt;p&gt;分别是Per</summary>
      
    
    
    
    <category term="QT" scheme="https://ouyujia.github.io/categories/QT/"/>
    
    
    <category term="QT" scheme="https://ouyujia.github.io/tags/QT/"/>
    
    <category term="串口" scheme="https://ouyujia.github.io/tags/%E4%B8%B2%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>QT自定义log系统</title>
    <link href="https://ouyujia.github.io/2023/04/29/QT%E8%87%AA%E5%AE%9A%E4%B9%89log%E7%B3%BB%E7%BB%9F/"/>
    <id>https://ouyujia.github.io/2023/04/29/QT%E8%87%AA%E5%AE%9A%E4%B9%89log%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-04-29T11:51:29.000Z</published>
    <updated>2023-05-04T02:56:58.543Z</updated>
    
    
    
    
    <category term="QT" scheme="https://ouyujia.github.io/categories/QT/"/>
    
    
    <category term="QT" scheme="https://ouyujia.github.io/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title>QT使用MingW编译器添加Dump调试功能</title>
    <link href="https://ouyujia.github.io/2023/04/28/QTMingW%E6%B7%BBDump%E5%8A%9F%E8%83%BD/"/>
    <id>https://ouyujia.github.io/2023/04/28/QTMingW%E6%B7%BBDump%E5%8A%9F%E8%83%BD/</id>
    <published>2023-04-28T08:43:26.000Z</published>
    <updated>2023-04-28T09:00:30.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>最近因为维护的项目出现崩溃，客户现场的log无法定位，因此需要使用dump文件调试于是查找资料添加了一个崩溃生成dump文件功能</p></blockquote><hr><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><blockquote><p>Qt5.12.9-MingW版本/Qt5.5.1-MingW版本，Visual Studio 2017/Visual Studio 2013，Windows系统</p></blockquote><hr><h2 id="配置pro文件，在exe文件加入调试信息"><a href="#配置pro文件，在exe文件加入调试信息" class="headerlink" title="配置pro文件，在exe文件加入调试信息"></a>配置pro文件，在exe文件加入调试信息</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QMAKE_CFLAGS_RELEASE += -g</span><br><span class="line">QMAKE_CXXFLAGS_RELEASE += -g</span><br><span class="line">#禁止优化</span><br><span class="line">QMAKE_CFLAGS_RELEASE -= -O2</span><br><span class="line">QMAKE_CXXFLAGS_RELEASE -= -O2</span><br><span class="line">QMAKE_LFLAGS_RELEASE = -mthreads -W</span><br><span class="line">#生成dump文件需要</span><br><span class="line">LIBS += -lDbgHelp</span><br><span class="line">#加上下面两行，否则用vs调试时，提示“未找到xxx.exe<span class="string">"</span></span><br><span class="line"><span class="string">QMAKE_CXXFLAGS += -g</span></span><br><span class="line"><span class="string">QMAKE_CFLAGS += -g</span></span><br></pre></td></tr></tbody></table></figure><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"mainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDir&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;qdebug.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDateTime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;qglobal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QList&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMap&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_WIN</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dbghelp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_WIN</span></span><br><span class="line"><span class="comment">//! 异常处理回调（崩溃时自动调用）</span></span><br><span class="line"><span class="function"><span class="type">static</span> LONG WINAPI <span class="title">exceptionCallback</span><span class="params">(<span class="keyword">struct</span> _EXCEPTION_POINTERS* exceptionInfo)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QCoreApplication *app = QApplication::<span class="built_in">instance</span>();</span><br><span class="line"></span><br><span class="line">    QString savePath = app-&gt;<span class="built_in">applicationDirPath</span>() + <span class="string">"dump/"</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"save path :"</span>&lt;&lt;savePath;</span><br><span class="line">    <span class="function">QDir <span class="title">dir</span><span class="params">(savePath)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!dir.<span class="built_in">exists</span>() &amp;&amp; !dir.<span class="built_in">mkpath</span>(savePath)) {</span><br><span class="line">        app-&gt;<span class="built_in">exit</span>(E_UNEXPECTED);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_EXECUTE_HANDLER;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    savePath.<span class="built_in">append</span>(<span class="string">"assit_"</span>);</span><br><span class="line">    savePath.<span class="built_in">append</span>(QDateTime::<span class="built_in">currentDateTime</span>().<span class="built_in">toString</span>(<span class="string">"yyyyMMddhhmmsszzz"</span>));</span><br><span class="line">    savePath.<span class="built_in">append</span>(<span class="string">".dmp"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建dump文件</span></span><br><span class="line">    HANDLE dump = <span class="built_in">CreateFileW</span>(savePath.<span class="built_in">toStdWString</span>().<span class="built_in">c_str</span>(), GENERIC_WRITE,</span><br><span class="line">        <span class="number">0</span>, <span class="literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (INVALID_HANDLE_VALUE == dump) {</span><br><span class="line">        app-&gt;<span class="built_in">exit</span>(E_UNEXPECTED);</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_EXECUTE_HANDLER;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    MINIDUMP_EXCEPTION_INFORMATION miniDumpExceptionInfo;</span><br><span class="line">    miniDumpExceptionInfo.ExceptionPointers = exceptionInfo;</span><br><span class="line">    miniDumpExceptionInfo.ThreadId = <span class="built_in">GetCurrentThreadId</span>();</span><br><span class="line">    miniDumpExceptionInfo.ClientPointers = TRUE;</span><br><span class="line">    DWORD idProcess = <span class="built_in">GetCurrentProcessId</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将崩溃信息写入dump文件中</span></span><br><span class="line">    <span class="built_in">MiniDumpWriteDump</span>(<span class="built_in">GetCurrentProcess</span>(), idProcess, dump,</span><br><span class="line">        MiniDumpNormal, &amp;miniDumpExceptionInfo, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(dump);</span><br><span class="line"></span><br><span class="line">    app-&gt;<span class="built_in">exit</span>(E_UNEXPECTED);</span><br><span class="line">    <span class="keyword">return</span> EXCEPTION_EXECUTE_HANDLER;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//! 空指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">crashNullPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//空指针测试</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span>* p_a = (<span class="type">int</span>*)(<span class="literal">NULL</span>); *p_a = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//! 悬浮指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">crashFloatPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span>* p_a = &amp;a;</span><br><span class="line">    <span class="keyword">delete</span> p_a;</span><br><span class="line">    *p_a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"*p_a :"</span>&lt;&lt; *p_a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//! 野指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">crashWildPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span>* p_a;</span><br><span class="line">    *p_a = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"*p_a :"</span>&lt;&lt; *p_a;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//! array越界</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ArrayExceed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">2</span>] = {<span class="number">0</span>, <span class="number">1</span>};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        arr[i] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"arr[i]"</span>&lt;&lt; arr[i];</span><br><span class="line">    }</span><br><span class="line">    arr[<span class="number">1000</span>] = <span class="number">11111</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"arr[10000]"</span>&lt;&lt; arr[<span class="number">10000</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Vector越界</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VectorExceed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; vec = {<span class="number">0</span>, <span class="number">1</span>};</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        value = vec.<span class="built_in">at</span>(i);</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"arr.at(i)"</span>&lt;&lt; value;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"arr[10000]"</span>&lt;&lt; vec.<span class="built_in">at</span>(<span class="number">10000</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Vector越界</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VectorExceed2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; vec = {<span class="number">0</span>, <span class="number">1</span>};</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        vec[i] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"arr[i]"</span>&lt;&lt; vec[i];</span><br><span class="line">    }</span><br><span class="line">    vec[<span class="number">1000</span>] = <span class="number">11111</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">"arr[10000]"</span>&lt;&lt; vec[<span class="number">10000</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//! list越界</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListExceed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    QList&lt;<span class="type">int</span>&gt; list = {<span class="number">0</span>, <span class="number">1</span>};</span><br><span class="line">    list[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Map</span></span><br><span class="line"><span class="comment">//void MapExceed()</span></span><br><span class="line"><span class="comment">//{</span></span><br><span class="line"><span class="comment">//    QMap&lt;int, QString&gt; map;</span></span><br><span class="line"><span class="comment">//    map.insert(0, "frist");</span></span><br><span class="line"><span class="comment">//    map.insert(1, "second");</span></span><br><span class="line"><span class="comment">//    map.remove(3);</span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Q_OS_WIN</span></span><br><span class="line">    <span class="comment">//! 注册异常奔溃回调</span></span><br><span class="line">    <span class="built_in">SetUnhandledExceptionFilter</span>(exceptionCallback);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//测试接口</span></span><br><span class="line"><span class="comment">//    crashNullPtr();</span></span><br><span class="line"><span class="comment">//    crashFloatPtr();</span></span><br><span class="line"><span class="comment">//    crashWildPtr();</span></span><br><span class="line"><span class="comment">//    ArrayExceed();</span></span><br><span class="line">    <span class="built_in">VectorExceed</span>();</span><br><span class="line"><span class="comment">//    VectorExceed2();</span></span><br><span class="line"><span class="comment">//    ListExceed();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="生成pdb文件"><a href="#生成pdb文件" class="headerlink" title="生成pdb文件"></a>生成pdb文件</h2><blockquote><p>注：WingW编译器并不会像MSVC一样自动生成pdb文件需要使用第三方工具生成。这里使用github开源工具<strong>cv2pdb.exe</strong>生成。</p></blockquote><h3 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h3><p><a href="https://github.com/rainers/cv2pdb">下载链接</a></p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682242797578.png" alt="1682242797578"></p><p>下载下来使用vs2017编译源码的到cv2pdb.exe文件。</p><h3 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h3><blockquote><p>使用命令行(cmd)</p><ol><li>打开命令行，cd到cv2pdb.exe文件路径下</li><li>执行指令 “cv2pdb.exe  xxx.exe”即可在xxx.exe同级路径下生成xxx.pdb文件</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682243028125.png" alt="1682243028125"></p><h3 id="出现错误："><a href="#出现错误：" class="headerlink" title="出现错误："></a>出现错误：</h3><blockquote><p><strong>qBreakpadTest.pdb: cannot load PDB helper DLL</strong></p></blockquote><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p><strong>错误原因：电脑没有安装Visual Studio环境</strong></p><blockquote><p>安装Visual Studio即可解决</p></blockquote><hr><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><hr><h3 id="使用Visual-Studio-IDE调试（推荐）"><a href="#使用Visual-Studio-IDE调试（推荐）" class="headerlink" title="使用Visual Studio IDE调试（推荐）"></a>使用Visual Studio IDE调试（推荐）</h3><h4 id="加载pdb文件"><a href="#加载pdb文件" class="headerlink" title="加载pdb文件"></a>加载pdb文件</h4><blockquote><p>使用Visual Studio打开需要调试的pdb文件(将exe文件和pdb放到同一目录下，然后设置符合路径)</p></blockquote><hr><h4 id="设置调试pdb目录位置"><a href="#设置调试pdb目录位置" class="headerlink" title="设置调试pdb目录位置"></a>设置调试pdb目录位置</h4><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682243563126.png" alt="1682243563126"></p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682243641185.png" alt="1682243641185"></p><hr><h4 id="设置源码目录"><a href="#设置源码目录" class="headerlink" title="设置源码目录"></a>设置源码目录</h4><p>在解决方案-属性，打开弹窗设置</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682243771250.png" alt="1682243771250"></p><h4 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h4><blockquote><p>点击 “使用 仅限本机 进行调试”</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682243822104.png" alt="1682243822104"></p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/kk_image.jpg" alt="img"></p><hr><h3 id="使用Windows调试器windbg-exe调试"><a href="#使用Windows调试器windbg-exe调试" class="headerlink" title="使用Windows调试器windbg.exe调试"></a>使用Windows调试器windbg.exe调试</h3><blockquote><p><a href="https://developer.microsoft.com/zh-cn/windows/downloads/windows-sdk/">下载链接</a></p><p>此链接是下载Windows SDK安装包的，Windows SDK安装包含windbg.exe。</p></blockquote><h4 id="调试步骤"><a href="#调试步骤" class="headerlink" title="调试步骤"></a>调试步骤</h4><blockquote><ol><li>双击打开windbg.exe，选择相应版本</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682405908877.png" alt="1682405865975"></p><ol start="2"><li>依次完成如下配置<br>打开File 需要完成 Symbol File Path 、Source File Path、Image File Path 的配置</li><li>Symbol File Path ：这里就是加載pdb文件的路徑</li><li>Source File Path: 加载程序代码 存放的路径（注意切回發佈版本的代碼）</li><li>Image File Path: 加載exe 存放的路徑</li><li>選擇Open Crash Dump 導入生成的dmp文件</li><li>输入命令 !analyze -v ，等待几秒后会打印出错误信息</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682407236891.png" alt="1682407236891"></p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blog-img/img/1682407088643.png" alt="1682407088643"></p></blockquote><p>1、Symbol File Path ：這裏就是加載pdb文件的路徑，我們直接使用</p><p>D:/Project/DumTools/<br>1<br>2、 Source File Path: 加载程序代码 存放的路径（注意切回發佈版本的代碼）</p><p>D:/Project/Demo/<br>1<br>3、Image File Path: 加載exe 存放的路徑</p><p>D:/Project/DumTools/<br>1<br>4、選擇Open Crash Dump 導入生成的dmp文件</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><blockquote><ul><li>用于崩溃调试的dump、pdb、源码需要是同一个版本，一般为发布版本（即客户版本）</li><li>用于崩溃调试的dump、pdb、源码需要区分debug和release否则无法调试</li></ul></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ol><li><a href="https://blog.csdn.net/LiHong333/article/details/129798322?spm=1001.2014.3001.5502">Qt-mingw 生成dump文件并使用vs调试定位错误代码_qt生成dump文件</a></li><li><a href="https://libaineu2004.blog.csdn.net/article/details/108310384?spm=1001.2014.3001.5502">Qt如何在Release编译下怎么调试？怎么生成pdb文件</a></li><li><a href="https://blog.csdn.net/HeroGuo_JP/article/details/105383752"> Window端Qt Create dmp的生成与解析</a></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;最近因为维护的项目出现崩溃，客户现场的log无法定位，因此需要使用dump文件调试于是查找资料添加了一个崩溃生成d</summary>
      
    
    
    
    <category term="Qt" scheme="https://ouyujia.github.io/categories/Qt/"/>
    
    
    <category term="QT" scheme="https://ouyujia.github.io/tags/QT/"/>
    
    <category term="MingW" scheme="https://ouyujia.github.io/tags/MingW/"/>
    
    <category term="Dump" scheme="https://ouyujia.github.io/tags/Dump/"/>
    
  </entry>
  
  <entry>
    <title>QT数据库</title>
    <link href="https://ouyujia.github.io/2022/05/28/QT%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://ouyujia.github.io/2022/05/28/QT%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2022-05-28T11:54:44.000Z</published>
    <updated>2023-04-28T05:56:04.358Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>QT模型/视图</title>
    <link href="https://ouyujia.github.io/2022/05/28/QT%E6%A8%A1%E5%9E%8B-%E8%A7%86%E5%9B%BE/"/>
    <id>https://ouyujia.github.io/2022/05/28/QT%E6%A8%A1%E5%9E%8B-%E8%A7%86%E5%9B%BE/</id>
    <published>2022-05-28T11:54:22.000Z</published>
    <updated>2023-04-28T05:56:04.359Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>QT样式基类</title>
    <link href="https://ouyujia.github.io/2022/05/28/QT%E6%A0%B7%E5%BC%8F%E5%9F%BA%E7%B1%BB/"/>
    <id>https://ouyujia.github.io/2022/05/28/QT%E6%A0%B7%E5%BC%8F%E5%9F%BA%E7%B1%BB/</id>
    <published>2022-05-28T11:53:44.000Z</published>
    <updated>2023-04-28T05:56:04.359Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>QT自定义部件</title>
    <link href="https://ouyujia.github.io/2022/05/28/QT%E8%87%AA%E5%AE%9A%E4%B9%89%E9%83%A8%E4%BB%B6/"/>
    <id>https://ouyujia.github.io/2022/05/28/QT%E8%87%AA%E5%AE%9A%E4%B9%89%E9%83%A8%E4%BB%B6/</id>
    <published>2022-05-28T11:53:20.000Z</published>
    <updated>2023-04-28T05:56:04.360Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>QT绘图</title>
    <link href="https://ouyujia.github.io/2022/05/28/QT%E7%BB%98%E5%9B%BE/"/>
    <id>https://ouyujia.github.io/2022/05/28/QT%E7%BB%98%E5%9B%BE/</id>
    <published>2022-05-28T11:52:52.000Z</published>
    <updated>2023-04-28T05:56:04.359Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>QT串口通讯</title>
    <link href="https://ouyujia.github.io/2022/05/28/QT%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF/"/>
    <id>https://ouyujia.github.io/2022/05/28/QT%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF/</id>
    <published>2022-05-28T11:52:29.000Z</published>
    <updated>2023-04-28T05:56:04.357Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>QT网络通讯</title>
    <link href="https://ouyujia.github.io/2022/05/28/QT%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/"/>
    <id>https://ouyujia.github.io/2022/05/28/QT%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/</id>
    <published>2022-05-28T11:52:10.000Z</published>
    <updated>2023-04-28T05:56:04.360Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>QT线程</title>
    <link href="https://ouyujia.github.io/2022/05/28/QT%E7%BA%BF%E7%A8%8B/"/>
    <id>https://ouyujia.github.io/2022/05/28/QT%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-05-28T11:51:49.000Z</published>
    <updated>2023-04-28T05:56:04.359Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>QT部件基类</title>
    <link href="https://ouyujia.github.io/2022/05/28/QT%E9%83%A8%E4%BB%B6%E5%9F%BA%E7%B1%BB/"/>
    <id>https://ouyujia.github.io/2022/05/28/QT%E9%83%A8%E4%BB%B6%E5%9F%BA%E7%B1%BB/</id>
    <published>2022-05-28T11:51:29.000Z</published>
    <updated>2023-04-28T05:56:04.360Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>QT对象基类</title>
    <link href="https://ouyujia.github.io/2022/05/28/QT%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%B1%BB/"/>
    <id>https://ouyujia.github.io/2022/05/28/QT%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%B1%BB/</id>
    <published>2022-05-28T11:50:59.000Z</published>
    <updated>2023-04-28T05:56:04.358Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>QT事件</title>
    <link href="https://ouyujia.github.io/2022/05/28/QT%E4%BA%8B%E4%BB%B6/"/>
    <id>https://ouyujia.github.io/2022/05/28/QT%E4%BA%8B%E4%BB%B6/</id>
    <published>2022-05-28T11:50:04.000Z</published>
    <updated>2023-04-28T05:56:04.358Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>空悬指针和野指针</title>
    <link href="https://ouyujia.github.io/2022/05/09/%E7%A9%BA%E6%82%AC%E6%8C%87%E9%92%88%E5%92%8C%E9%87%8E%E6%8C%87%E9%92%88/"/>
    <id>https://ouyujia.github.io/2022/05/09/%E7%A9%BA%E6%82%AC%E6%8C%87%E9%92%88%E5%92%8C%E9%87%8E%E6%8C%87%E9%92%88/</id>
    <published>2022-05-09T11:03:39.000Z</published>
    <updated>2023-04-28T05:56:04.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="空悬指针"><a href="#空悬指针" class="headerlink" title="空悬指针"></a>空悬指针</h2><p>简单地说，空悬指针是对象的指针的生存周期比对象更长所导致的，也就是说，<font color="orange"><code>对象销毁、删除了，不存在了，指针仍然存在，这时这个指针就成了空悬指针。</code></font><br>当对象被析构、删除时，如果指向它的指针没有被同时修改，那么指针仍然会指向那块内存（但是那块内存已经没有东西了）。系统此时可能会重新分配这块已经free掉的内存。<font color="red"><code>如果程序再通过这个指针读这块内存，就可能会有不可预见的事情发生，因为这块内存可能被分配了完全不同的内容。</code></font>如果程序此时要写这块内存，就可能会造成数据污染，进而可能带来超级难被发现的bug。<font color="red"><code>如果内存已经被其它进程重新分配，此时再去访问指针指向的内容，就可能会发生片段错误(UNIX,Linux)或者一般性保护错误(Windows).如果程序有足够的权限去重写内核内存分配器的内容，还可能造成系统的不稳定。</code></font>在有垃圾回收机制的面向对象语言中，阻止空悬引用的方法是销毁所有访问不到的对象，也就是说他们也就没有所谓的指针了，这是由追踪或引用计数而确保的。然而finalizer可能会创建新的对象的引用，这就要求对象要再生来防止空悬引用。</p><p>以下举例说明空悬指针：</p><p>例1</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">   <span class="type">char</span> *dp = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="comment">/* ... */</span></span><br><span class="line">   {</span><br><span class="line">       <span class="type">char</span> c; <span class="comment">//出了作用域系统自动销毁局部变量</span></span><br><span class="line">       dp = &amp;c;</span><br><span class="line">   }  </span><br><span class="line"><span class="comment">//到这里，c已经被销毁了，dp就变成了空悬指针(dp没有修改其指向正确的地址，它依然指向c的指针，但c的地址已不属于本程序)</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>例2</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">test_array</span><span class="params">(<span class="type">int</span> *a)</span></span>{</span><br><span class="line"><span class="type">int</span> length = <span class="built_in">sizeof</span>(a)/<span class="built_in">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"><span class="type">int</span> *b = <span class="keyword">new</span> <span class="type">int</span> [length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">{</span><br><span class="line">*b++=a[i];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="type">int</span> a [<span class="number">5</span>] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line"><span class="type">int</span> *b = <span class="built_in">test_array</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">{</span><br><span class="line">cout&lt;&lt;b[i]&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">51</span></span><br></pre></td></tr></tbody></table></figure><p>就像这样，因为虽然返回了一个指针，但是这个指针指向的对象在函数返回时已经销毁了，因此返回的值是不确定的。如果接下来还想用，那么得用引用的方法传参。</p><p>消除空悬指针的方式</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span> *dp = <span class="built_in">malloc</span>(A_CONST);</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="built_in">free</span>(dp);         <span class="comment">/* dp 现在是空悬指针 */</span></span><br><span class="line">    dp = <span class="literal">NULL</span>;        <span class="comment">/* dp 不再是空悬指针*/</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>注意：</p><blockquote><p>悬浮指针所指向的内存不属于当前程序，但是因为知道内存的指针，当前程序还是可以追寻到这块地址并修改它的值，如果操作系统没有将这块内存分配给其他程序，当前系统对该内存的操作不会出现问题（严禁这么做，因为你不知道什么时候操作系统会将这块内存分配给其他程序），如果操作系统已经将这块内存分配给其他程序，此时当前程序通过指针对这块内存进行操作就可能会发生片段错误(UNIX,Linux)或者一般性保护错误(Windows)。</p></blockquote><p>下面是一段简单的测试代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//悬浮指针， 野指针的一种，使用后结果不可控，非常危险</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* int_pointer = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"赋值前地址:"</span> &lt;&lt; int_pointer;</span><br><span class="line">    *int_pointer = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"赋值后地址:"</span> &lt;&lt; int_pointer;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"delete前值:"</span> &lt;&lt; *int_pointer;</span><br><span class="line">    <span class="keyword">delete</span> int_pointer;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"delete后值:"</span> &lt;&lt; *int_pointer;</span><br><span class="line"><span class="comment">//    int * int_pointer_second = int_pointer;</span></span><br><span class="line">    <span class="type">double</span> * double_pointer = (<span class="type">double</span>*) int_pointer;</span><br><span class="line">    *double_pointer = <span class="number">8.4</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"delete后地址:"</span> &lt;&lt; int_pointer;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"double delete后地址:"</span> &lt;&lt; double_pointer;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"int delete后值1:"</span> &lt;&lt; *int_pointer; <span class="comment">//此时变量被double值占用，输出为垃圾值（-858993459）</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"double delete后值1:"</span> &lt;&lt; *double_pointer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    *int_pointer = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"double delete后值2:"</span> &lt;&lt; *double_pointer;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"delete后赋值2:"</span> &lt;&lt; *int_pointer;</span><br><span class="line">    int_pointer = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"nullptr后地址:"</span> &lt;&lt; int_pointer;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">"nullptr后地址double:"</span> &lt;&lt; double_pointer;</span><br><span class="line"><span class="comment">//    qDebug() &lt;&lt; "nullptr后值:" &lt;&lt; *int_pointer; //报错 无法操作空指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">赋值前地址: <span class="number">0x35dc900</span></span><br><span class="line">赋值后地址: <span class="number">0x35dc900</span></span><br><span class="line"><span class="keyword">delete</span>前值: <span class="number">5</span></span><br><span class="line"><span class="keyword">delete</span>后值: <span class="number">5</span></span><br><span class="line"><span class="keyword">delete</span>后地址: <span class="number">0x35dc900</span></span><br><span class="line"><span class="type">double</span> <span class="keyword">delete</span>后地址: <span class="number">0x35dc900</span></span><br><span class="line"><span class="type">int</span> <span class="keyword">delete</span>后值<span class="number">1</span>: <span class="number">-858993459</span></span><br><span class="line"><span class="type">double</span> <span class="keyword">delete</span>后值<span class="number">1</span>: <span class="number">8.4</span></span><br><span class="line"><span class="type">double</span> <span class="keyword">delete</span>后值<span class="number">2</span>: <span class="number">8.39999</span></span><br><span class="line"><span class="keyword">delete</span>后赋值<span class="number">2</span>: <span class="number">9</span></span><br><span class="line"><span class="literal">nullptr</span>后地址: <span class="number">0x0</span></span><br><span class="line"><span class="literal">nullptr</span>后地址<span class="type">double</span>: <span class="number">0x35dc900</span></span><br></pre></td></tr></tbody></table></figure><h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><p><font color="orange"><code>野指针作为一个指针，甚至都没有被初始化，也就是说虽然它的类型是一个指针，但它根本没有值。</code></font>它跟NULL指针还有差别，NULL是指向了0地址，而野指针是没有地址。也就相当于，int a=0;和int a;的区别。野指针非常危险，往往会引起程序奔溃。</p><p>举例说明：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span> *dp;<span class="comment">//野指针，没有初始化</span></span><br><span class="line">    <span class="comment">//定义一个测试类testClass，包含一个成员函数void show();</span></span><br><span class="line">    testClass * test; <span class="comment">//野指针，没有初始化</span></span><br><span class="line">    test.<span class="built_in">show</span>(); <span class="comment">//系统将奔溃</span></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> *sdp; <span class="comment">//非野指针，因为静态变量会默认初始化为0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">C++空悬指针和野指针浅谈</summary>
    
    
    
    <category term="C++" scheme="https://ouyujia.github.io/categories/C/"/>
    
    <category term="指针" scheme="https://ouyujia.github.io/categories/C/%E6%8C%87%E9%92%88/"/>
    
    
    <category term="C++" scheme="https://ouyujia.github.io/tags/C/"/>
    
    <category term="指针" scheme="https://ouyujia.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>可调用对象包装器、绑定器</title>
    <link href="https://ouyujia.github.io/2022/05/09/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8%E3%80%81%E7%BB%91%E5%AE%9A%E5%99%A8/"/>
    <id>https://ouyujia.github.io/2022/05/09/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8%E3%80%81%E7%BB%91%E5%AE%9A%E5%99%A8/</id>
    <published>2022-05-09T07:07:51.000Z</published>
    <updated>2023-04-28T05:56:04.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h2><p>在 C++ 中存在 “可调用对象” 这么一个概念。准确来说，可调用对象有如下几种定义：</p><ul><li><font color="orange"><code>是一个函数指针</code></font></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 定义函数指针</span></span><br><span class="line"><span class="built_in">int</span> (*func)(<span class="type">int</span>, <span class="type">double</span>) = &amp;print</span><br></pre></td></tr></tbody></table></figure><ul><li><font color="orange"><code>是一个具有operator()成员函数的类对象（仿函数，即重载()运算符）</code></font></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// ()操作符重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string msg)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"msg: "</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="built_in">t</span>(<span class="string">"我是要成为海贼王的男人!!!"</span>);<span class="comment">// 仿函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><font color="orange"><code>是一个可被转换为函数指针的类对象</code></font></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>, string);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, string b)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"name: "</span> &lt;&lt; b &lt;&lt; <span class="string">", age: "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将类对象转换为函数指针</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">func_ptr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> print; <span class="comment">//只能是类的静态成员函数，因为类的静态成员函数类定义时就存在，而类的普通成员函数只有函数实例对象后才存在.</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="comment">// 对象转换为函数指针, 并调用</span></span><br><span class="line">    <span class="built_in">t</span>(<span class="number">19</span>, <span class="string">"Monkey D. Luffy"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><font color="orange"><code>是一个类成员函数指针或者类成员指针</code></font></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, string b)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"name: "</span> &lt;&lt; b &lt;&lt; <span class="string">", age: "</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 定义类成员函数指针指向类成员函数</span></span><br><span class="line">    <span class="built_in">void</span> (Test::*func_ptr)(<span class="type">int</span>, string) = &amp;Test::print;</span><br><span class="line">    <span class="comment">// 类成员指针指向类成员变量</span></span><br><span class="line">    <span class="type">int</span> Test::*obj_ptr = &amp;Test::m_num;</span><br><span class="line"></span><br><span class="line">    Test t;</span><br><span class="line">    <span class="comment">// 通过类成员函数指针调用类成员函数</span></span><br><span class="line">    (t.*func_ptr)(<span class="number">19</span>, <span class="string">"Monkey D. Luffy"</span>);</span><br><span class="line">    <span class="comment">// 通过类成员指针初始化类成员变量</span></span><br><span class="line">    t.*obj_ptr = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"number is: "</span> &lt;&lt; t.m_num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上面的例子中满足条件的这些可调用对象对应的类型被统称为<font color="red"><code>可调用类型</code></font>。C++ 中的可调用类型虽然具有比较统一的操作形式，但定义方式五花八门，这样在我们试图使用统一的方式保存，或者传递一个可调用对象时会十分繁琐。现在，<font color="orange"><code>C++11通过提供std::function 和 std::bind统一了可调用对象的各种操作。</code></font></p><h2 id="可调用对象包装器"><a href="#可调用对象包装器" class="headerlink" title="可调用对象包装器"></a>可调用对象包装器</h2><p><font color="orange"><code>std::function是可调用对象的包装器。它是一个类模板，可以容纳除了类成员（函数）指针之外的所有可调用对象。通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们。</code></font></p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>std::function 必须要包含一个叫做 <font color="orange"><code>functional</code> </font>的头文件，可调用对象包装器使用语法如下:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line">std::function&lt;返回值类型(参数类型列表)&gt; diy_name = 可调用对象;</span><br></pre></td></tr></tbody></table></figure><p>下面的实例代码中演示了可调用对象包装器的基本使用方法：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">" + "</span> &lt;&lt; b &lt;&lt; <span class="string">" = "</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">" - "</span> &lt;&lt; b &lt;&lt; <span class="string">" = "</span> &lt;&lt; a - b &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">" * "</span> &lt;&lt; b &lt;&lt; <span class="string">" = "</span> &lt;&lt; a * b &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 绑定一个普通函数</span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f1 = add;</span><br><span class="line">    <span class="comment">// 绑定以静态类成员函数</span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f2 = T1::sub;</span><br><span class="line">    <span class="comment">// 绑定一个仿函数</span></span><br><span class="line">    T2 t;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f3 = t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">f2</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">f3</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输入结果如下:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> + <span class="number">3</span> = <span class="number">12</span></span><br><span class="line"><span class="number">9</span> - <span class="number">3</span> = <span class="number">6</span></span><br><span class="line"><span class="number">9</span> * <span class="number">3</span> = <span class="number">27</span></span><br></pre></td></tr></tbody></table></figure><p><font color="red"><code>通过测试代码可以得到结论：std::function 可以将可调用对象进行包装，得到一个统一的格式，包装完成得到的对象相当于一个函数指针，和函数指针的使用方式相同，通过包装器对象就可以完成对包装的函数的调用了。</code></font></p><h3 id="作为回调函数使用"><a href="#作为回调函数使用" class="headerlink" title="作为回调函数使用"></a>作为回调函数使用</h3><p>因为回调函数本身就是通过函数指针实现的，<font color="orange"><code>使用对象包装器可以取代函数指针的作用</code></font>，来看一下下面的例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数参数是一个包装器对象</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> function&lt;<span class="built_in">void</span>()&gt;&amp; f) : <span class="built_in">callback</span>(f)</span><br><span class="line">    {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">callback</span>(); <span class="comment">// 调用通过构造函数得到的函数指针</span></span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    function&lt;<span class="type">void</span>()&gt; callback;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"我是要成为海贼王的男人!!!"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    B b;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(b)</span></span>; <span class="comment">// 仿函数通过包装器对象进行包装</span></span><br><span class="line">    a.<span class="built_in">notify</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过上面的例子可以看出，使用对象包装器 std::function 可以非常方便的将仿函数转换为一个函数指针，通过进行函数指针的传递，在其他函数的合适的位置就可以调用这个包装好的仿函数了。</p><p>另外，使用 std::function 作为函数的传入参数，可以将定义方式不相同的可调用对象进行统一的传递，这样大大增加了程序的灵活性。</p><h2 id="绑定器"><a href="#绑定器" class="headerlink" title="绑定器"></a>绑定器</h2><p><font color="orange"><code>std::bind用来将可调用对象与其参数一起进行绑定。绑定后的结果可以使用std::function进行保存，并延迟调用到任何我们需要的时候。</code></font>通俗来讲，它主要有两大作用：</p><ol><li><font color="orange"><code>将可调用对象与其参数一起绑定成一个仿函数。</code></font></li><li><font color="orange"><code>将多元（参数个数为n，n&gt;1）可调用对象转换为一元或者（n-1）元可调用对象，即只绑定部分参数。</code></font></li></ol><p>绑定器函数使用语法格式如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定非类成员函数/变量</span></span><br><span class="line"><span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(可调用对象地址, 绑定的参数/占位符);</span><br><span class="line"><span class="comment">// 绑定类成员函/变量</span></span><br><span class="line"><span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(类函数/成员地址, 类实例对象地址, 绑定的参数/占位符);</span><br></pre></td></tr></tbody></table></figure><p>下面来看一个关于绑定器的实际使用的例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callFunc</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;&amp; f)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">f</span>(x);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_add</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; x + <span class="number">10</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 使用绑定器绑定可调用对象和参数</span></span><br><span class="line">    <span class="keyword">auto</span> f1 = <span class="built_in">bind</span>(output, placeholders::_1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">callFunc</span>(i, f1);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f2 = <span class="built_in">bind</span>(output_add, placeholders::_1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">callFunc</span>(i, f2);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试代码输出的结果:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="number">10</span> <span class="number">12</span> <span class="number">14</span> <span class="number">16</span> <span class="number">18</span></span><br></pre></td></tr></tbody></table></figure><p>在上面的程序中，使用了 std::bind 绑定器，在函数外部通过绑定不同的函数，控制了最后执行的结果。<font color="orange"><code>std::bind绑定器返回的是一个仿函数类型，得到的返回值可以直接赋值给一个std::function，在使用的时候我们并不需要关心绑定器的返回值类型，使用auto进行自动类型推导就可以了。</code></font></p><p><font color="orange">placeholders::_1</font> 是一个占位符，代表这个位置将在函数调用时被传入的第一个参数所替代。同样还有其他的占位符 <font color="orange">placeholders::_2</font> 、<font color="orange">placeholders::_3</font> 、<font color="orange">placeholders::_4</font> 、<font color="orange">placeholders::_5</font>  等……</p><p>有了占位符的概念之后，使得 std::bind 的使用变得非常灵活:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 使用绑定器绑定可调用对象和参数, 并调用得到的仿函数</span></span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">1</span>, <span class="number">2</span>)();</span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_1, <span class="number">2</span>)(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">2</span>, placeholders::_1)(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// error, 调用时没有第二个参数</span></span><br><span class="line">    <span class="comment">// bind(output, 2, placeholders::_2)(10);</span></span><br><span class="line">    <span class="comment">// 调用时第一个参数10被吞掉了，没有被使用</span></span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">2</span>, placeholders::_2)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_1, placeholders::_2)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_2, placeholders::_1)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>示例代码执行的结果:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="number">2</span><span class="comment">// bind(output, 1, 2)();</span></span><br><span class="line"><span class="number">10</span> <span class="number">2</span><span class="comment">// bind(output, placeholders::_1, 2)(10);</span></span><br><span class="line"><span class="number">2</span> <span class="number">10</span><span class="comment">// bind(output, 2, placeholders::_1)(10);</span></span><br><span class="line"><span class="number">2</span> <span class="number">20</span><span class="comment">// bind(output, 2, placeholders::_2)(10, 20);</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span><span class="comment">// bind(output, placeholders::_1, placeholders::_2)(10, 20);</span></span><br><span class="line"><span class="number">20</span> <span class="number">10</span><span class="comment">// bind(output, placeholders::_2, placeholders::_1)(10, 20);</span></span><br></pre></td></tr></tbody></table></figure><p>通过测试可以看到，std::bind 可以直接绑定函数的所有参数，也可以仅绑定部分参数。在绑定部分参数的时候，通过使用 std::placeholders 来决定空位参数将会属于调用发生时的第几个参数。</p><p>可调用对象包装器 std::function 是不能实现对类成员函数指针或者类成员指针的包装的，但是通过绑定器 std::bind 的配合之后，就可以完美的解决这个问题了，再来看一个例子，然后再解释里边的细节：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"x: "</span> &lt;&lt; x &lt;&lt; <span class="string">", y: "</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> m_number = <span class="number">100</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="comment">// 绑定类成员函数</span></span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f1 = </span><br><span class="line">        <span class="built_in">bind</span>(&amp;Test::output, &amp;t, placeholders::_1, placeholders::_2);</span><br><span class="line">    <span class="comment">// 绑定类成员变量(公共)</span></span><br><span class="line">    function&lt;<span class="type">int</span>&amp;(<span class="type">void</span>)&gt; f2 = <span class="built_in">bind</span>(&amp;Test::m_number, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用</span></span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">520</span>, <span class="number">1314</span>);</span><br><span class="line">    <span class="built_in">f2</span>() = <span class="number">2333</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"t.m_number: "</span> &lt;&lt; t.m_number &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>示例代码输出的结果:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x: <span class="number">520</span>, y: <span class="number">1314</span></span><br><span class="line">t.m_number: <span class="number">2333</span></span><br></pre></td></tr></tbody></table></figure><p>在用绑定器绑定类成员函数或者成员变量的时候需要将它们所属的实例对象一并传递到绑定器函数内部。<font color="orange"><code>f1的类型是function&lt;void(int, int)&gt;，通过使用std::bind将Test的成员函数output的地址和对象t绑定，并转化为一个仿函数并存储到对象f1中。</code></font></p><p><font color="orange"><code>使用绑定器绑定的类成员变量m_number得到的仿函数被存储到了类型为function&lt;int&amp;(void)&gt;的包装器对象f2中，并且可以在需要的时候修改这个成员。其中int是绑定的类成员的类型，并且允许修改绑定的变量，因此需要指定为变量的引用，由于没有参数因此参数列表指定为void。</code></font></p><p>示例程序中是使用 function 包装器保存了 bind 返回的仿函数，如果不知道包装器的模板类型如何指定，可以直接使用 auto 进行类型的自动推导，这样使用起来会更容易一些。</p>]]></content>
    
    
    <summary type="html">C++11新特性</summary>
    
    
    
    <category term="C++" scheme="https://ouyujia.github.io/categories/C/"/>
    
    <category term="C++11" scheme="https://ouyujia.github.io/categories/C/C-11/"/>
    
    
    <category term="C++11新特性" scheme="https://ouyujia.github.io/tags/C-11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    <category term="指针" scheme="https://ouyujia.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
    <category term="可调用对象" scheme="https://ouyujia.github.io/tags/%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>QSS入门</title>
    <link href="https://ouyujia.github.io/2022/05/07/QSS%E5%85%A5%E9%97%A8/"/>
    <id>https://ouyujia.github.io/2022/05/07/QSS%E5%85%A5%E9%97%A8/</id>
    <published>2022-05-07T03:26:07.000Z</published>
    <updated>2023-04-28T05:56:04.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>为了书写方便, 文中一律使用 Qss 代替 Qt style sheet。</p><p>首先来看 Qt 的官方介绍: 除了子类化 QStyle 以外, Qss 是一个非常强大的用于自定义控件外观的机制. 它的概念,术语以及语法都是受到了 HTML CSS 的启发(实际上就是 CSS 的语法), 但可以适应全局窗口部件(这一句我没明白是什么意思)。</p><p>就是说, Qss 是用来设置界面样式的, 设置的方法就是类似于 CSS,通过以一定规则组织的字符串来给界面设置样式, 而不用我们调用控件对象的接口或子类化 QStyle 去设置样式. 这种组织字符串的规则就是它的语法, 下的总结也是主要讲一些 Qss 的语法, 包含少量的经验以及官方文档中没有说明的内容.</p><p>个人认为使用 Qss 的好处:</p><p>(1) 可读性高并且非常直观,便于设置界面样式;</p><p>(2) 在每个平台上都有相同的显示效果. </p><p>(3) 可以在界面代码中省去与显示效果相关的大量代码,将界面逻辑独立出来. </p><p>(4) 在界面风格(配色, 字体等)改变的情况下, 可以不用修改 c++源码就可以实现.</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>样式表由一系列的样式规则组成。一条样式规则由一个<font color="orange"><code>选择器</code></font>和一个<font color="orange"><code>声明语句</code></font>组成，<font color="orange"><code>选择器指明了哪个（或者说是哪种）控件将会受规则影响，而声明语句则指明了哪些属性会设置到这个（这些）控件</code></font>. </p><p>语法如下:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selector { attribute: value; } </span><br></pre></td></tr></tbody></table></figure><blockquote><p>在上面这条语句中, selector 代表选择器, 指明了哪个(或者说是哪种)控件将会受到规则影响.</p><p>{attribute: value;}代表声明语句, 其中 attribute 表示属性, value 表示该属性的值, 属性与它的值之间必须以冒号( : )隔开, 属性值后面必须以分号( ; )结束,表示这条属性已经设置完成. 整条语句加起来的意思是, 在整个应用程序中, 被 selector匹配的控件, 它们控件的 attribute 属性的值应该被设置为 value.</p></blockquote><p>例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPushButton{ <span class="attribute">color</span>: red;}</span><br></pre></td></tr></tbody></table></figure><p>表示将我们的应用程序中所有的 QPushbutton 对象以及它的子类对象应该使用 red 作为它们的前景色(即字体的颜色);由此看来, 我们要学会如何使用 qss 来控制我们的界面样式, 只需要学会两个方面的内容, 即选择器和属性, 下面将用专门的章节来讲解这两部分的内容.</p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="通用选择器"><a href="#通用选择器" class="headerlink" title="通用选择器"></a>通用选择器</h4><p>又叫通配符选择器</p><h5 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* { 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>通用选择器用( * )来表示, 它表示匹配程序中所有的 widget.</p><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><blockquote><p><font color="cornflowerblue">由于通用选择器会匹配程序中所有的 widgets, 效率较低, 因此应该尽量减少或者不使用</font></p></blockquote><h5 id="一般用法"><a href="#一般用法" class="headerlink" title="一般用法"></a>一般用法</h5><p>通用选择器一般用来给应用程序设置统一的字体,例如</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*{<span class="attribute">font</span>: normal <span class="number">20px</span> “微软雅黑”;}</span><br></pre></td></tr></tbody></table></figure><p>这条语句表示将程序中所有 widget 的字体大小都设置为 20px 大小, 字体采用微软雅黑.</p><h4 id="类型选择器"><a href="#类型选择器" class="headerlink" title="类型选择器"></a>类型选择器</h4><h5 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 { 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>类名即 Widget 类名, 由 QObject :: metaObject() :: className()获取, 类型选择器匹配所有该类以及该类的派生类的对象.</p><p>例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QPushButton{ </span><br><span class="line"><span class="attribute">color</span>: blue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这条语句表示, 程序中<font color="orange"><code>所有的 QPushButton 类和它的派生类的对象, 它们的前景色(即文字颜色)被设置为蓝色.</code></font></p><h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><p>Qt 样式表使用 widget 的 <font color="orange"><code>QObject::className()</code></font>来决定何时应用<font color="orange"><code>类型选择器</code></font>。当<font color="red"><code>自定义控件在命名空间之中</code></font>(或它是一个嵌套类)，<font color="red">QObject::className()会返回( :: )</font>, 这与后面介绍的子控件选择器相冲突. 为了解决这个问题，当为命名空间中 widget 使用类型选择器时, 我们必须将<font color="orange"><code>” :: ”</code></font>替换成<font color="orange"><code>” -- ”</code></font>, 下面即将介绍的类选择器也是一样. </p><p>例子如下:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ns {</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">MyPushButton</span> : <span class="keyword">public</span> QPushButton {</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> } </span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">qApp-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">"ns--MyPushButton { background: yellow; }"</span>);</span><br></pre></td></tr></tbody></table></figure><h5 id="一般用法-1"><a href="#一般用法-1" class="headerlink" title="一般用法"></a><strong>一般用法</strong></h5><p>类型选择器会匹配<font color="orange"><code>所有该类以及该类的派生类的对象</code></font>, 所以我们在程序中, 有时为了统一具有相似性的控件的样式, 可以使用类型选择器, 如, 我们想要为 <font color="orange">QSpinBox</font>,<font color="orange">QDoubleSpinBox</font>, <font color="orange">QDateTimeEdit</font>, <font color="orange">QTimeEdit</font>, <font color="orange">QDateEdit</font> 等这些编辑框的控件设置一些相同的样式, 因为它们都是 <font color="orange">QAbstractSpinBox 类的派生类</font>, 因此可以如下写:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QAbstractSpinBox{</span><br><span class="line"><span class="attribute">min-height</span>: <span class="number">30px</span>;</span><br><span class="line"><span class="attribute">max-height</span>: <span class="number">30px</span>;</span><br><span class="line"><span class="attribute">border-width</span>: <span class="number">1px</span>;</span><br><span class="line">rder-style: solid;</span><br><span class="line"><span class="attribute">order</span>-<span class="attribute">color</span>: gray; </span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0px</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a><strong>类选择器</strong></h4><h5 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.类名 { 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>这里的类名与类型选择器中的类名一样, 不同的是, 类选择器的类名前面有一个( . ), 这种选择器<font color="red"><code>只会匹配该类的所有对象, 而不会匹配其派生类的对象.</code></font> </p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.QPushButton</span>{ </span><br><span class="line"><span class="attribute">color</span>: blue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="一般用法-2"><a href="#一般用法-2" class="headerlink" title="一般用法"></a><strong>一般用法</strong></h5><p>类选择器提供了一种<font color="orange"><code>匹配所有该类的对象但不会匹配派生类的方法</code></font>, 通常用来特例化拥有派生类的类对象, 但不仅限于此.例如在在我的应用程序中, 我用 QFrame 来作为容器 widget,此时我想对它设置一些样式, 但又不想影响它的子类对象(QLabel, QAbstractScrollArea 等等),那么我可以使用类选择器给所有的 QFrame 设置相同的样式 . </p><p>例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.QFrame</span>{</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">25px</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="ID-选择器"><a href="#ID-选择器" class="headerlink" title="ID 选择器"></a><strong>ID</strong> <strong>选择器</strong></h4><h5 id="格式-3"><a href="#格式-3" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#id</span>{ 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>这里的 id 指的是 objectName, 每个 QObject 类及其派生类都有的一个属性, “#” + objectName构成了我们的 ID 选择器, <font color="orange"><code>它匹配所有 objectName 为 ID 选择器所指定的名称的对象</code></font>, 为其设置样式. </p><p>例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#button_1</span>{</span><br><span class="line"> <span class="attribute">color</span>: red; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a><strong>注意点</strong></h5><ol><li><p>objectName 是大小写敏感的.</p></li><li><p>“#”与 ID 之间不可以有空格</p></li><li><p>由于 objectName 是所有 QObject 类对象的一个属性, 在运行过程中可以改变, 所以一般情况下, 要使用 ID 选择器时,<font color="orange"> <code>保证 objectName 不要在运行时被改变, 否则重新加载stylesheet 文件时, 对应的 ID 选择器将不会匹配到原来的控件.</code></font></p></li><li><p>由于 objectName 允许字符串中含有空格, 但是 ID 选择器中,<font color="orange"> <code>ID 是从紧跟#后的第一个字符开始直到遇到空格或“{”之间的字符串, 因此, 如果是为了使用 ID 选择器而设置objectName, 则 objectName 中不能含有空格</code></font></p></li><li><p><font color="orange"><code>由于任何对象的 objectName 都可以出现重复, 因此在设置 objectName 时, 尽量保持其唯一性</code></font></p></li><li><p>Qt 官方给出的 ID 选择器的格式为:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名<span class="selector-id">#id</span>{ 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>但实际上不加类名也是可以的(加了类名的 ID 选择器在 CSS 中被称为交集选择器),在正式开发中, 还是<font color="orange"><code>建议加上类名, 因为这样可以看出这个 id 选择器所匹配的对象的类型,有利于提高阅读性.</code></font>基于以上特点, 我们在设置 objectName 时, 一般使用下划线”_”连接的多个单词表明此对象的功能.</p></li></ol><h5 id="一般用法-3"><a href="#一般用法-3" class="headerlink" title="一般用法"></a><strong>一般用法</strong></h5><p>ID 选择器一般用于为比较特殊的控件设置样式, 例如在我的某个页面中, 需要突出一个重要的按钮, 那么此时我可以给这个按钮设置一个独特的样式用以提醒用户, 如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-id">#settings_popup_fileDialog_button</span>{</span><br><span class="line"></span><br><span class="line"> <span class="attribute">min-height</span>: <span class="number">31px</span>;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">min-width</span>: <span class="number">70px</span>;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">color</span>: <span class="number">#F0F0F0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">min-height</span>: <span class="number">10px</span>;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">border-radius</span>:<span class="number">3px</span>;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">background</span>: <span class="built_in">qlineargradient</span>(spread:pad, x1:<span class="number">0</span>, y1:<span class="number">0</span>, x2:<span class="number">0</span>, y2:<span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">stop:<span class="number">0</span> <span class="number">#454648</span>, stop:<span class="number">1</span> <span class="number">#7A7A7A</span>); </span><br><span class="line"></span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h4 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a><strong>后代选择器</strong></h4><h5 id="格式-4"><a href="#格式-4" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器<span class="number">1</span> 选择器<span class="number">2</span>{ 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>这个选择器表示: <font color="orange"><code>在选择器 1 匹配的所有对象中, 找到选择器 2 所匹配的所有后代对象, 并给它们设置样式.</code></font></p><h5 id="注意点-3"><a href="#注意点-3" class="headerlink" title="注意点"></a><strong>注意点</strong></h5><ol><li>后代选择器必须用空格隔开每个选择器</li><li><font color="orange"><code>后代选择器可以通过空格一直延续下去</code></font>, 例如:选择器 1 选择器 2 选择器 3 … 选择器 N{ 属性: 值; }</li><li><font color="red"><code>顾名思义, 后代选择器不仅包含”儿子”, 还包含”孙子”, “重孙子”等, 一般来说, 只要 B 控件显示在 A 控件上, 那么 B 控件就是 A 控件的后代.</code></font></li><li>后代选择器不仅可以使用类型选择器, 还可以使用类选择器, id 选择器以及后面提及的属性选择器等.</li><li>Qt 中, 各控件的父子关系:通过简单的验证, 各控件的父子关系并非我们在创建对象时所指定的那样, <font color="orange"><code>实际父子关系取决于如何布局.</code> </font></li></ol><h5 id="一般用法-4"><a href="#一般用法-4" class="headerlink" title="一般用法"></a><strong>一般用法</strong></h5><p>后代选择器一般用于指定特定类的后代的样式, 例如在我的应用程序中, 有很多个相似的对话框, 它们中包含一些样式相同的按钮, 那么我可以使用后代选择器为他们指定样式, 例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BaseDialog QPushButton{</span><br><span class="line"><span class="attribute">min-width</span>: <span class="number">120px</span>;</span><br><span class="line"><span class="attribute">min-height</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">max-width</span>: <span class="number">120px</span>;</span><br><span class="line"><span class="attribute">max-height</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0px</span>; </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h4 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a><strong>子元素选择器</strong></h4><h5 id="格式-5"><a href="#格式-5" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器<span class="number">1</span> &gt;选择器<span class="number">2</span> { 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>子元素选择器表示找到指定选择器所匹配的对象中的所有特定直接子元素然后设置属性, </p><p>即找到选择器 1 匹配到的对象中的被选择器 2 匹配盗的直接子元素然后设置属性</p><p><strong>注意点</strong></p><ol><li><p>子元素选择器必须用”&gt;”连接, “&gt;”两边有没有空格都可以, 但是不建议写空格, 因为会与后代选择器的连接符混淆.</p></li><li><p><font color="orange"><code>子元素选择器只会查找”儿子”, 不会查找其他后代.</code></font></p></li><li><p>子元素选择器不仅可以使用类型选择器, 还可以使用类选择器,id 等选择器</p></li><li><p><font color="red"><code>子元素选择器不能通过”&gt;”一直延续下去, 只能有一个”&gt;”</code></font></p></li><li><p>由于 Qt 中有继承关系的 Widgets 较多, 在使用子元素选择器时, 请特别注意继承关系,比如我只想选中 QGroupBox 中的 QPushButton, 那么我即可以写成</p></li></ol>   <figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QWidget&gt;QPushButton{<span class="attribute">color</span>: red;} </span><br><span class="line"><span class="comment">/*也可以写成*/</span></span><br><span class="line">QGroupBox&gt;QPushButton{<span class="attribute">color</span>: red;} </span><br></pre></td></tr></tbody></table></figure><p>   这是因为 QGroupBox 是 QWidget 的派生类, 类型选择器 QWidget 会选中所有它的派生类对象,这些对象中包括 QGroupBox, 因此写法.1 会将所有的 QPushButton 的前景色设置为红色.鉴于此种情况, 我推荐在使用子元素选择器时, 使用类选择器替代类型选择器.</p><h5 id="一般用法-5"><a href="#一般用法-5" class="headerlink" title="一般用法"></a><strong>一般用法</strong></h5><p>子元素选择器一般用于一些特定布局条件中的控件, 例如我想给直接布局在 QGroupBox 的QCheckBox 设置一些特定属性, 那么可以这样做: </p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.QGroupBox</span> &gt; <span class="selector-class">.QCheckBox</span>{</span><br><span class="line"><span class="attribute">color</span>: blue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a><strong>属性选择器</strong></h4><h5 id="格式-6"><a href="#格式-6" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[attribute=value]</span>{ 属性: 值; }</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[attribute|=value]</span>{ 属性:值; }</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[attribute~=value]</span>{ 属性:值; }</span><br></pre></td></tr></tbody></table></figure><blockquote><p><font color="orange"><code>attribute=value 表示匹配有特定属性 attribute, 并且值为 value 的所有控件, 然后设置样式;</code></font></p><p><font color="orange"><code>attribute|=value 表示匹配有特定属性 attribute, 并且值以 value 开头的所有控件, 然后设置样式;</code></font></p><p><font color="orange"><code>attribute~=value 表示匹配有特定属性 attribute, 并且值包含 value 的所有控件, 然后设置样 式;</code></font></p></blockquote><h5 id="注意点-4"><a href="#注意点-4" class="headerlink" title="注意点"></a><strong>注意点</strong></h5><p><font color="red"><code>attribute|=value 表示 attribute 属性的值以 value 开头, 无论 value 后面还有没有值, 或者value 后面是什么, 均能匹配到</code></font>, 例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[objectName|=<span class="string">"button"</span>]</span>{</span><br><span class="line"><span class="attribute">color</span>: red; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这表示将 objectName 属性以 button 开头的所有控件的前景色设置为红色.</p><p><font color="red"><code>attribute~=value 表示 attribute 属性的值中包含 value, 这里要注意的是:value 必须是独立的单词, 也就是包含 value 并且 value 是被空格隔开的</code></font>, 例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[objectName~=<span class="string">"button"</span>]</span>{</span><br><span class="line"><span class="attribute">color</span>: red; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>而我在代码中, 设置的 objectName 的语句为:</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081327869.png"></p><p>结果是只匹配到了 pBtn2 所指的对象</p><h5 id="官方文档的解释"><a href="#官方文档的解释" class="headerlink" title="官方文档的解释:"></a>官方文档的解释:</h5><p>通常情况下, 这里的属性指的是, 使用 <font color="blue"><code>Q_PROPERTY</code> </font>宏所声明的属性, 并且属性类型要受 <font color="orange"><code>QVariant::toString()</code></font>支持.</p><p>这个选择器类型也可以用来判断动态属性，要了解更多使用自定义动态属性的细节，请参考使用自定义动态属性 </p><p><font color="orange"><code>除了使用=，你还可以使用~=来判断一个 QStringList 中是否包含给定的 QString</code></font>。警告：如果在设置了样式表后，相应的属性值发生了改变(如：flat 变成了”true”)，则有必要重新加载样式表，一个有效的方法是，取消样式表，再重新设置一次,下面的代码是其中一种方式：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">style()-&gt;unpolish(this);</span><br><span class="line"></span><br><span class="line">style()-&gt;polish(this);</span><br></pre></td></tr></tbody></table></figure><h5 id="一般用法-6"><a href="#一般用法-6" class="headerlink" title="一般用法"></a><strong>一般用法</strong></h5><p>属性选择器一般不常用, 如果要用, 请参照官方文档的方法使用</p><h4 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a><strong>并集选择器</strong></h4><h5 id="格式-7"><a href="#格式-7" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器<span class="number">1</span>,选择器<span class="number">2</span>,选择器<span class="number">3</span>{ 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>并集选择器表示, 将每个单独选择器匹配到的控件放在同一个结果集中, 并给结果集中的每个控件都设置声明语句中的样式.</p><h5 id="注意点-5"><a href="#注意点-5" class="headerlink" title="注意点"></a><strong>注意点</strong></h5><ol><li>并集选择器必须使用”,”来连接不同的选择器</li><li>并集选择器可以使用类选择器, 类型选择器, id 选择器, 属性选择器等.</li></ol><p><strong>一般用法</strong></p><p>主要用于给具有相同属性并且外观相似的的控件设置样式, 例如: </p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.QLineEdit</span>, <span class="selector-class">.QComboBox</span>{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid gray;</span><br><span class="line"><span class="attribute">background-color</span>:white; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="两个特殊的选择器"><a href="#两个特殊的选择器" class="headerlink" title="两个特殊的选择器"></a><strong>两个特殊的选择器</strong></h4><h5 id="子控件选择器"><a href="#子控件选择器" class="headerlink" title="子控件选择器"></a><strong>子控件选择器</strong></h5><h5 id="格式-8"><a href="#格式-8" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型选择器::子控{ 属性: 值; }</span><br><span class="line"></span><br><span class="line">类选择器::子控件{ 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>表示对类型选择器或类选择器指定的所有控件的<font color="orange"><code>子控件</code></font>设置样式;</p><p><strong>Qt</strong> <strong>官方说明</strong> </p><p>为了样式化你的复杂 widget，很有必要使用 widget 的 subcontrol，比如 QComboBox 的 drop-down 部分或者是 QSpinBox 的上和下箭头。选择器也许会包含 subcontrols 用于限制 widget的 subcontrols, 举个例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QComboBox::down-arrow{</span><br><span class="line">image: <span class="built_in">url</span>(<span class="string">:/res/arrowdown.png</span>); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述规则样式化所有 QComboBox 的 drop-down 部分，虽然双冒号(::)让人联想到 CSS3 的伪元素语法，但是 Qt 的 Sub-Controls 跟它是不一样的。</p><p> Sub-Controls 始终相对于另一个元素来定位–一个参考元素。这个参考元素可以是一个Widget 又或者是另一个 Sub-Control。举个例子，QComboBox 的::drop-down 默认被放置于QComboBox 的 Padding rectangle(盒子模型)的右上角。::drop-down 默认会被放置于另一个::drop-down Sub-Control 的中心。查看可样式化的 Widget 列表以了解更多使用 Sub-Control来样式化 Widget 和初始化其位置的内容。源 rectangle 可以使用 subcontrol-origin 来改变。</p><p>举个例子，如果我们想要把 drop-down 放置于 QComboBox 的 margin rectangle 而不是默认的 Padding rectangle，我们可以像下面这样指</p><p>定：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QComboBox {</span><br><span class="line"><span class="attribute">margin-right</span>: <span class="number">20px</span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">QComboBox::drop-down {</span><br><span class="line">    subcontrol-origin: margin; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>drop-down 在 Margin rectangle 内的排列方式可以由 subcontrol-position 来改变. </p><p>width 和 height 属性可以用来控制 Sub-control 的 size.需要注意的是，设置了 image 就隐式的设置了 Sub-control 的 size 了。</p><ol><li>相对定位方案（position:relative）,允许 Sub-Control 的位置从它的初始化位置作出偏移。</li></ol><p>举个例子，当 QComboBox 的 drop-down 按钮被 pressed 时，我们也许想要那个箭头作出位移以显示一种“pressed”的效果，为了达到目标，我们可以像下面那样指定</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QComboBox::down-arrow {</span><br><span class="line"> image*: <span class="built_in">url</span>(<span class="string">down_arrow.png</span>); </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">QComboBox::down-arrow:pressed {</span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">1px</span>; <span class="attribute">left</span>: <span class="number">1px</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>绝对定位方(position : absolute)，使得 Sub-control 的 position 和 size 基于其参考元素而改</li></ol><p>变。一旦定位，它们将会与 widget 同等对待并且可以使用盒子模型来样式化。查看 Sub-Control 列表以了解那些 sub-control 是被支持的，并且可以查看自定义QPushButton 的菜单指示器 Sub-Control 来了解一个实际的使用例子。注意：像 QComboBox 和 QScrollBar 这样的复杂部件，如果 sub-control 的一项属性是自定义的，那么其他所有的属性跟 sub-control 也都应该自定义。</p><h5 id="子控件表（参考）"><a href="#子控件表（参考）" class="headerlink" title="子控件表（参考）"></a>子控件表（参考）</h5><table><thead><tr><th>子部件</th><th>描述</th></tr></thead><tbody><tr><td>::down-arrow</td><td>combo box或spin box的下拉箭头</td></tr><tr><td>::down-button</td><td>spin box的向下按钮</td></tr><tr><td>::drop-down</td><td>combo box的下拉箭头</td></tr><tr><td>::indicato</td><td>checkbox、radio button或可选择group box的指示器</td></tr><tr><td>::item</td><td>menu、menu bar或status bar的子项目</td></tr><tr><td>::menu-indicator</td><td>push button的菜单指示器</td></tr><tr><td>::title</td><td>group box的标题</td></tr><tr><td>::up-arrow</td><td>spin box的向上箭头</td></tr><tr><td>::up-button</td><td>spin box的向上按钮</td></tr></tbody></table><h5 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a><strong>伪类选择器</strong></h5><h5 id="格式-9"><a href="#格式-9" class="headerlink" title="格式"></a><strong>格式</strong></h5><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型选择器:状态{ 属性: 值; }</span><br><span class="line"></span><br><span class="line">类选择器:状态{ 属性: 值; }</span><br></pre></td></tr></tbody></table></figure><p>表示对类型选择器或类选择器指定的所有控件设置它在指定状态时的样式.</p><p><strong>Qt</strong> <strong>官方说明</strong> </p><p>选择器也许会包含基于 widget 的 state 的程序限制规则的伪状态。<font color="orange"><code>伪状态以冒号(:)作为分隔紧跟着选择器</code></font>。举个例子，下面的规则在鼠标悬浮在 QPushButton 的上方时生效：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:hover</span> { <span class="attribute">color</span>: white }</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>伪状态可以使用感叹号进行取反</code></font>，下面一条规则在鼠标没有悬浮在 QRadioButton 上方时生效：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QRadioButton:!hover { <span class="attribute">color</span>: red }</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>伪状态可以链接，在这样的情况下，隐式地包含了逻辑与</code></font>。举个例子，下面一条规则在鼠标悬浮到一个已 check 的 QCheckBox 上时生效：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QCheckBox<span class="selector-pseudo">:hover</span><span class="selector-pseudo">:checked</span> { <span class="attribute">color</span>: white }</span><br></pre></td></tr></tbody></table></figure><p>伪状态的取反也可以出现在伪状态链中，举个例子，下面的规则在鼠标悬浮到一个没有被press 的 QPushButton 上时生效：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:hover</span>:!pressed { <span class="attribute">color</span>: blue; }</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>如果有需要，可以使用逗号来表示逻辑或, 即并集选择器</code></font></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QCheckBox<span class="selector-pseudo">:hover</span>, QCheckBox<span class="selector-pseudo">:checked</span> { <span class="attribute">color</span>: white }</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>伪状态可以与 subcontrol 组合使用</code></font>，举个例子：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QComboBox::drop-down:hover { *image*: <span class="built_in">url</span>(<span class="string">dropdown_bright.png</span>) }</span><br></pre></td></tr></tbody></table></figure><h5 id="伪状态表（参考）"><a href="#伪状态表（参考）" class="headerlink" title="伪状态表（参考）"></a>伪状态表（参考）</h5><table><thead><tr><th>伪状态</th><th>描述</th></tr></thead><tbody><tr><td>:unchecked</td><td>button部件未被选中</td></tr><tr><td>:checked</td><td>button部件被选中</td></tr><tr><td>:disabled</td><td>部件被禁用</td></tr><tr><td>:enabled</td><td>部件被启用</td></tr><tr><td>:focus</td><td>部件获得焦点</td></tr><tr><td>:hover</td><td>鼠标位于部件上</td></tr><tr><td>:indeterminate</td><td>checkbox或radiobutton被部分选中</td></tr><tr><td>:off</td><td>部件可以切换，且处于off状态</td></tr><tr><td>:on</td><td>部件可以切换，且处于on状态</td></tr><tr><td>:pressed</td><td>部件被鼠标按下</td></tr></tbody></table><h4 id="没有选择器的情况"><a href="#没有选择器的情况" class="headerlink" title="没有选择器的情况"></a><strong>没有选择器的情况</strong></h4><p>如果在 c++的代码中直接调用控件对象的 setStyleSheet 函数来设置样式,但样式中没有任何选择器, 例如下面这样</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pBtn1-&gt;setStyleSheet("<span class="attribute">color</span>: green;");</span><br></pre></td></tr></tbody></table></figure><p>即使这种写法可以生效, 但它不符合语法规则, 因此不推荐使用.经过测试, <font color="red"><code>这样的语句被忽略的选择器相当于通用选择器</code></font>或下面例子中的选择器, 假如 pBtn1 是一个 QPushButton 对象的指针, 那么这条语句等价于</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pBtn1-&gt;setStyleSheet("QPushButton, QPushButton *{<span class="attribute">color</span>: green;}");</span><br></pre></td></tr></tbody></table></figure><h4 id="选择器的匹配规则"><a href="#选择器的匹配规则" class="headerlink" title="选择器的匹配规则"></a><strong>选择器的匹配规则</strong></h4><p>之所以要把这个问题单独作为一个小节来写, 是因为在日常开发过程中, 经常会犯这方面的错误.</p><p>下面看一个例子:假如需要完成一个界面, 如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081409652.png"></p><p>这里用户名输入框是一个 QComboBox 对象, 密码输入框是一个 QLineEdit 对象, 它们的父控件是一个 QDialog, 有这样一个需求:给这两个输入框设置相同的边框属性: 1 个像素宽的蓝色实线框, 为了方便更改风格, 我有一个 css 文件, 将所有样式都写在了这个文件里, 这时, 观察发现, 这两个控件都是QDialog的子控件,于是可以用后代选择器或者子元素选择器, 如下:</p><p>第一种:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QDialog QComboBox,QLineEdit{</span><br><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid blue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第二种:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QDialog&gt;QComboBox,QLineEdit{</span><br><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid blue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当我写完并运行程序后, 发现无论采用哪种写法 QComboBox 是正常的, 但是我的程序界面中, <font color="orange"><code>其他所有的 QLineEdit 的边框都变成了 1 个像素款的蓝色实线框</code></font>, 而这并不是我想要的效果.</p><p>因此对于上面的现象, 我们很容易得出结论: <font color="red"><code>多个选择器组合(并集选择器)使用时, 它们的结合方向是自右向左, 而不是我们认为的自左向右</code></font>.也就是说, 这两个选择器分别被理解为<font color="orange"><code>(QDialogQComboBox), QLineEdit</code></font> 和<font color="orange"><code>(QDialog&gt;QComboBox),QLineEdit</code>.</font></p><p>其实, 这应该与 CSS 的选择器匹配规则是一样的, 是为了提高效率的一种做法, 具体原因这 里不细谈.</p><p>正确的写法应该是</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QDialog QComboBox, QDialog QLineEdit{</span><br><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid blue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>或</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QDialog&gt;QComboBox, QDialog&gt;QLineEdit{</span><br><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid blue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Qss-的特性"><a href="#Qss-的特性" class="headerlink" title="Qss 的特性"></a><strong>Qss</strong> <strong>的特性</strong></h2><h3 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a><strong>层叠性</strong></h3><p>qss 的语法来源于 css, 而 css 的全称是 Cascading StyleSheet, 翻译过来叫做层叠样式表,</p><p>也叫级联样式表, 本文中一律使用层叠样式表.</p><p>层叠性是 css 处理冲突的一种能力.</p><p>只有在多个选择器匹配到同一个控件时才会发生层叠性, 如下面的例子:</p> <figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pBtn1-&gt;setStyleSheet("QPushButton{<span class="attribute">color</span>: blue;}");</span><br><span class="line"></span><br><span class="line"> pBtn1-&gt;setStyleSheet("<span class="selector-class">.QPushButton</span>{<span class="attribute">color</span>: green;}");</span><br></pre></td></tr></tbody></table></figure><p>这两个选择器匹配到了同一个按钮, (<font color="orange"><code>选择器优先级相同的情况下</code></font>)结果是后面的样式覆盖掉了前面的, 这就是层叠现象.</p><h3 id="继承性-Qt-Version-gt-x3D-5-7"><a href="#继承性-Qt-Version-gt-x3D-5-7" class="headerlink" title="继承性(Qt-Version >= 5.7)"></a><strong>继承性</strong><strong>(Qt-Version &gt;= 5.7)</strong></h3><p>在典型的 CSS 中，如果一个标签的字体和颜色没有显式设置，它会自动从其父亲获得。当使</p><p>用 Qt 样式表时，控件**<font color="orange">不会</font>**从其<font color="orange"><strong>父亲(不是父类)</strong></font>继承字体和颜色的设置(请注意，父亲和父类、孩子和子类都是不同的概念，不要搞混)</p><p>举个例子，考虑一个 QGroupBox 内有一个 QPushButton：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qApp-&gt;setStyleSheet("QGroupBox{ <span class="attribute">color</span>: red; }");</span><br></pre></td></tr></tbody></table></figure><p>QPushButton 没有任何显式的 color 设置。因此，<font color="orange"><code>它会获得系统的颜色而不是从父亲继承 color的值</code></font>。如果我们要设置 QGroupBox 及其所有孩子的 color，我们可以这样写：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qApp-&gt;setStyleSheet("QGroupBox,QGroupBox * { <span class="attribute">color</span>: red; }");</span><br></pre></td></tr></tbody></table></figure><p>注意 QGroupBox 和*之间的空格。与此相反，使用 QWidget::setFont()可以设置字体包括孩子的字体，使用 <font color="orange"><code>QWidget::setPalette()</code></font>可以设置调色板包括孩子的调色板。如果想要字体和调 色板被孩子继承 , 可以给 QApplication 设 置<font color="orange"><code>Qt::AA_UseStyleSheetPropagationInWidgetStyles</code></font>(Qt5.7 加入)属性, 例如:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QCoreApplication::<span class="built_in">setAttribute</span>(Qt::AA_UseStyleSheetPropagationInWidgetStyles, true);</span><br></pre></td></tr></tbody></table></figure><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a><strong>优先级</strong></h2><p>为什么要有优先级？</p><p>当一个控件被多个选择器选中并且设置了相同的属性（值不同）时， 不能仅仅根据设置样式语句出现的先后顺序进行层叠, 那么控件的样式如何确定，于是引出了选择器的优先级问题。</p><p>一般通过下面两步进行选择器优先级的判定.</p><h3 id="第一步：-设置方式所产生的优先级问题"><a href="#第一步：-设置方式所产生的优先级问题" class="headerlink" title="第一步： 设置方式所产生的优先级问题"></a><strong>第一步：</strong> <strong>设置方式所产生的优先级问题</strong></h3><p>在 CSS 中， 有如下层叠优先级规则：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内联样式&gt;内部样式&gt;外部样式&gt;浏览器缺省</span><br></pre></td></tr></tbody></table></figure><p>而在 Qss 中, 这个规则表现为:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给控件直接设置的样式&gt;给QApplication设置的样式</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>就是说， 调用控件的 setStylesheet 设置的样式的优先级永远高于给 QApplication 设置的样式， 即使 QApplication 中的选择器优先级更高</code></font></p><h3 id="第二步：样式表本身的优先级问题"><a href="#第二步：样式表本身的优先级问题" class="headerlink" title="第二步：样式表本身的优先级问题"></a><strong>第二步：样式表本身的优先级问题</strong></h3><p>当设置方式相同，且几个样式规则为同一个控件的同一个属性指定不同的值时,就产生了冲突.此时, 如何层叠就由选择器的优先级来确定.一般而言，<font color="red"><code>选择器越特殊，它的优先级越高。也就是选择器指向的越准确，它的优先级就越高。</code></font></p><h3 id="优先级判断的三种方式"><a href="#优先级判断的三种方式" class="headerlink" title="优先级判断的三种方式"></a><strong>优先级判断的三种方式</strong></h3><h4 id="间接选中"><a href="#间接选中" class="headerlink" title="间接选中"></a>间接选中</h4><p>间接选中就是指继承, 也就是在 Qt5.7 及以上版本, 程序中给 <font color="orange"><code>QApplication</code></font> 对象设置了<font color="purple"><code>Qt::AA_UseStyleSheetPropagationInWidgetStyles</code> </font>属性时, 才会有间接选中.</p><p><font color="orange"><code>如果是间接选中,那么最终的样式就是离目标最近的那个</code></font>, 这里的近指的是两个控件的父子关系. </p><p>例如:</p><blockquote><p>一个 QPushButton 对象被布局在 QGroupBox 中, 而 QGroupBox 又被布局在 QWidget 中, 此时如果给 QGroupBox 和 QWidget 都设置了 color 属性的颜色, 那么无论设置顺序如何, QPushButton 的前景色总是表现为 QGroupBox 设置的颜色, 因为QGroupBox 显然是离 QPushButton 最近的那一个.</p></blockquote><h4 id="相同选择器-直接选中"><a href="#相同选择器-直接选中" class="headerlink" title="相同选择器(直接选中)"></a>相同选择器(直接选中)</h4><p>如果都是直接选中, 并且都是同类型的选择器, 那么写在后面的样式会覆盖掉前面的样式, 例如</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pBtn1-&gt;setStyleSheet("QPushButton{<span class="attribute">color</span>: green;}");</span><br><span class="line"></span><br><span class="line">pBtn1-&gt;setStyleSheet("QPushButton{<span class="attribute">color</span>: blue;}");</span><br></pre></td></tr></tbody></table></figure><p>显而易见, pBtn1 的前景色是蓝色.</p><h4 id="不同选择器-直接选中"><a href="#不同选择器-直接选中" class="headerlink" title="不同选择器(直接选中)"></a>不同选择器(直接选中)</h4><p>如果都是直接选中, 并且不是相同类型的选择器, 那么就会按照选择器的优先级来层叠.</p><p>具体的优先级如下: </p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Id &gt; 类 &gt; 类型 &gt; 通配符 &gt; 继承 &gt; 默认</span><br></pre></td></tr></tbody></table></figure><h3 id="优先级权重"><a href="#优先级权重" class="headerlink" title="优先级权重"></a><strong>优先级权重</strong></h3><p>为什么会有优先级权重？</p><p>当多个选择器混合在一起使用时, 我们可以通过计算权重来判断谁的优先级最高,从而确定控件的样式.</p><p>注意点： </p><p><font color="red"><code>只有选择器是直接选中控件时才需要计算权重， 否则直接选择器高于一切间接选中的选择器</code></font></p><p>优先级权重的计算方式:</p><blockquote><ol><li><p>计算选择器中的 id 选择器数量[=a]</p></li><li><p>计算选择器中类选择器的数量+属性选择器的数量[=b]</p></li><li><p>计算选择器中类型选择器的数量[=c]</p></li><li><p>忽略子控件选择器</p></li></ol><p>串联这三个数字 a-b-c 就得到优先级权重, 数字越大优先级越高.</p></blockquote><p>串联这三个数字 a-b-c 就得到优先级权重, 数字越大优先级越高.</p><p>这里给出我写的一个例子， qss 文件位于资源文件中：</p><h3 id="Qt-官方关于冲突解决的说明"><a href="#Qt-官方关于冲突解决的说明" class="headerlink" title="Qt 官方关于冲突解决的说明"></a><strong>Qt</strong> <strong>官方关于冲突解决的说明</strong></h3><p>当几个样式规则为同一个属性指定不同的值时，就产生了冲突。请考虑下面的样式表：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QPushButton**<span class="selector-id">#okButton</span>** { <span class="attribute">color</span>: gray; }</span><br><span class="line"></span><br><span class="line">QPushButton { <span class="attribute">color</span>: red; }</span><br></pre></td></tr></tbody></table></figure><p>两条规则都匹配名为 okButton 的 QPushButton 实例并且冲突于颜色属性。为了解决冲突，我们必须考虑到选择器的特殊性。在上面的例子中，QPushButton#okButton 被视为比QPushButton 更特殊，<font color="orange"><code>因为它（通常）指向一个单一的对象而不是 QPushButton 的所有实例</code></font>。 相似的，<font color="orange"><code>指定了伪状态的选择器比没有指定伪状态的更特殊</code></font>。从而，下面的样式表指明了当鼠标悬浮到 QPushButton 上方时其字体颜色应该为白色，而其余情况则为红色：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:hover</span> { <span class="attribute">color</span>: white; }</span><br><span class="line"></span><br><span class="line">QPushButton { <span class="attribute">color</span>: red; }</span><br></pre></td></tr></tbody></table></figure><p>接下来看一个很有意思的：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:hover</span> { <span class="attribute">color</span>: white; }</span><br><span class="line"></span><br><span class="line">QPushButton<span class="selector-pseudo">:enabled</span> { <span class="attribute">color</span>: red; }</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>两个选择器都有相同的特殊性</code></font>，所以当鼠标悬浮在一个 enabled 的按钮上时，第二条规则优先。</p><p>如果在这种情况下我们想要文字变成白色，我们可以像下面那样重新排布一下样式规则：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:enabled</span> { <span class="attribute">color</span>: red; }</span><br><span class="line"></span><br><span class="line">QPushButton<span class="selector-pseudo">:hover</span> { <span class="attribute">color</span>: white; }</span><br></pre></td></tr></tbody></table></figure><p>另外，我们可以使第一条规则更特殊一些：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-pseudo">:hover</span><span class="selector-pseudo">:enabled</span> { <span class="attribute">color</span>: white; }</span><br><span class="line"></span><br><span class="line">QPushButton<span class="selector-pseudo">:enabled</span> { <span class="attribute">color</span>: red; }</span><br></pre></td></tr></tbody></table></figure><p>相似的问题出现在相互配合的类型选择器上。考虑以下情况：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QPushButton { <span class="attribute">color</span>: red; }</span><br><span class="line"></span><br><span class="line">QAbstractButton { <span class="attribute">color</span>: gray; }</span><br></pre></td></tr></tbody></table></figure><p>两条规则都应用于 QPushButton 的实例（因为 QPushButton 继承于 QAbstractButton）并且冲突于 color 属性。因为 QPushButton 继承于 QAbstractButton，这让人不禁想到 QPushButton比 QAbstractButton 更特殊(<font color="red">并没有更特殊</font>)。然而，<font color="orange"><code>对于样式表的运算，所有的类型选择器都具有同等的特殊性，并且出现在更后面的规则优先级更高</code></font>。换句话说，QAbstractButton 的 color 会被设置成灰色，包括 QPushButton。如果我们确实想要 QPushButton 字体颜色设置为红色，<font color="orange"><code>我们总是可以使用重新排列样式表规则顺序的方式实现</code></font>。</p><p>为确定规则的特殊性，Qt 样式表跟随 CSS2 规范</p><p>一个选择器的特殊性由下面的方式计算：</p><blockquote><ul><li><p>计算选择器中 ID 属性的数量[=a] </p></li><li><p>计算选择器中其他属性和伪类的数量[=b] </p></li><li><p>计算选择器中元素名字的数量[=c] </p></li><li><p>忽略伪原素[如:subcontrol]</p></li></ul></blockquote><p>串联这三个数字<font color="orange"> <code>a-b-c</code></font>（在一个大基数的数字系统）就得到了特殊性等级。</p><p>举个例子：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* {} <span class="comment">/* a=0 b=0 c=0 -&gt; specificity = 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">LI</span> {} <span class="comment">/* a=0 b=0 c=1 -&gt; specificity = 1 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">UL</span> <span class="selector-tag">LI</span> {} <span class="comment">/* a=0 b=0 c=2 -&gt; specificity = 2 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">UL</span> <span class="selector-tag">OL</span>+<span class="selector-tag">LI</span> {} <span class="comment">/* a=0 b=0 c=3 -&gt; specificity = 3 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">H1</span> + *<span class="selector-attr">[REL=up]</span>{} <span class="comment">/* a=0 b=1 c=1 -&gt; specificity = 11 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">UL</span> <span class="selector-tag">OL</span> <span class="selector-tag">LI</span><span class="selector-class">.red</span> {} <span class="comment">/* a=0 b=1 c=3 -&gt; specificity = 13 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">LI</span><span class="selector-class">.red</span><span class="selector-class">.level</span> {} <span class="comment">/* a=0 b=2 c=1 -&gt; specificity = 21 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#x34y</span> {} <span class="comment">/* a=1 b=0 c=0 -&gt; specificity = 100 */</span></span><br></pre></td></tr></tbody></table></figure><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a><strong>盒模型</strong></h2><p>在讲解属性之前, 我们必须了解一下 QSS 的盒模型.</p><h3 id="什么是盒模型"><a href="#什么是盒模型" class="headerlink" title="**什么是盒模型? **"></a>**什么是盒模型? **</h3><p>盒模型仅仅是一个形象的比喻, 所有的 widget 都被看做是一个”盒子”, 一个盒子包括：外边距，边框，内边距，和实际内容. 它们可以看作是有包含关系的矩形, 并且这种包含关系是固定不变的.</p><p>如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081520165.png"></p><blockquote><p><strong>Margin</strong> <strong>（外边距）</strong> - 与其他盒子之间的距离.</p><p><strong>Border</strong> <strong>（边框）</strong> - 外边距与内边距之间的区域.边框有自己的颜色不会受到盒子的背景颜色影响</p><p><strong>Padding</strong> <strong>（内边距）</strong> - 内容和边框之间的区域.会受到背景颜色影响. </p><p><strong>Content</strong> <strong>（内容）</strong> - 盒子的内容,显示文本,图像或其他控件</p></blockquote><p>除了内容外, 其他三个部分均不能单独设置颜色, 只能设置其宽度, 并且是以像素为单位.</p><p>对比一张生活中的一张照片墙来看会更容易理解</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081522950.png"></p><h3 id="盒模型中的宽度与高度"><a href="#盒模型中的宽度与高度" class="headerlink" title="盒模型中的宽度与高度"></a><strong>盒模型中的宽度与高度</strong></h3><p>在属性中将要学到的 width, height 两个属性, 设置的均是盒子的<strong>内容</strong>的宽高, 而我们在 c++</p><p>代码中的窗口的 width 与 height 指的是<strong>整个盒子的宽度与高度</strong>, 这一点非常重要.</p><p>整个盒子的宽度应该等于:</p><p>左外边距 + 左边框 + 左内边距 + 内容宽度 + 右内边距 + 右边框 + 右外边距,</p><p>同理, 整个盒子的高度也是上下外边距,内边距,边框和内容高度的和.</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a><strong>属性</strong></h4><p><font color="orange"><code>属性即控件的具体外观样式</code></font>, 比如背景颜色, 边框宽度等等. 本节主要列举一些常用的属性,并介绍它们的具体格式或取值</p><p>注意:<font color="red"><code>一个属性并不是被所有 widget 都支持的</code></font>, 要想查看什么 widget 支持哪些属性, 或一个属性被哪些 widget 支持, 请查看文档后面给出的官方链接.</p><h4 id="背景属性-background"><a href="#背景属性-background" class="headerlink" title="背景属性 background"></a><strong>背景属性</strong> <strong>background</strong></h4><p>背景共有 7 个属性, <font color="orange"><code>既可以每个属性单独设置, 也可以连写</code></font>, 下面将对他们逐一进行分析,并在最后给出其连写格式</p><h5 id="background-color"><a href="#background-color" class="headerlink" title="background-color"></a><strong>background-color</strong></h5><p>取值: Brush 类型(Brush 类型介绍见本节最后)</p><p>作用: 设置控件的背景颜色, <font color="orange"><code>默认是 border 之内的矩形区域, 包括内边距和内容矩形</code></font>.</p><h5 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a><strong>background-image</strong></h5><p>取值: Url 类型, 格式是 url(filename), <font color="orange"><code>filename 是一个本地文件路径或 Qt 资源文件路径, 不支持网络图片</code></font></p><p>作用: 设置控件的背景图片. <font color="orange"><code>可以与背景颜色共存, 背景图片会覆盖背景颜色, 在没有被图片覆盖的区域, 显示背景颜色.</code></font></p><h5 id="background-repeat"><a href="#background-repeat" class="headerlink" title="background-repeat"></a><strong>background-repeat</strong></h5><p>取值:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repeat-x: 在水平方向上平铺</span><br><span class="line"></span><br><span class="line">repeat-y: 在垂直方向上平铺</span><br><span class="line"></span><br><span class="line">repeat: 在水平和垂直方向上都平铺, 这是默认值(但是 Qt 好像有 bug, 设置了 repeat 反而不会平铺, 不设置才平铺)</span><br><span class="line"></span><br><span class="line">no-repeat: 不平铺</span><br></pre></td></tr></tbody></table></figure><p>作用: <font color="orange"><code>设置背景图片的平铺方式.</code> </font></p><p>例子: </p><p>给一个 QTextEdit 设置背景图片,代码和效果分别如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>);</span><br><span class="line"><span class="attribute">background-repeat</span>: no-repeat;<span class="comment">/*repeat-x; repeat-y; repeat;*/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081535428.png" alt="repeat-x"><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081535917.png" alt="repeat-y"></p><p>​            </p><p>  <img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081535678.png" alt="repeat"><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081535053.png" alt="no-repeat">  </p><p>​</p><h5 id="background-position"><a href="#background-position" class="headerlink" title="background-position"></a><strong>background-position</strong></h5><p>取值:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">top</span>: 向上对齐 left: 向左对齐</span><br><span class="line"></span><br><span class="line">bottom: 向下对齐 right:向右对齐</span><br><span class="line"></span><br><span class="line">center: 居中</span><br></pre></td></tr></tbody></table></figure><p>格式:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-position</span>: 水平对齐方式 垂直对齐方式;</span><br></pre></td></tr></tbody></table></figure><p>这是 css 规定的标准顺序, 而 qss 并未严格规定, 但建议按照 css 的顺序写</p><p>作用: <font color="orange"><code>设置背景图片的对齐方式, 默认情况下向左向上对齐,</code></font></p><p>举例: 水平向左垂直居中对齐, 代码和效果如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>);</span><br><span class="line"><span class="attribute">background-position</span>: right center; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081535623.png"></p><h5 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a><strong>background-attachment</strong></h5><p>取值:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scroll : 滚动, 这是默认值</span><br><span class="line"></span><br><span class="line">fixed: 固定</span><br></pre></td></tr></tbody></table></figure><p>作用: <font color="orange">设置背景图片在带滚动条的控件(QAbstractScrollArea)中是固定在一个位置还是随着滚动条滚动.</font></p><p>比如: css 代码分别如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>);</span><br><span class="line"><span class="attribute">background-repeat</span>: no-repeat;<span class="comment">/*repeat-x; repeat-y; repeat;*/</span></span><br><span class="line"><span class="attribute">background-position</span>: right center;</span><br><span class="line"><span class="attribute">background-attachment</span>: scroll; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;<span class="comment">/*repeat-x; repeat-y; repeat;*/</span></span><br><span class="line"><span class="attribute">background-position</span>: right center;</span><br><span class="line"><span class="attribute">background-attachment</span>: fixed; </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p>效果图</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081541879.png" alt="scroll "><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081541064.png" alt="fixed"></p><p>​</p><h5 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a><strong>background-clip</strong></h5><p>取值:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">margin</span>: 外边距矩形</span><br><span class="line"></span><br><span class="line">border: 边框矩形</span><br><span class="line"></span><br><span class="line">padding: 内边距矩形</span><br><span class="line"></span><br><span class="line">content: 内容矩形</span><br></pre></td></tr></tbody></table></figure><p>作用: <font color="orange"><code>设置背景颜色覆盖的区域, 默认情况下背景只覆盖内边距矩形, 如果没有指定, 默认值为 border</code></font></p><p>例子: 为了区别各矩形, 我们先给 QTextEdit 设置边框,内边距和外边距, 为了区别明显, 我们将边框宽度设置大一点</p><p>代码和图片如下:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">20px</span> solid purple;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>);</span><br><span class="line"><span class="attribute">background-repeat</span>: no-repeat;<span class="comment">/*repeat-x; repeat-y; repeat;*/</span></span><br><span class="line"><span class="attribute">background-position</span>: left top;</span><br><span class="line"><span class="attribute">background-attachment</span>: fixed; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205101117655.png"></p><p>分别将 background-clip 属性的值设为 margin, border, padding, content, </p><p>效果图如下</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081542686.png" alt="margin "><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081548247.png" alt="border"></p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081543791.png" alt="padding"><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081543463.png" alt="content"></p><pre><code>                                                                 content</code></pre><p><font color="orange"><code>可见, background-clip 属性只对背景的渲染区域有关系</code></font>, 背景图片始终是靠在 padding 边上</p><h5 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a><strong>background-origin</strong></h5><p>取值: 与 background-clip 一样</p><p>作用: 与 background-position 和 background-image 一起使用,<font color="orange"> 指明背景图片的覆盖范围矩形</font>,如果没有指定, <font color="orange">默认为 padding</font></p><p>下面是分别设置为 margin, border, padding 和 content 的代码和效果图</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">20px</span> solid purple;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>);</span><br><span class="line"> <span class="comment">/*background-repeat: no-repeat;*/</span><span class="comment">/*repeat-x; repeat-y; repeat;*/</span></span><br><span class="line"><span class="attribute">background-position</span>: left top;</span><br><span class="line"><span class="attribute">background-attachment</span>: fixed;</span><br><span class="line"><span class="attribute">background-clip</span>: margin; <span class="comment">/*border; padding; content;*/</span></span><br><span class="line"><span class="attribute">background-origin</span>: margin; <span class="comment">/*border; padding; content;*/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081548330.png" alt=" margin "><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081549270.png" alt="border"></p><p>​</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081808678.png" alt="padding"><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081549494.png" alt="content"></p><p>注意观察 border 与 padding 的图片, 它们是不同的, 差别就是 border 的 20 个像素所造成的不一致。</p><h5 id="背景属性的连写格式"><a href="#背景属性的连写格式" class="headerlink" title="背景属性的连写格式"></a><strong>背景属性的连写格式</strong></h5><p>格式:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background</span>: color image repeat position;</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>在这种连写格式中, 只能包含着四个属性, 其他几个仍然需要单独写, 而且这四个属性可以省略任何一个, 最多可以省略三个, 也就是最少需要保留一个,即属性值不能为空</code></font></p><p><font color="red"><code>另外让人比较迷惑的是, 在这种连写方式中,repeat 确实是平铺了图片, 而单独写时, 它又是不平铺的, 具体原因还未找到.</code></font></p><p>举个例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">20px</span> solid purple;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">background</span>: skyblue <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>) repeat left top; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>效果图</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081552920.png"></p><h4 id="前景属性-color"><a href="#前景属性-color" class="headerlink" title="前景属性 color"></a><strong>前景属性</strong> <strong>color</strong></h4><p>与背景相对应, 背景设置的是控件的最底层的颜色, 作为背景, 但 <font color="orange"><code>color 设置的前景色, 也就是控件文字的颜色</code></font>, color 属性是被所有 widget 都支持的.</p><p>格式:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">color</span>: Brush类型的值;</span><br></pre></td></tr></tbody></table></figure><p>举个例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081556014.png"></p><h4 id="边框属性-border"><a href="#边框属性-border" class="headerlink" title="**边框属性 border"></a>**<strong>边框属性</strong> <strong>border</strong></h4><p>边框属性有四种书写方式, 同样, 先逐一进行分析, 最后给出书写格式</p><h5 id="border-width"><a href="#border-width" class="headerlink" title="border-width"></a><strong>border-width</strong></h5><p>取值: ?px 像素宽度, 数值后面一定要加上像素单位 px, 也有其他单位, 但不推荐使用</p><p>作用:用于边框宽度</p><p>例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border-width</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">border-style</span>: solid;</span><br><span class="line"><span class="attribute">border-color</span>:purple;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">20px</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>效果图</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081557565.png"></p><h5 id="border-style"><a href="#border-style" class="headerlink" title="border-style"></a><strong>border-style</strong></h5><p>设置边框的渲染样式.</p><p>取值以及效果如下:</p><p>dashed </p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081557030.png"></p><p>dot-dash </p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081557540.png"></p><p>dot-dot-dash</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081557180.png"></p><p>dotted</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081558909.png"></p><p>double</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081558333.png"></p><p>groove</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081558590.png"></p><p>inset</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081558125.png"></p><p>outset</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081558853.png"></p><p>ridge</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081559284.png"></p><p>solid</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081559793.png"></p><p>none</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081559309.png"></p><h5 id="border-color"><a href="#border-color" class="headerlink" title="border-color"></a><strong>border-color</strong></h5><p>取值: Brush 类型</p><p>作用: 设置边框的颜色</p><h5 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a><strong>border-radius</strong></h5><p>取值: 水平半径 垂直半径;</p><p>均是以像素为单位, 值必须带 px, 第二个值是可选的, 如果只有一个值, 表示同时水平半径和垂直半径, 如果有两个值, 则第一个代表水平半径, 第二个代表垂直半径.</p><p>示例图</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081600183.png"></p><p>作用: 设置边框四个角的弧度</p><p>举个例子:</p><p>代码 1:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line">border-width: 10px;</span><br><span class="line">border-style: solid;</span><br><span class="line">border-color: red;</span><br><span class="line">border-radius: 50px;</span><br><span class="line">padding: 20px;</span><br><span class="line">margin: 20px; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码 2:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border-width</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">border-style</span>: solid;</span><br><span class="line"><span class="attribute">border-color</span>: red;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">50px</span> <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">20px</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081802324.png" alt=""><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081801057.png" alt="" style="zoom:;"></p><p> 代码 1 效果图 代码 2 效果图</p><h5 id="border-image"><a href="#border-image" class="headerlink" title="border-image"></a><strong>border-image</strong></h5><p>取值: 这是一个连写格式, 下面给出具体的书写格式, 由于 <font color="orange"><code>Qt 对这个属性支持不是很好, 因此不建议使用</code></font>, 下面简要介绍一下</p><p>格式:</p><p>CSS 的连写格式如下, 每一项分别代表分开写时的一个属性.</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-image</span>: border-image-source border-image-slice (fill)/ border-image-width</span><br><span class="line">/ border-image-outset border-image-repeat</span><br></pre></td></tr></tbody></table></figure><p>其中,<font color="orange"> <code>fill, border-image-width 和 border-image-outset 在 Qt 中不被支持</code></font>, 而且 Qt 只支持连写格式, 因此在 Qt 中, 我们实际的代码格式是</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-image</span>: border-image-source border-image-slice border-image-repeat</span><br></pre></td></tr></tbody></table></figure><p>下面简略说一下每项的含义:</p><blockquote><p>border-image-source: <font color="orange">图片路径,还是只支持本地路径和 Qt 资源文件路径.</font></p><p>border-image-slice: 图片切片, 单位只能是像素值, 因此数值不必带单位 px, 它最多可以指 定 4 个值,按照顺序分别代表上右下左, 最少指定 1 个值, 左省略时和右相同,下省略时和上相同, 右省略时和上相同; 它们的含义是, 距图片顶部, 右侧, 下部, 左侧分别按照指定的像素值进行切片, 将图片分成 四个角(左上,右上,右下,左下) + 四个边(上右下左) + 中间部分 = 共 9 个部分, 在 CSS 中, 如果指定了 fill, 则中间部分会覆盖元素(控件)的背景, 否则中间部分默认被省略</p><p>border-image-repeat: 最多两个值最少一个值, 第一个值表示水平方向, 第二个值表示垂直方向. 作用是指定边框图片的四条边和四个角的平铺方式,不包括中间部分, 有三种取值, 分别为 <strong>stretch</strong>(默认), <strong>round</strong>(均分平铺), <strong>repeat</strong>(平铺). stretch 表示拉伸四条边相应的切片图片,来填补边框的间隙.round 是把四个角和四条边分成均等区域然后用背景图片切好能铺满整个边框空隙, 不能多也不能少, 正好合适. repeat 是做直接复制填满空隙.</p></blockquote><p>下面是一个切片的具体示例:利用上面这张图片,来看一下 border-image 的一些效果图</p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20220508160643576.png" alt="" style="zoom:150%;"><p>效果 1:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">30px</span> solid red;</span><br><span class="line"><span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/border.png</span>) <span class="number">30</span> round;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081607846.png"></p><p>效果 2:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">30px</span> solid red;</span><br><span class="line"><span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/border.png</span>) <span class="number">30</span> stretch;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081609325.png"></p><p>效果 3:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">30px</span> solid red;</span><br><span class="line"><span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/border.png</span>) <span class="number">30</span> repeat;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081609923.png"></p><p>效果 4:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">30px</span> solid red;</span><br><span class="line"><span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/border.png</span>) <span class="number">30</span> repeat stretch;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">:/resource/girl.jpg</span>); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081610885.png"></p><h5 id="格式-10"><a href="#格式-10" class="headerlink" title="格式"></a><strong>格式</strong></h5><p>border 属性的 style, color, width 可以连写也可以单独写, 并且可以分别设置四条边的边框,</p><p>下面进行详细介绍</p><h6 id="连写格式-1"><a href="#连写格式-1" class="headerlink" title="连写格式 1"></a><strong>连写格式</strong> <strong>1</strong></h6><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>: width style color;</span><br></pre></td></tr></tbody></table></figure><p>这种格式将四条边框的宽度, 风格, 颜色全部设置为一样.</p><p>例子如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">10px</span> solid red;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20220508161138157.png" alt=""><h6 id="连写格式-2"><a href="#连写格式-2" class="headerlink" title="连写格式 2"></a><strong>连写格式</strong> <strong>2</strong></h6><p>这种格式设置指定方向的边框的样式, 可以只设置一条边, 格式如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-top</span>: width style color;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border-right</span>: width style color;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border-bottom</span>: width style color;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border-left</span>: width style color;</span><br></pre></td></tr></tbody></table></figure><p>例子如下:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border-top</span>: <span class="number">10px</span> solid red;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20220508161311854.png" alt=""><p><strong>连写格式</strong> <strong>3</strong> </p><p>这种连写格式是指定一种属性, 按照上右下左四个方向进行设置边框, 格式如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-style</span>:上 右 下 左;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border-width</span>:上 右 下 左;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border-color</span>:上 右 下 左;</span><br></pre></td></tr></tbody></table></figure><p>其中, 后三个可以省略, 左省略则与右相同, 下省略则与上相同, 右省略与上相同</p><p>这里给两个示例:</p><p>示例 1:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border-style</span>: solid dashed dotted double;</span><br><span class="line"><span class="attribute">border-color</span>: red green blue purple;</span><br><span class="line"><span class="attribute">border-width</span>: <span class="number">5px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20220508161913218.png" alt=""><p>示例 2:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border-style</span>: solid dashed ;</span><br><span class="line"><span class="attribute">border-color</span>: red green blue;</span><br><span class="line"><span class="attribute">border-width</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>单写格式</strong> </p><p>单写格式指的是, 对每条边框的每个属性分别进行设置, 格式如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-top-width</span> <span class="attribute">border-top-style</span> <span class="attribute">border-top-color</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">border-right-width</span> <span class="attribute">border-right-style</span> <span class="attribute">border-right-color</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">border-bottom-width</span> <span class="attribute">border-bottom-style</span> <span class="attribute">border-bottom-color</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">border-left-width</span> <span class="attribute">border-left-style</span> <span class="attribute">border-left-color</span></span><br></pre></td></tr></tbody></table></figure><h4 id="字体属性-font"><a href="#字体属性-font" class="headerlink" title="字体属性 font"></a><strong>字体属性</strong> <strong>font</strong></h4><h5 id="font-style"><a href="#font-style" class="headerlink" title="font-style"></a><strong>font-style</strong></h5><p>作用: 设置字体风格</p><p>取值:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">normal</span>: 正常</span><br><span class="line"></span><br><span class="line">italic: 斜体</span><br><span class="line"></span><br><span class="line">oblique: 倾斜的字体</span><br></pre></td></tr></tbody></table></figure><p>关于 italic 和 oblique 的区别:</p><p>他们都是向右倾斜的文字, 大多数情况下看不出任何区别, 但是原理却不一样.</p><p>要搞清楚这个问题，首先要明白字体是怎么回事。一种字体有粗体、斜体、下划线、删除线</p><p>等诸多属性。但是并不是所有字体都做了这些，一些不常用的字体，或许就只有个正常体，如果你用 Italic，</p><p>就没有效果了,这时候就要用 Oblique.</p><p><font color="orange"><code>可以理解成 Italic 是使用文字的斜体，Oblique 是让没有斜体属性的文字倾斜！</code></font></p><h5 id="font-weight"><a href="#font-weight" class="headerlink" title="font-weight"></a><strong>font-weight</strong></h5><p>作用: 设置文字的粗细</p><p>取值:</p><p>它有两种取值, 一种是单次表示:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">normal</span>: 正常粗细</span><br><span class="line"></span><br><span class="line">bold: 加粗</span><br></pre></td></tr></tbody></table></figure><p>另一种是整数表示, 整数越大, 字体越粗</p><p>100, 200, 300, …, 900 </p><h5 id="font-size"><a href="#font-size" class="headerlink" title="font-size"></a><strong>font-size</strong></h5><p>作用: 设置字体大小</p><p>取值:</p><p>字体大小的取值是一个数值加上单位, 它的单位有 px , pt , 但一般都使用 px, 表示多少个像素, 如 20px, 表示字体的宽和高</p><p>说明:</p><p>注意，<font color="orange"><code>实际上它设置的是字体中字符框的高度；实际的字符字形可能比这些框高或矮（通常会矮）</code></font>。</p><p>各关键字对应的字体必须比一个最小关键字相应字体要高，并且要小于下一个最大关键字对应的字体。</p><h5 id="font-family"><a href="#font-family" class="headerlink" title="font-family"></a><strong>font-family</strong></h5><p>作用: 设置文字字体</p><p>取值: 各种字体名称</p><p>如果字体是中文, 尽量用双引号括起来</p><p>QSS 中 font-family 只能指定一种字体</p><h5 id="连写格式"><a href="#连写格式" class="headerlink" title="连写格式"></a><strong>连写格式</strong></h5><p>字体属性可以单写, 也可以连写, 连写格式如下:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">font</span>: style weight size family</span><br></pre></td></tr></tbody></table></figure><p>这种书写格式中的注意点:</p><blockquote><ol><li><p>style 和 weight 的位置可以交换, 并且可以省略;</p></li><li><p>size 不能被省略</p></li><li><p>size 和 family 必须写在其他两个属性的后面, 并且位置不能交换</p></li><li><p>family 可以省略, 省略后使用默认字体</p></li></ol></blockquote><p>举个例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">font</span>: normal normal <span class="number">30px</span> <span class="string">"隶书"</span>;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081631678.png"></p><h4 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a><strong>文本属性</strong></h4><h5 id="text-align"><a href="#text-align" class="headerlink" title="text-align"></a><strong>text-align</strong></h5><p>作用:设置文本的对齐方式</p><p>取值:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">top</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">bottom</span> </span><br><span class="line"></span><br><span class="line"><span class="attribute">left</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">right</span></span><br><span class="line"></span><br><span class="line">center</span><br></pre></td></tr></tbody></table></figure><p><font color="red">注意点: 支持这个属性的控件目前只有 QPushButton 和 QProgressBar.</font></p><p>格式:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">text-align</span>: 水平对齐方式(left, right, center) 垂直对齐方式(top bottom center);</span><br></pre></td></tr></tbody></table></figure><p>举个例子</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QPushButton{</span><br><span class="line"><span class="attribute">background-color</span>: pink;</span><br><span class="line"><span class="attribute">min-height</span>: <span class="number">80px</span>;</span><br><span class="line"><span class="attribute">text-align</span>: left top; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081638898.png"></p><h5 id="text-decoration"><a href="#text-decoration" class="headerlink" title="text-decoration"></a><strong>text-decoration</strong></h5><p>作用: 给文本添加装饰</p><p>取值:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">none</span>: 没有装饰</span><br><span class="line"></span><br><span class="line">underline: 下划线</span><br><span class="line"></span><br><span class="line">overline: 上划线</span><br><span class="line"></span><br><span class="line">line-through: 删除线</span><br></pre></td></tr></tbody></table></figure><p>举个例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line">    <span class="attribute">font</span>: normal normal <span class="number">30px</span> <span class="string">"微软雅黑"</span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#text_edit_1</span>{</span><br><span class="line"><span class="attribute">text-decoration</span>: none; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#text_edit_2</span>{</span><br><span class="line"><span class="attribute">text-decoration</span>: underline; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#text_edit_3</span>{</span><br><span class="line"><span class="attribute">text-decoration</span>: overline; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#text_edit_4</span>{</span><br><span class="line"><span class="attribute">text-decoration</span>: line-through; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081639340.png"></p><h4 id="padding-和-margin"><a href="#padding-和-margin" class="headerlink" title="padding 和 margin"></a><strong>padding</strong> <strong>和</strong> <strong>margin</strong></h4><p>盒模型中的 padding 和 margin 都可以连写, 也可以单独写, 它们都能完成四个方向上的边距设置, <font color="orange"><code>默认情况下都是 0.</code></font></p><p>与边框和其他连写格式一样, 如果它们连写时, 最多可以指定 4 个值, 最少指定 1 个值,指定 4 个时, 分别表示上右下左方向的边距, 省略时, 也有相同的效果, 即左省略时默认和右一样, 下省略时默认和上一样, 右省略时和上一样.</p><p>设置边距时, 数值后面必须要带像素单位, 即 px;</p><h5 id="padding"><a href="#padding" class="headerlink" title="padding"></a><strong>padding</strong></h5><p>padding 既可以连写也可以分四个方向单独设置,</p><p>格式如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">padding</span>: 上 右 下 左;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"><span class="attribute">padding-top</span>: ?px;</span><br><span class="line"></span><br><span class="line"><span class="attribute">padding-right</span>: ?px;</span><br><span class="line"></span><br><span class="line"><span class="attribute">padding-bottom</span>: ?px;</span><br><span class="line"></span><br><span class="line"><span class="attribute">padding-left</span>: ?px;</span><br></pre></td></tr></tbody></table></figure><h5 id="margin"><a href="#margin" class="headerlink" title="margin"></a><strong>margin</strong></h5><p>格式与 padding 类似, 具体如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">margin</span>: 上 右 下 左; </span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"><span class="attribute">margin</span> -<span class="attribute">top</span>: ?px;</span><br><span class="line"></span><br><span class="line"><span class="attribute">margin</span> -<span class="attribute">right</span>: ?px;</span><br><span class="line"></span><br><span class="line"><span class="attribute">margin</span> -<span class="attribute">bottom</span>: ?px;</span><br><span class="line"></span><br><span class="line"><span class="attribute">margin</span> -<span class="attribute">left</span>: ?px;</span><br></pre></td></tr></tbody></table></figure><p><font color="orange"><code>由于 Qt 将整个盒子看做是一个控件, 因此在布局时, 不会考虑每个盒子的垂直方向的外边距是否有合并现象等, 所以一个控件的外边距只会对自己产生影响, 不会对其他的控件产生影响.</code></font></p><p>下面看一个例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{</span><br><span class="line"><span class="attribute">border</span>: <span class="number">2px</span> solid red;</span><br><span class="line"><span class="attribute">background</span>: skyblue;</span><br><span class="line"><span class="attribute">background-clip</span>: margin;</span><br><span class="line"><span class="attribute">font</span>: normal normal <span class="number">30px</span> <span class="string">"微软雅黑"</span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#text_edit_1</span>{ </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">5px</span>; </span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>; </span><br><span class="line">    <span class="attribute">text-decoration</span>: none; </span><br><span class="line">} <span class="selector-id">#text_edit_2</span>{ </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>; </span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>; </span><br><span class="line">    <span class="attribute">text-decoration</span>: underline; </span><br><span class="line">} <span class="selector-id">#text_edit_3</span>{ </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">15px</span>; </span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span>; </span><br><span class="line">    <span class="attribute">text-decoration</span>: overline; </span><br><span class="line">} <span class="selector-id">#text_edit_4</span>{ </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>; </span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>; </span><br><span class="line">    <span class="attribute">text-decoration</span>: line-through; </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081644843.png"></p><h4 id="width-与-height"><a href="#width-与-height" class="headerlink" title="width 与 height"></a><strong>width</strong> <strong>与</strong> <strong>height</strong></h4><h5 id="width-height"><a href="#width-height" class="headerlink" title="width, height"></a><strong>width, height</strong></h5><ul><li>这两个属性设置的是<font color="orange"><code>盒子内容</code></font>的宽高.</li><li>这两个属性只对子控件选择器选中的对象有效</li><li>这两个属性的取值均是像素值, 即数字加像素单位 px;</li></ul><h5 id="max-width-min-width-与-max-height-min-height"><a href="#max-width-min-width-与-max-height-min-height" class="headerlink" title="max-width min width 与 max-height min-height"></a><strong>max-width min width</strong> <strong>与</strong> <strong>max-height min-height</strong></h5><ul><li>这四个属性对所有的 widget 都有效, 用来设置盒子内容的最小或最大尺寸</li><li>当最小宽度与最大宽度相等时, 意味着给这个盒子的内容设置了一个固定宽度.</li><li>当最小高度与最大高度相等时, 意味着给这个盒子的内容设置了一个固定高度.</li></ul><p>举个例子:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QComboBox{ </span><br><span class="line">    <span class="attribute">background-color</span>: skyblue; </span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red; </span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>; </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>; </span><br><span class="line">    <span class="attribute">background-clip</span>: content; </span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">50px</span>; </span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">50px</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081645397.png"></p><p><strong>outline</strong> </p><p>outline （轮廓）是控件有焦点时, 绘制在边框边缘的外围,可起到突出作用,轮廓线不占据控</p><p>件, 也不一定是矩形.</p><p>它有如下属性,</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">outline</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">outline-color</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">outline-offset</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">outline-style</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">outline</span>-radius</span><br><span class="line"></span><br><span class="line"><span class="attribute">outline</span>-<span class="attribute">bottom</span>-<span class="attribute">left</span>-radius</span><br><span class="line"></span><br><span class="line"><span class="attribute">outline</span>-<span class="attribute">bottom</span>-<span class="attribute">right</span>-radius</span><br><span class="line"></span><br><span class="line"><span class="attribute">outline</span>-<span class="attribute">top</span>-<span class="attribute">left</span>-radius</span><br><span class="line"></span><br><span class="line"><span class="attribute">outline</span>-<span class="attribute">top</span>-<span class="attribute">right</span>-radius</span><br></pre></td></tr></tbody></table></figure><p>这里对这些属性不做详细介绍, 只需要知道, 当我们想在一个控件有焦点时, 不绘制轮廓,</p><p>只需要这样做,</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">outline</span>: none;</span><br></pre></td></tr></tbody></table></figure><h3 id="属性结语"><a href="#属性结语" class="headerlink" title="属性结语"></a><strong>属性结语</strong></h3><p>这一小节主要列举了一些常用的属性, 并列举了它们的用法和取值等, 还有其他一些属性并未介绍, 但很可能在开发中需要用到. 这里啰嗦一下, 这种总结性质的东西, 不可能尽善尽美罗列所有, 如果有需要, 还是要去自己查看 Qt 官方给的资料, 查阅文档搜寻有用的知识也是一种很重要的技能.</p><h2 id="Brush-类型介绍"><a href="#Brush-类型介绍" class="headerlink" title="Brush 类型介绍"></a><strong>Brush</strong> <strong>类型介绍</strong></h2><p>brush 一般用来设置颜色, 其取值有 3 种, 分别是 <font color="orange">Color</font>, <font color="orange">Gradient </font>和 <font color="orange">PaletteRole</font>, 下面简单介绍一下</p><h3 id="Color"><a href="#Color" class="headerlink" title="Color"></a><strong>Color</strong></h3><p>color 本身又支持很多格式, 列举所有格式, 如下:</p><ul><li><p>rgb(r, g, b) 每个数字表示每个通道的值, 依次分别是红绿蓝</p></li><li><p>rgba(r, g, b, a) 与 rgb 相同, a 代表 α 通道, 是一个范围 0~1 的浮点数, 表示透明度, 1 代表不透明, 0 表示全透明</p></li><li><p>hsv(h, s, v)</p></li><li><p>hsva(h, s, v, a)</p></li><li><p>#rrggbb: 16 进制表示的 rgb 值, 每个值占两位, 但如果每个通道的两位都一样, 可以简写为</p></li><li><p>#rgb, 如#66FFAA 可以简写为 #6FA, 并且大小写不敏感.</p></li><li><p>name: 常见的表示颜色的单次, 如 red, green, blue, yellow, purple 等</p><p><font color="orange"><code>常用的是 rgb, rgba, #rrggbb, name</code></font></p></li></ul><h3 id="Gradient"><a href="#Gradient" class="headerlink" title="Gradient"></a><strong>Gradient</strong></h3><p>可实现渐变效果,三种取值:</p><ul><li>qlineargradient 线性渐变</li><li>qradialgradient 径向渐变</li><li>qconicalgradient 锥形渐变</li></ul><p>它们分别对应了 Qt 的 3 个类, <font color="orange"><code>QLinearGradient</code></font>, <font color="orange"><code>QRadialGradient</code></font>, <font color="orange"><code>QConicalGradient</code></font>, 参数可以</p><p>参考它们的函数, 这里不多赘述</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{ </span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid red; </span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">qlineargradient</span>(x1:<span class="number">0</span>, y1:<span class="number">0</span>, x2:<span class="number">1</span>, y2:<span class="number">1</span>, stop:<span class="number">0</span> </span><br><span class="line"><span class="number">#ace</span>, stop: <span class="number">0.4</span> <span class="number">#f96</span>, stop:<span class="number">1</span> <span class="number">#ace</span>); </span><br><span class="line">    <span class="attribute">background-clip</span>: margin; </span><br><span class="line">    <span class="attribute">font</span>: normal normal <span class="number">30px</span> <span class="string">"微软雅黑"</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081658453.png"></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{ </span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid red; </span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">qradialgradient</span>(cx:<span class="number">0</span>, cy:<span class="number">0</span>, radius: <span class="number">1</span>, </span><br><span class="line">        fx:<span class="number">0.5</span>, fy:<span class="number">0.5</span>, stop:<span class="number">0</span> <span class="number">#ace</span>, stop:<span class="number">1</span> <span class="number">#f96</span>); </span><br><span class="line">    <span class="attribute">background-clip</span>: margin; </span><br><span class="line">    <span class="attribute">font</span>: normal normal <span class="number">30px</span> <span class="string">"微软雅黑"</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081659550.png"></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit{ </span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid red; </span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">qconicalgradient</span>(cx:<span class="number">0.5</span>, cy:<span class="number">0.5</span>, angle:<span class="number">30</span>, </span><br><span class="line">                       stop:<span class="number">0</span> <span class="number">#ace</span>, stop:<span class="number">1</span> <span class="number">#f96</span>); </span><br><span class="line">    <span class="attribute">background-clip</span>: margin; </span><br><span class="line">    <span class="attribute">font</span>: normal normal <span class="number">30px</span> <span class="string">"微软雅黑"</span>; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Qt-官方链接"><a href="#Qt-官方链接" class="headerlink" title="Qt 官方链接"></a><strong>Qt</strong> <strong>官方链接</strong></h3><p>链接地址: <a href="http://doc.qt.io/qt-5/stylesheet.html">http://doc.qt.io/qt-5/stylesheet.html</a></p><p>assistan 搜索方法: 输入 style sheet 即可, 注意两个单词之间有空格, 然后进入</p><p>Qt Style Sheets Reference 专题, 如图:</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205081701854.png"></p><h3 id="加载QSS文件方法"><a href="#加载QSS文件方法" class="headerlink" title="加载QSS文件方法"></a>加载QSS文件方法</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可用过qApp对象设置整个程序的qss或者通过this指针设置单前界面的qss</span></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">qApp-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">"file:///:qss/defaultStyle.qss"</span>); <span class="comment">//通过qApp对象设置</span></span><br><span class="line">qApp-&gt;<span class="built_in">setStyleSheet</span>(<span class="built_in">QString</span>(<span class="string">"file:///%1"</span>).<span class="built_in">arg</span>(qssFileName));</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setStyleSheet</span>(<span class="string">"file:///:qss/defaultStyle.qss"</span>); <span class="comment">//通过this对象设置当前界面的qss</span></span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">setStyleSheet</span>(<span class="built_in">QString</span>(<span class="string">"file:///%1"</span>).<span class="built_in">arg</span>(qssFileName));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">QString qss;  </span><br><span class="line"><span class="function">QFile <span class="title">qssFile</span><span class="params">(<span class="string">":/qss/luffy.qss"</span>)</span></span>;  <span class="comment">//样式表文件</span></span><br><span class="line">qssFile.<span class="built_in">open</span>(QFile::ReadOnly);   </span><br><span class="line"><span class="keyword">if</span> (qssFile.<span class="built_in">isOpen</span>()) {        </span><br><span class="line">    qss = <span class="built_in">QLatin1String</span>(qssFile.<span class="built_in">readAll</span>());       </span><br><span class="line">    qApp-&gt;<span class="built_in">setStyleSheet</span>(qss);       </span><br><span class="line">    qssFile.<span class="built_in">close</span>();  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">QT入门，QT样式表</summary>
    
    
    
    <category term="QT" scheme="https://ouyujia.github.io/categories/QT/"/>
    
    <category term="QSS" scheme="https://ouyujia.github.io/categories/QT/QSS/"/>
    
    
    <category term="QT" scheme="https://ouyujia.github.io/tags/QT/"/>
    
    <category term="QSS" scheme="https://ouyujia.github.io/tags/QSS/"/>
    
    <category term="CSS" scheme="https://ouyujia.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CPU上下文</title>
    <link href="https://ouyujia.github.io/2022/05/05/CPU%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://ouyujia.github.io/2022/05/05/CPU%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2022-05-05T08:43:26.000Z</published>
    <updated>2023-04-28T05:56:04.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux 是一个多任务操作系统，它支持远大于 CPU 数量的任务同时运行。当然，这些任务实际上并不是真的在同时运行，而是因为系统在很短的时间内，将 CPU 轮流分配给它们，造成多任务同时运行的错觉。</p><p>而在每个任务运行前，CPU 都需要知道<font color="orange">任务从哪里加载</font>、又<font color="orange">从哪里开始运行</font>，任务执行的<font color="orange">状态</font>和<font color="orange">数据</font>等信息，也就是说，需要系统事先帮它设置好<font color="orange">CPU 寄存器</font>和<font color="orange">程序计数器</font>。</p><h2 id="什么是CPU上下文"><a href="#什么是CPU上下文" class="headerlink" title="什么是CPU上下文"></a>什么是CPU上下文</h2><blockquote><p>CPU 寄存器和程序计数器就是 CPU 上下文，因为它们都是 CPU 在运行任何任务前，必须的依赖环境。</p><ul><li>CPU 寄存器是 CPU 内置的容量小、但速度极快的内存。</li><li>程序计数器则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置</li></ul></blockquote><h2 id="什么是CPU上下文切换"><a href="#什么是CPU上下文切换" class="headerlink" title="什么是CPU上下文切换"></a>什么是CPU上下文切换</h2><blockquote><p>就是先把前一个任务的 CPU 上下文（也就是 CPU寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p><p>而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p></blockquote><h2 id="CPU上下文切换的类型"><a href="#CPU上下文切换的类型" class="headerlink" title="CPU上下文切换的类型"></a>CPU上下文切换的类型</h2><p>根据任务的不同，可以分为以下三种类型 - <font color="red">进程上下文切换</font> - <font color="red">线程上下文切换</font> - <font color="red">中断上下文切换</font></p><h4 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h4><p>Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中， CPU 特权等级的 Ring 0 和 Ring 3。</p><ul><li>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；</li><li>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205051655043.png" alt="image-20220505165129232"></p><p>进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。</p><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><blockquote><p>进程访问内核特定资源时将从用户态转为内核态。从用户态到内核态的转变，需要通过系统调用来完成。比如，当我们查看文件内容时，就需要多次系统调用来完成：首先调用 open()<br>打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件。</p><p>在这个过程中就发生了CPU上下文切换，整个过程是这样的：</p><ol><li>保存 CPU 寄存器里原来用户态的指令位</li><li>为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。</li><li>跳转到内核态运行内核任务。</li><li>当系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程<br>所以，<strong>一次系统调用的过程，其实是发生了两次 CPU 上下文切换</strong>。（<font color="orange">用户态-内核态  内核态-用户态</font>）</li></ol></blockquote><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这跟我们通常所说的进程上下文切换是不一样的：<font color="red"><code>进程上下文切换，是指从一个进程切换到另一个进程运行；而系统调用过程中一直是同一个进程在运行</code></font>.</p><p><font color="orange"><code>所以，系统调用过程通常称为特权模式切换，而不是上下文切换。系统调用属于同进程内的 CPU 上下文切换。但实际上，系统调用过程中，CPU 的上下文切换还是无法避免的。</code></font></p><h4 id="进程上下文切换与系统调用的区别"><a href="#进程上下文切换与系统调用的区别" class="headerlink" title="进程上下文切换与系统调用的区别"></a>进程上下文切换与系统调用的区别</h4><blockquote><p>进程是由内核来管理和调度的，<font color="orange"><code>进程的切换只能发生在内核态</code></font>。所以，<font color="greed"><strong>进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态</strong></font><br>因此，进程的上下文切换就比系统调用时多了一步：<font color="orange"><code>在保存内核态资源（当前进程的内核状态和 CPU 寄存器）之前，需要先把该进程的用户态资源（虚拟内存、栈等）保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</code></font></p></blockquote><p>如下图所示，保存上下文和恢复上下文的过程并不是“免费”的，需要内核在 CPU 上运行才能完成。</p><p><img src="https://cdn.jsdelivr.net/gh/ouyujia/blogImg/img/202205051707207.png" alt="image-20220505170736442"></p><h4 id="进程上下文切换潜在的性能问题"><a href="#进程上下文切换潜在的性能问题" class="headerlink" title="进程上下文切换潜在的性能问题"></a>进程上下文切换潜在的性能问题</h4><blockquote><p>根据 Tsuna 的测试报告，每次上下文切换都需要几十纳秒到数微秒的 CPU时间。</p><p>这个时间还是相当可观的，特别是在进程上下文切换次数较多的情况下，很容易导致 CPU将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，进而大大缩短了真正运行进程的时间。这也正是导致平均负载升高的一个重要因素。</p><p>另外，我们知道， Linux 通过 TLB（Translation LookasideBuffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB也需要刷新，内存的访问也会随之变慢。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。</p></blockquote><h4 id="发生进程上下文切换的场景"><a href="#发生进程上下文切换的场景" class="headerlink" title="发生进程上下文切换的场景"></a>发生进程上下文切换的场景</h4><blockquote><ol><li>为了保证所有进程可以得到公平调度，CPU时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU的进程运行。</li><li>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。</li><li>当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。</li><li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。</li><li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。</li></ol></blockquote><h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><blockquote><p>线程与进程最大的区别在于：<font color="red"><strong><code>线程是调度的基本单位，而进程则是资源拥有的基本单位</code></strong></font>。说白了，<font color="green">所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。</font></p><p>所以，对于线程和进程，我们可以这么理解： </p><ul><li>当进程只有一个线程时，可以认为进程就等于线程。 </li><li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。 </li><li>另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的</li></ul></blockquote><h4 id="发生线程上下文切换的场景"><a href="#发生线程上下文切换的场景" class="headerlink" title="发生线程上下文切换的场景"></a>发生线程上下文切换的场景</h4><blockquote><ol><li>前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。</li><li>前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据</li></ol></blockquote><h4 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h4><blockquote><p>为了快速响应硬件的事件，**<font color="orange"><code>中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件</code></font>。**而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。</p><p>**<font color="orange"><code>跟进程上下文不同，中断上下文切换并不涉及到进程的用户态</code></font>**。所以，即便中断过程打断了一个正处在用户态的进程，<font color="orange"><code>也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源(中断上下文切换不会覆盖这个进程的虚拟内存、全局变量等用户态资源)。</code></font>中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括CPU 寄存器、内核堆栈、硬件中断参数等。</p><p>**<font color="orange"><code>对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生</code></font>**。同样道理，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。</p><p>另外，跟进程上下文切换一样，中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的<br>CPU，甚至严重降低系统的整体性能。所以，当你发现中断次数过多时，就需要注意去排查它是否会给你的系统带来严重的性能问题。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Linux 是一个多任务操作系统，它支持远大于 CPU 数量的任务同时运行。当然，这些任务实际上并不是真的在同时运行，而是因为系统在很短的时</summary>
      
    
    
    
    <category term="操作系统" scheme="https://ouyujia.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="CPU上下文" scheme="https://ouyujia.github.io/tags/CPU%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
    <category term="多进程hexo" scheme="https://ouyujia.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8Bhexo/"/>
    
    <category term="多线程" scheme="https://ouyujia.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
